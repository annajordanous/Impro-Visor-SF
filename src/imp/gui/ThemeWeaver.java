/**
 * This Java Class is part of the Impro-Visor Application
 *
 * Copyright (C) 2015 Robert Keller and Harvey Mudd College
 *
 * Impro-Visor is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * Impro-Visor is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of merchantability or fitness
 * for a particular purpose. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Impro-Visor; if not, write to the Free Software Foundation, Inc., 51 Franklin
 * St, Fifth Floor, Boston, MA 02110-1301 USA
 */
package imp.gui;

import static imp.Constants.BEAT;
import imp.com.CommandManager;
import imp.com.InvertCommand;
import imp.com.LoadThemesCommand;
import imp.com.PlayScoreCommand;
import imp.com.RectifyPitchesCommand;
import imp.com.ReverseCommand;
import imp.com.SaveThemesCommand;
import imp.com.ShiftPitchesCommand;
import imp.data.ChordPart;
import imp.data.MelodyPart;
import imp.data.Note;
import imp.data.NoteSymbol;
import imp.data.Part;
import imp.data.PitchClass;
import imp.data.Unit;
import imp.lickgen.NoteConverter;
import imp.util.ThemesFilter;
import polya.Polylist;
import imp.lickgen.LickGen;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import javax.swing.table.DefaultTableModel;
import javax.swing.ListSelectionModel;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Arrays;
import javax.swing.AbstractListModel;
import javax.swing.JFileChooser;
import java.util.List;
import java.util.Random;
import java.util.Collections;
import java.util.LinkedHashMap;
import imp.util.ErrorLog;
import java.util.Map;
import imp.ImproVisor;
import imp.com.TimeWarpCommand;
import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.io.FileOutputStream;
import java.io.FileInputStream;
import polya.Tokenizer;
import imp.data.Score;
import javax.swing.table.DefaultTableCellRenderer;
import polya.PolylistEnum;
import java.util.Hashtable;
import javax.swing.JLabel;
import javax.swing.ImageIcon;
import java.awt.Font;
import java.awt.Component;

/**
 *
 * @author David Morrison, Nava Dallal, Amelia Sheppard
 */
@SuppressWarnings("serial")
public class ThemeWeaver extends javax.swing.JFrame
{

String TITLE = "Theme Weaver";
LickgenFrame lickgenFrame;
private static String themesExt = ".themes";
public String themesFile = "My" + themesExt;
JFileChooser themesfc;
private File savedThemes;

/**
 * Creates new form ThemeWeaver
 */
public ThemeWeaver(LickGen lickgen, Notate notate, CommandManager cm)
  {
    this.random = new Random();
    initComponents();
    //    testDialog.setVisible(true);
    this.cm = cm;
    this.lickgen = lickgen;
    this.notate = notate;

    setTitle(TITLE);
    WindowRegistry.registerWindow(this);
    soloTable.setModel(soloTableModel);
    soloTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
    soloTable.addMouseListener(new MouseAdapter()
    {
    @Override
    public void mouseReleased(MouseEvent e)
      {
        if( e.getClickCount() >= 1 )
          {
            int row = soloTable.rowAtPoint(e.getPoint());
            soloTable.getSelectionModel().setSelectionInterval(row, row);
          }

      }

    });
    setTableColumnWidths();
    themesfc = new JFileChooser();
    loadFromFile(fileName);
    
  }

public void setTableColumnWidths()
  {
    for( int j = 0; j < soloTableModel.getColumnCount(); j++ )
      {
        soloTable.getColumnModel().getColumn(j).
                setPreferredWidth(soloTableModel.getColumnWidths(j));
      }


    for( int j = 0; j < soloTableModel.getColumnCount(); j++ )
      {
        DefaultTableCellRenderer renderer = new DefaultTableCellRenderer();
        renderer.setHorizontalAlignment(soloTableModel.getColumnAdjustments(j));
        soloTable.getColumnModel().getColumn(j).setCellRenderer(renderer);
      }
  }
    



/**
 * This method is called from within the constructor to initialize the form.
 * WARNING: Do NOT modify this code. The content of this method is always
 * regenerated by the Form Editor.
 */
@SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        nameErrorMessage = new javax.swing.JDialog();
        nameField = new javax.swing.JTextField();
        namePicked = new javax.swing.JLabel();
        CancelButton = new javax.swing.JButton();
        OkButton = new javax.swing.JButton();
        chooseName = new javax.swing.JLabel();
        enteredIncorrectly = new javax.swing.JDialog();
        typedWrong = new javax.swing.JLabel();
        tryAgain = new javax.swing.JLabel();
        cellOkbutton = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        resetCheck = new javax.swing.JDialog();
        Resettable = new javax.swing.JLabel();
        youSure = new javax.swing.JLabel();
        YesButton = new javax.swing.JButton();
        NoButton = new javax.swing.JButton();
        noRowSelected = new javax.swing.JDialog();
        soloTableScrollPane = new javax.swing.JScrollPane();
        soloTable = new javax.swing.JTable();
        themeListScrollPane = new javax.swing.JScrollPane();
        themeList = new javax.swing.JList();
        themeUsageScrollPane = new javax.swing.JScrollPane();
        themeUsageTextArea = new javax.swing.JTextArea();
        SoloGeneratorTitle = new java.awt.Label();
        Reset = new javax.swing.JButton();
        themeIntervalTextField = new javax.swing.JTextField();
        themeIntervalLabel = new javax.swing.JLabel();
        noThemeProbTextField = new javax.swing.JTextField();
        noThemeProbLabel = new javax.swing.JLabel();
        generateSoloJButton = new javax.swing.JButton();
        generateThemeJButton = new javax.swing.JButton();
        currentSelectionJButton = new javax.swing.JButton();
        stopPlaytoggle = new javax.swing.JToggleButton();
        deleteRowbutton = new javax.swing.JButton();
        deleteThemebutton = new javax.swing.JButton();
        probExpandby2or3 = new javax.swing.JSlider();
        pitchRangeMinSlider = new javax.swing.JSlider();
        expandBy2Label = new javax.swing.JLabel();
        expandBy3Label = new javax.swing.JLabel();
        pitchRangeMinLabel = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        javax.swing.JLabel E7Label1 = new javax.swing.JLabel();
        javax.swing.JLabel E7Label2 = new javax.swing.JLabel();
        pitchRangeMaxSlider = new javax.swing.JSlider();
        jLabel4 = new javax.swing.JLabel();
        trans1ComboBox = new javax.swing.JComboBox();
        trans3ComboBox = new javax.swing.JComboBox();
        trans4ComboBox = new javax.swing.JComboBox();
        trans5ComboBox = new javax.swing.JComboBox();
        TransformationOrder = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        trans2ComboBox = new javax.swing.JComboBox();
        roadmapMenuBar = new javax.swing.JMenuBar();
        javax.swing.JMenu fileMenu = new javax.swing.JMenu();
        loadThemesMI = new javax.swing.JMenuItem();
        saveAsAdvice = new javax.swing.JMenuItem();
        javax.swing.JMenuItem exitMenuItem = new javax.swing.JMenuItem();
        windowMenu = new javax.swing.JMenu();
        closeWindowMI = new javax.swing.JMenuItem();
        cascadeMI = new javax.swing.JMenuItem();
        jSeparator5 = new javax.swing.JPopupMenu.Separator();
        windowMenuSeparator = new javax.swing.JSeparator();

        nameErrorMessage.setMinimumSize(new java.awt.Dimension(500, 400));
        nameErrorMessage.getContentPane().setLayout(new java.awt.GridBagLayout());

        nameField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nameFieldActionPerformed(evt);
            }
        });
        nameField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                nameFieldKeyPressed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 4;
        gridBagConstraints.ipadx = 309;
        gridBagConstraints.ipady = 12;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 20, 0, 0);
        nameErrorMessage.getContentPane().add(nameField, gridBagConstraints);

        namePicked.setText("The name you have picked is already assigned to a theme. ");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 5;
        gridBagConstraints.ipadx = 75;
        gridBagConstraints.ipady = 15;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(53, 20, 0, 0);
        nameErrorMessage.getContentPane().add(namePicked, gridBagConstraints);

        CancelButton.setText("Cancel");
        CancelButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CancelButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(12, 43, 105, 0);
        nameErrorMessage.getContentPane().add(CancelButton, gridBagConstraints);

        OkButton.setText("Ok");
        OkButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                OkButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.ipadx = -18;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(12, 20, 105, 0);
        nameErrorMessage.getContentPane().add(OkButton, gridBagConstraints);

        chooseName.setText("Please choose another:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.ipadx = 44;
        gridBagConstraints.ipady = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 20, 0, 0);
        nameErrorMessage.getContentPane().add(chooseName, gridBagConstraints);

        enteredIncorrectly.setMinimumSize(new java.awt.Dimension(400, 300));
        enteredIncorrectly.getContentPane().setLayout(new java.awt.GridBagLayout());

        typedWrong.setText("You have either typed information into a cell incorrectly,");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(80, 24, 0, 21);
        enteredIncorrectly.getContentPane().add(typedWrong, gridBagConstraints);

        tryAgain.setText("Please try again.");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 6, 0, 0);
        enteredIncorrectly.getContentPane().add(tryAgain, gridBagConstraints);

        cellOkbutton.setText("Ok");
        cellOkbutton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cellOkbuttonActionPerformed(evt);
            }
        });
        cellOkbutton.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                cellOkbuttonKeyPressed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(18, 79, 107, 0);
        enteredIncorrectly.getContentPane().add(cellOkbutton, gridBagConstraints);

        jLabel1.setText("not finished entering contents into a cell, or left a cell");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 4;
        gridBagConstraints.ipadx = 15;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(12, 24, 0, 21);
        enteredIncorrectly.getContentPane().add(jLabel1, gridBagConstraints);

        jLabel2.setText("blank.");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 24, 0, 0);
        enteredIncorrectly.getContentPane().add(jLabel2, gridBagConstraints);

        resetCheck.setMinimumSize(new java.awt.Dimension(500, 300));
        resetCheck.getContentPane().setLayout(new java.awt.GridBagLayout());

        Resettable.setText("Resetting the table will clear everything you currently have entered. ");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 5;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(96, 39, 0, 77);
        resetCheck.getContentPane().add(Resettable, gridBagConstraints);

        youSure.setText("Are you sure you want to do this?");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 137, 0, 0);
        resetCheck.getContentPane().add(youSure, gridBagConstraints);

        YesButton.setText("Yes, Continue");
        YesButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                YesButtonActionPerformed(evt);
            }
        });
        YesButton.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                YesButtonKeyPressed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(31, 78, 150, 0);
        resetCheck.getContentPane().add(YesButton, gridBagConstraints);

        NoButton.setText("No, Cancel");
        NoButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                NoButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.ipadx = 16;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(31, 76, 150, 0);
        resetCheck.getContentPane().add(NoButton, gridBagConstraints);

        setAlwaysOnTop(true);
        setLocation(new java.awt.Point(10, 10));
        setLocationByPlatform(true);
        setMaximumSize(new java.awt.Dimension(1500, 1000));
        setMinimumSize(new java.awt.Dimension(1500, 800));
        setPreferredSize(new java.awt.Dimension(1500, 800));
        setSize(new java.awt.Dimension(1500, 700));
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosed(java.awt.event.WindowEvent evt) {
                ThemeWeaver.this.windowClosed(evt);
            }
        });
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
        });
        getContentPane().setLayout(new java.awt.GridBagLayout());

        soloTableScrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        soloTableScrollPane.setMaximumSize(new java.awt.Dimension(32767, 400));
        soloTableScrollPane.setMinimumSize(new java.awt.Dimension(23, 350));
        soloTableScrollPane.setPreferredSize(new java.awt.Dimension(469, 200));

        soloTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null}
            },
            new String [] {
                "Name", "Theme Length", "Theme", "Prob. to Use", "Prob. to Transpose", "Prob. to Invert", "Prob. to Reverse", "Prob. to Expand", "Prob. to Side Slip"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }
        });
        soloTable.setToolTipText("shift-click a cell in a row of a theme to listen to it");
        soloTable.setAlignmentY(1.0F);
        soloTable.setColumnSelectionAllowed(true);
        soloTable.setGridColor(new java.awt.Color(0, 0, 0));
        soloTable.setMinimumSize(new java.awt.Dimension(105, 200));
        soloTable.setSelectionBackground(javax.swing.UIManager.getDefaults().getColor("CheckBoxMenuItem.selectionBackground"));
        soloTable.setShowGrid(true);
        soloTable.getTableHeader().setReorderingAllowed(false);
        soloTable.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                soloTableMouseClicked(evt);
            }
        });
        soloTable.addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentShown(java.awt.event.ComponentEvent evt) {
                soloTableComponentShown(evt);
            }
        });
        soloTable.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                soloTableKeyPressed(evt);
            }
        });
        soloTableScrollPane.setViewportView(soloTable);
        soloTable.getColumnModel().getSelectionModel().setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.gridheight = 6;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.ipadx = 800;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.weightx = 0.8;
        gridBagConstraints.weighty = 0.3;
        gridBagConstraints.insets = new java.awt.Insets(19, 35, 0, 0);
        getContentPane().add(soloTableScrollPane, gridBagConstraints);

        themeListScrollPane.setMaximumSize(new java.awt.Dimension(0, 0));
        themeListScrollPane.setMinimumSize(new java.awt.Dimension(0, 0));
        themeListScrollPane.setPreferredSize(new java.awt.Dimension(100, 100));

        themeList.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        themeList.setModel(themeListModel);
        themeList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        themeList.setToolTipText("shift-click a theme to listen to it");
        themeList.setLayoutOrientation(javax.swing.JList.VERTICAL_WRAP);
        themeList.setPreferredSize(null);
        themeList.setVisibleRowCount(30);
        themeList.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                themeListClicked(evt);
            }
        });
        themeList.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                themeListKeyPressed(evt);
            }
        });
        themeListScrollPane.setViewportView(themeList);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 4;
        gridBagConstraints.gridy = 7;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.gridheight = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.VERTICAL;
        gridBagConstraints.ipadx = 320;
        gridBagConstraints.ipady = 200;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 0.3;
        gridBagConstraints.insets = new java.awt.Insets(0, 20, 0, 0);
        getContentPane().add(themeListScrollPane, gridBagConstraints);

        themeUsageScrollPane.setMinimumSize(new java.awt.Dimension(300, 100));

        themeUsageTextArea.setColumns(20);
        themeUsageTextArea.setRows(70);
        themeUsageScrollPane.setViewportView(themeUsageTextArea);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 13;
        gridBagConstraints.gridwidth = 4;
        gridBagConstraints.gridheight = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 0.6;
        gridBagConstraints.weighty = 0.3;
        gridBagConstraints.insets = new java.awt.Insets(0, 10, 5, 10);
        getContentPane().add(themeUsageScrollPane, gridBagConstraints);

        SoloGeneratorTitle.setFont(new java.awt.Font("Lucida Grande", 1, 24)); // NOI18N
        SoloGeneratorTitle.setMaximumSize(new java.awt.Dimension(327, 327));
        SoloGeneratorTitle.setText("Theme Weaver ");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 8;
        gridBagConstraints.ipady = -7;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(10, 0, 15, 0);
        getContentPane().add(SoloGeneratorTitle, gridBagConstraints);

        Reset.setText("Reset");
        Reset.setToolTipText("Clears the table of all themes currently entered");
        Reset.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ResetActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 5;
        gridBagConstraints.gridy = 11;
        gridBagConstraints.gridheight = 2;
        gridBagConstraints.ipadx = 32;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTH;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 50);
        getContentPane().add(Reset, gridBagConstraints);

        themeIntervalTextField.setText("8");
        themeIntervalTextField.setMaximumSize(new java.awt.Dimension(50, 2147483647));
        themeIntervalTextField.setMinimumSize(new java.awt.Dimension(50, 28));
        themeIntervalTextField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                themeIntervalTextFieldActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 5;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        getContentPane().add(themeIntervalTextField, gridBagConstraints);

        themeIntervalLabel.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        themeIntervalLabel.setText("Theme Use Interval");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 4;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.ipadx = 5;
        gridBagConstraints.insets = new java.awt.Insets(0, 30, 0, 0);
        getContentPane().add(themeIntervalLabel, gridBagConstraints);

        noThemeProbTextField.setText("0.5");
        noThemeProbTextField.setMaximumSize(new java.awt.Dimension(50, 2147483647));
        noThemeProbTextField.setMinimumSize(new java.awt.Dimension(50, 28));
        noThemeProbTextField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                noThemeProbTextFieldActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 5;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        getContentPane().add(noThemeProbTextField, gridBagConstraints);

        noThemeProbLabel.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        noThemeProbLabel.setText("No-Theme Prob.");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 4;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.ipadx = 5;
        gridBagConstraints.insets = new java.awt.Insets(0, 40, 0, 0);
        getContentPane().add(noThemeProbLabel, gridBagConstraints);

        generateSoloJButton.setText("Generate Solo");
        generateSoloJButton.setToolTipText("Creates a solo from the themes in the table and displays and plays the solo in the leadsheet window");
        generateSoloJButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                generateSoloJButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 2.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 35, 0, 0);
        getContentPane().add(generateSoloJButton, gridBagConstraints);

        generateThemeJButton.setText("Generate Theme");
        generateThemeJButton.setToolTipText("Generates a theme for every non empty length cell in the table that doesn't have a corresponding theme");
        generateThemeJButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                generateThemeJButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 9;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 2.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 35, 0, 0);
        getContentPane().add(generateThemeJButton, gridBagConstraints);

        currentSelectionJButton.setText("Use Current Selection in Leadsheet Window as Theme");
        currentSelectionJButton.setToolTipText("Adds the selection from the window into the first empty theme cell in the table");
        currentSelectionJButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                currentSelectionJButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 10;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 2.0;
        gridBagConstraints.insets = new java.awt.Insets(10, 35, 0, 0);
        getContentPane().add(currentSelectionJButton, gridBagConstraints);

        stopPlaytoggle.setBackground(new java.awt.Color(255, 255, 255));
        stopPlaytoggle.setText("Stop Playing");
        stopPlaytoggle.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                stopPlaytoggleActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.insets = new java.awt.Insets(0, 35, 0, 0);
        getContentPane().add(stopPlaytoggle, gridBagConstraints);

        deleteRowbutton.setText("Delete Selected Row");
        deleteRowbutton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                deleteRowbuttonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 13;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.insets = new java.awt.Insets(0, 35, 0, 0);
        getContentPane().add(deleteRowbutton, gridBagConstraints);

        deleteThemebutton.setText("Delete Theme From File");
        deleteThemebutton.setPreferredSize(new java.awt.Dimension(78, 29));
        deleteThemebutton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                deleteThemebuttonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 5;
        gridBagConstraints.gridy = 10;
        gridBagConstraints.ipadx = 32;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTH;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 50);
        getContentPane().add(deleteThemebutton, gridBagConstraints);

        probExpandby2or3.setFont(new java.awt.Font("Lucida Grande", 0, 5)); // NOI18N
        probExpandby2or3.setMajorTickSpacing(50);
        probExpandby2or3.setMinorTickSpacing(5);
        probExpandby2or3.setPaintLabels(true);
        probExpandby2or3.setPaintTicks(true);
        probExpandby2or3.setMinimumSize(new java.awt.Dimension(280, 29));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 5;
        gridBagConstraints.gridy = 3;
        getContentPane().add(probExpandby2or3, gridBagConstraints);

        pitchRangeMinSlider.setMajorTickSpacing(10);
        pitchRangeMinSlider.setMinimum(40);
        pitchRangeMinSlider.setMinorTickSpacing(1);
        pitchRangeMinSlider.setPaintLabels(true);
        pitchRangeMinSlider.setPaintTicks(true);
        pitchRangeMinSlider.setToolTipText("");
        pitchRangeMinSlider.setValue(60);
        pitchRangeMinSlider.setMinimumSize(new java.awt.Dimension(280, 52));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 5;
        gridBagConstraints.gridy = 4;
        getContentPane().add(pitchRangeMinSlider, gridBagConstraints);

        expandBy2Label.setText("Expand by 2");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 4;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        getContentPane().add(expandBy2Label, gridBagConstraints);

        expandBy3Label.setText("Expand by 3");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 6;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.ipadx = 40;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        getContentPane().add(expandBy3Label, gridBagConstraints);

        pitchRangeMinLabel.setText("Pitch Range Minimum      E2");
        pitchRangeMinLabel.setToolTipText("");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 4;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        getContentPane().add(pitchRangeMinLabel, gridBagConstraints);
        pitchRangeMinLabel.getAccessibleContext().setAccessibleName("Pitch Range Minimum       E2");

        jLabel3.setText("Pitch Range Maximum     E2");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 4;
        gridBagConstraints.gridy = 5;
        getContentPane().add(jLabel3, gridBagConstraints);

        E7Label1.setText("E7");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 6;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        getContentPane().add(E7Label1, gridBagConstraints);

        E7Label2.setText("E7");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 6;
        gridBagConstraints.gridy = 5;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        getContentPane().add(E7Label2, gridBagConstraints);

        pitchRangeMaxSlider.setMajorTickSpacing(10);
        pitchRangeMaxSlider.setMinimum(40);
        pitchRangeMaxSlider.setMinorTickSpacing(1);
        pitchRangeMaxSlider.setPaintLabels(true);
        pitchRangeMaxSlider.setPaintTicks(true);
        pitchRangeMaxSlider.setValue(80);
        pitchRangeMaxSlider.setMinimumSize(new java.awt.Dimension(280, 52));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 5;
        gridBagConstraints.gridy = 5;
        getContentPane().add(pitchRangeMaxSlider, gridBagConstraints);

        jLabel4.setFont(new java.awt.Font("Lucida Grande", 1, 18)); // NOI18N
        jLabel4.setText("             Themes                      ");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 5;
        gridBagConstraints.gridy = 6;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.ipadx = 10;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTH;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 40);
        getContentPane().add(jLabel4, gridBagConstraints);

        trans1ComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Transpose", "Invert", "Reverse", "Expand", "Side Slip" }));
        trans1ComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                trans1ComboBoxActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.ipady = 24;
        getContentPane().add(trans1ComboBox, gridBagConstraints);

        trans3ComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Reverse", "Expand", "Side Slip" }));
        trans3ComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                trans3ComboBoxActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 6;
        gridBagConstraints.ipady = 24;
        getContentPane().add(trans3ComboBox, gridBagConstraints);

        trans4ComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Expand", "Side Slip" }));
        trans4ComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                trans4ComboBoxActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 7;
        gridBagConstraints.ipady = 24;
        getContentPane().add(trans4ComboBox, gridBagConstraints);

        trans5ComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Side Slip" }));
        trans5ComboBox.setToolTipText("");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 8;
        gridBagConstraints.ipady = 24;
        getContentPane().add(trans5ComboBox, gridBagConstraints);

        TransformationOrder.setFont(new java.awt.Font("Lucida Grande", 1, 16)); // NOI18N
        TransformationOrder.setText("Transformation Order");
        TransformationOrder.setToolTipText("If a transformation is entered more than once, it will use the default order (Transpose, Invert, Reverse, Expand, Side Slip).");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 3;
        getContentPane().add(TransformationOrder, gridBagConstraints);

        jLabel5.setText("1:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(0, 15, 0, 0);
        getContentPane().add(jLabel5, gridBagConstraints);

        jLabel6.setText("2:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 5;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(0, 15, 0, 0);
        getContentPane().add(jLabel6, gridBagConstraints);

        jLabel7.setText("3:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 6;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(0, 15, 0, 0);
        getContentPane().add(jLabel7, gridBagConstraints);

        jLabel8.setText("4:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 7;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(0, 15, 0, 0);
        getContentPane().add(jLabel8, gridBagConstraints);

        jLabel9.setText("5:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 8;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(0, 15, 0, 0);
        getContentPane().add(jLabel9, gridBagConstraints);

        trans2ComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Invert", "Reverse", "Expand", "Side Slip" }));
        trans2ComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                trans2ComboBoxActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 5;
        gridBagConstraints.ipady = 24;
        getContentPane().add(trans2ComboBox, gridBagConstraints);

        fileMenu.setText("File"); // NOI18N
        fileMenu.setMaximumSize(new java.awt.Dimension(50, 40));
        fileMenu.setPreferredSize(new java.awt.Dimension(50, 21));

        loadThemesMI.setText("Load Themes File");
        loadThemesMI.setToolTipText("Load a new vocabulary.");
        loadThemesMI.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                loadThemesMIActionPerformed(evt);
            }
        });
        fileMenu.add(loadThemesMI);

        saveAsAdvice.setText("Save Themes As");
        saveAsAdvice.setToolTipText("Save the current vocabulary in a file.");
        saveAsAdvice.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveAsThemesActionPerformed(evt);
            }
        });
        fileMenu.add(saveAsAdvice);

        exitMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Q, java.awt.event.InputEvent.CTRL_MASK));
        exitMenuItem.setText("Close this window."); // NOI18N
        exitMenuItem.setToolTipText("Closes this window."); // NOI18N
        exitMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitMenuItemexitMIhandler(evt);
            }
        });
        fileMenu.add(exitMenuItem);

        roadmapMenuBar.add(fileMenu);

        windowMenu.setMnemonic('W');
        windowMenu.setText("Window"); // NOI18N
        windowMenu.addMenuListener(new javax.swing.event.MenuListener() {
            public void menuSelected(javax.swing.event.MenuEvent evt) {
                windowMenuMenuSelected(evt);
            }
            public void menuDeselected(javax.swing.event.MenuEvent evt) {
            }
            public void menuCanceled(javax.swing.event.MenuEvent evt) {
            }
        });

        closeWindowMI.setMnemonic('C');
        closeWindowMI.setText("Close Window"); // NOI18N
        closeWindowMI.setToolTipText("Closes the current window (exits program if there are no other windows)"); // NOI18N
        closeWindowMI.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                closeWindowMIActionPerformed(evt);
            }
        });
        windowMenu.add(closeWindowMI);

        cascadeMI.setMnemonic('A');
        cascadeMI.setText("Cascade Windows"); // NOI18N
        cascadeMI.setToolTipText("Rearrange windows into a cascade.\n"); // NOI18N
        cascadeMI.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cascadeMIActionPerformed(evt);
            }
        });
        windowMenu.add(cascadeMI);
        windowMenu.add(jSeparator5);
        windowMenu.add(windowMenuSeparator);

        roadmapMenuBar.add(windowMenu);

        setJMenuBar(roadmapMenuBar);

        pack();
    }// </editor-fold>//GEN-END:initComponents

public void stopPlaying()
  {
    notate.stopPlaying();
  }

private void playSelection()
  {
    notate.getCurrentStave().playSelection(false, notate.getLoopCount(), PlayScoreCommand.USEDRUMS, "LickGenFrame");
  }
    private void soloTableComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_soloTableComponentShown
        // TODO add your handling code here:
    }//GEN-LAST:event_soloTableComponentShown

    private void soloTableKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_soloTableKeyPressed
        int index = soloTable.getSelectedRow();
        int col = soloTable.getSelectedColumn();

        if( evt.getKeyCode() == KeyEvent.VK_DELETE )
          {
            soloTableModel.removeRow(index);
          }

        // When enter is pressed on this cell, keep the same cell selected
        // (This can be conditioned on column later if desired.)
        if( evt.getKeyCode() == KeyEvent.VK_ENTER )
          {
            //index = index <= 1 ? 0 : index-1;
            //soloTable.setRowSelectionInterval(index, index);

            if( col == THEME_COLUMN && getValueAt(index, THEME_COLUMN) != null )
              {
                //System.out.println("Theme at row " + index + " entered");
                MelodyPart melody = new MelodyPart((String) getValueAt(index, THEME_COLUMN));
                int themeLengthBeats = melody.getSize() / BEAT;
                soloTable.setValueAt(themeLengthBeats + "", index, LENGTH_COLUMN);
              }
          }
    }//GEN-LAST:event_soloTableKeyPressed

    private void ResetActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ResetActionPerformed
        resetCheck.setVisible(true);

    }//GEN-LAST:event_ResetActionPerformed

    private void soloTableMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_soloTableMouseClicked
        //Play a theme in the table using shift-click
        if( evt.isShiftDown() )
          {
            int index = soloTable.getSelectedRow();

            String name = (String) getValueAt(index, NAME_COLUMN);
            Score score = new Score(name);

            String themeString = (String) getValueAt(index, THEME_COLUMN);
            MelodyPart melody = new MelodyPart(themeString);

            score.addPart(melody);
            PatternDisplay.playScore(notate, score, themeWeaver);
          }
    }//GEN-LAST:event_soloTableMouseClicked

    private void themeListClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_themeListClicked
        if( !evt.isShiftDown() )
          {
            // add theme into table if clicked and not shift-clicked
            for( int i = 0; i < orderedThemes.size(); i++ )
              { //loop through size of orderedThemes
                for( int j = 0; j < soloTable.getRowCount(); j++ )
                  {//loop through table

                    if( themeList.isSelectedIndex(i)
                            && (getValueAt(j, NAME_COLUMN) == null)
                            && (getValueAt(j, THEME_COLUMN) == null)
                            && (getValueAt(j, LENGTH_COLUMN) == null) )
                      {
                        //if a theme in the Themes scroll box is clicked and a theme
                        //cell is selected and there is an empty row

                        if( (getValueAt(j, USE_COLUMN) == null)
                                && (getValueAt(j, TRANSPOSE_COLUMN) == null)
                                && (getValueAt(j, INVERT_COLUMN) == null)
                                && (getValueAt(j, REVERSE_COLUMN) == null) )
                          {
                            // if the weighted value cells are null
                            //set default values for weighted values
                            soloTable.setValueAt(USE_DEFAULT_VALUE, j, USE_COLUMN);
                            soloTable.setValueAt(TRANSPOSE_DEFAULT_VALUE, j, TRANSPOSE_COLUMN);
                            soloTable.setValueAt(INVERT_DEFAULT_VALUE, j, INVERT_COLUMN);
                            soloTable.setValueAt(REVERSE_DEFAULT_VALUE, j, REVERSE_COLUMN);
                            soloTable.setValueAt(EXPAND_DEFAULT_VALUE, j, EXPAND_COLUMN);
                            soloTable.setValueAt(SIDESLIP_DEFAULT_VALUE, j, SIDESLIP_COLUMN);
                          }

                        String name = (String) themeList.getSelectedValue();
                        //set name equal to the one clicked in the scroll box

                        for( Map.Entry pair : allThemes.entrySet() )
                          {
                            //loop through entries in allThemes

                            if( name == pair.getValue() )
                              { //if the name in the themeList is equal to the name in the entry
                                Theme theme = (Theme) pair.getKey();
                                //set theme equal to the corresponding theme in that entry
                                MelodyPart melody = theme.melody; //get the melody of the theme
                                Part.PartIterator k = melody.iterator(); //iterate over melody
                                String themestring = ""; //set theme as empty to start

                                while( k.hasNext() ) //while you can still iterate through the melody
                                  {
                                    Unit unit = k.next();
                                    if( unit != null ) //if next isn't empty
                                      {
                                        themestring += unit.toLeadsheet() + " ";
                                        //add it to the theme in leadsheet notation
                                      }
                                  }

                                setValueAt(name, j, NAME_COLUMN);
                                //paste in the name of theme to the table
                                setValueAt(melody.size() / BEAT + "", j, LENGTH_COLUMN);
                                //paste in the theme length
                                setValueAt(themestring, j, THEME_COLUMN);
                                //paste in the theme in leadsheet notation

                                //in case the length is different than the one typed by the user 
                                int n = 0;

                                for( int x = 0; x < soloTable.getRowCount(); x++ )
                                  { //loop through table
                                    if( (getValueAt(x, NAME_COLUMN) != null)
                                            && ((((String) getValueAt(x, NAME_COLUMN)).equals(name))
                                            || ((String) getValueAt(x, NAME_COLUMN)).equals(name + "- " + n))
                                            && (x != j)
                                            && (((String) getValueAt(x, THEME_COLUMN)).equals(themestring)) )
                                      {

                                        n += 1; //add one to n so if the same theme 
                                        //is already in the table it will be differentiated from it
                                        //if the names are the same, the rows are different,
                                        //the themes are the same, the lengths are different
                                        setValueAt(melody.size() / BEAT + "", x, LENGTH_COLUMN);
                                        //make the lengths the same 
                                        setValueAt(name + "- " + n, j, NAME_COLUMN);

                                        //make a copy of the theme and add it to the file and scroll box
                                        Theme copy = Theme.makeTheme(name + "- " + n, melody);
                                        addTheme(copy);
                                        saveRules(fileName);
                                        break;
                                      }
                                  }
                                break;
                              }
                          }
                        break;
                      }
                  }
              }
          }

        //Play selected theme if shift-clicked
        if( evt.isShiftDown() )
          {
            for( int i = 0; i < orderedThemes.size(); i++ )
              { //loop through all saved themes
                if( themeList.isSelectedIndex(i) )
                  {
                    String name = (String) themeList.getSelectedValue();
                    Score score = new Score(name);
                    //create empty score with name of theme selected
                    for( Map.Entry pair : allThemes.entrySet() )
                      {
                        //loop through entries in allThemes

                        if( name == pair.getValue() )
                          {
                            //if the name in the themeList is equal to the name in the entry
                            Theme theme = (Theme) pair.getKey();
                            //set theme equal to the corresponding theme in that entry
                            MelodyPart melody = theme.melody; //get the melody of the theme
                            score.addPart(melody);
                            PatternDisplay.playScore(notate, score, themeWeaver);
                          }
                      }
                  }
              }
          }
    }//GEN-LAST:event_themeListClicked

    private void OkButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_OkButtonActionPerformed
        if( orderedThemes.contains(nameField.getText()) )
          { //if the user enters a name that is already in orderedThemes
            nameErrorMessage.setVisible(true); //same error message pops up
          }
        else
          {
            for( int i = 0; i < soloTable.getRowCount(); i++ )
              {// loop through table

                if( soloTable.isCellSelected(i, NAME_COLUMN) )
                  {
                    setValueAt(nameField.getText(), i, NAME_COLUMN);
                    //set the name in the table
                    String name = nameField.getText();
                    String melodyString = (String) getValueAt(i, THEME_COLUMN);
                    MelodyPart themeMelody = new MelodyPart(melodyString);
                    Theme theme = Theme.makeTheme(name, themeMelody);

                    addTheme(theme);
                    saveRules(fileName);
                    //add the theme to the scroll box and save it
                  }
              }
          }
        nameErrorMessage.setVisible(false); //close the error window
    }//GEN-LAST:event_OkButtonActionPerformed

    private void CancelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CancelButtonActionPerformed
        nameErrorMessage.setVisible(false);
    }//GEN-LAST:event_CancelButtonActionPerformed

    private void cellOkbuttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cellOkbuttonActionPerformed
        enteredIncorrectly.setVisible(false);
    }//GEN-LAST:event_cellOkbuttonActionPerformed

    private void nameFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nameFieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_nameFieldActionPerformed

    private void YesButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_YesButtonActionPerformed
        soloTableModel.tableReset();
        resetCheck.setVisible(false);
    }//GEN-LAST:event_YesButtonActionPerformed

    private void NoButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_NoButtonActionPerformed
        resetCheck.setVisible(false);
    }//GEN-LAST:event_NoButtonActionPerformed

    private void themeListKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_themeListKeyPressed
    }//GEN-LAST:event_themeListKeyPressed

    private void formKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed
    }//GEN-LAST:event_formKeyPressed

    private void nameFieldKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_nameFieldKeyPressed
        if( evt.getKeyCode() == KeyEvent.VK_ENTER )
          {
            if( orderedThemes.contains(nameField.getText()) )
              {
                //if the user enters a name that is already in orderedThemes
                nameErrorMessage.setVisible(true); //same error message pops up
              }
            else
              {
                for( int i = 0; i < soloTable.getRowCount(); i++ )
                  {// loop through table
                    if( soloTable.isCellSelected(i, NAME_COLUMN) )
                      {
                        setValueAt(nameField.getText(), i, NAME_COLUMN);
                        //set the name in the table
                        String name = nameField.getText();
                        String melodyString = (String) getValueAt(i, THEME_COLUMN);
                        MelodyPart themeMelody = new MelodyPart(melodyString);
                        Theme theme = Theme.makeTheme(name, themeMelody);
                        addTheme(theme);
                        saveRules(fileName);
                        //add the theme
                      }
                  }
              }
            nameErrorMessage.setVisible(false); //close the error window
          }
    }//GEN-LAST:event_nameFieldKeyPressed

    private void cellOkbuttonKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_cellOkbuttonKeyPressed
        enteredIncorrectly.setVisible(false);
    }//GEN-LAST:event_cellOkbuttonKeyPressed

    private void YesButtonKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_YesButtonKeyPressed
        soloTableModel.tableReset();
        resetCheck.setVisible(false);
    }//GEN-LAST:event_YesButtonKeyPressed

    private void windowClosed(java.awt.event.WindowEvent evt)//GEN-FIRST:event_windowClosed
    {//GEN-HEADEREND:event_windowClosed
        closeWindow();
    }//GEN-LAST:event_windowClosed

    private void exitMenuItemexitMIhandler(java.awt.event.ActionEvent evt)//GEN-FIRST:event_exitMenuItemexitMIhandler
    {//GEN-HEADEREND:event_exitMenuItemexitMIhandler
        closeWindow();
    }//GEN-LAST:event_exitMenuItemexitMIhandler

    private void closeWindowMIActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_closeWindowMIActionPerformed
    {//GEN-HEADEREND:event_closeWindowMIActionPerformed
        closeWindow();
    }//GEN-LAST:event_closeWindowMIActionPerformed

private void closeWindow()
  {
    WindowRegistry.unregisterWindow(this);
    setVisible(false);
  }

    private void cascadeMIActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_cascadeMIActionPerformed
    {//GEN-HEADEREND:event_cascadeMIActionPerformed
        WindowRegistry.cascadeWindows(this);
    }//GEN-LAST:event_cascadeMIActionPerformed

    private void windowMenuMenuSelected(javax.swing.event.MenuEvent evt)//GEN-FIRST:event_windowMenuMenuSelected
    {//GEN-HEADEREND:event_windowMenuMenuSelected
        windowMenu.removeAll();

        windowMenu.add(closeWindowMI);

        windowMenu.add(cascadeMI);

        for( WindowMenuItem w : WindowRegistry.getWindows() )
          {
            windowMenu.add(w.getMI(this)); // these are static, and calling getMI updates the name on them too in case the window title changed
          }
        windowMenu.repaint();
    }//GEN-LAST:event_windowMenuMenuSelected

    private void themeIntervalTextFieldActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_themeIntervalTextFieldActionPerformed
    {//GEN-HEADEREND:event_themeIntervalTextFieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_themeIntervalTextFieldActionPerformed

    private void noThemeProbTextFieldActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_noThemeProbTextFieldActionPerformed
    {//GEN-HEADEREND:event_noThemeProbTextFieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_noThemeProbTextFieldActionPerformed

    private void generateSoloJButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_generateSoloJButtonActionPerformed
        
        ArrayList<ThemeUse> themeUses = new ArrayList<ThemeUse>();
        //create an empty array of themeUses

        for( int i = 0; i < soloTable.getRowCount(); i++ )
          { //loop through table
            if( (getValueAt(i, THEME_COLUMN) == null)
                    && (getValueAt(i, LENGTH_COLUMN) != null) )
              {
                //if theme cell is empty and length isn't
                enteredIncorrectly.setVisible(true); //show error message
                break;
              }
            else if( getValueAt(i, THEME_COLUMN) != null )
              {
                if ( (getValueAt(i, USE_COLUMN) == null)
                        || (getValueAt(i, TRANSPOSE_COLUMN) == null)
                        || (getValueAt(i, INVERT_COLUMN) == null)
                        || (getValueAt(i, REVERSE_COLUMN) == null)
                        || (getValueAt(i, EXPAND_COLUMN) == null)
                        || (getValueAt(i, SIDESLIP_COLUMN) == null))
                {
                    //if one necessary cell isn't filled
                    enteredIncorrectly.setVisible(true); //show error message 
                    break;
                }
                else if( !isDouble((String) getValueAt(i, USE_COLUMN))
                        || !isDouble((String) getValueAt(i, TRANSPOSE_COLUMN))
                        || !isDouble((String) getValueAt(i, INVERT_COLUMN))
                        || !isDouble((String) getValueAt(i, REVERSE_COLUMN))
                        || !isDouble((String) getValueAt(i, EXPAND_COLUMN))
                        || !isDouble((String) getValueAt(i, SIDESLIP_COLUMN)))
                  {
                    //if theme cell not empty but weighted values are entered wrong
                    enteredIncorrectly.setVisible(true); //show error message 
                    break;
                  }
                else
                  { //if all cells are entered correctly, form theme uses
                    ThemeUse use = new ThemeUse(new MelodyPart((String) getValueAt(i, THEME_COLUMN)));
                    use.probUse = Double.valueOf((String) getValueAt(i, USE_COLUMN));
                    use.probTranspose = Double.valueOf((String) getValueAt(i, TRANSPOSE_COLUMN));
                    use.probInvert = Double.valueOf((String) getValueAt(i, INVERT_COLUMN));
                    use.probReverse = Double.valueOf((String) getValueAt(i, REVERSE_COLUMN));
                    use.probExpand = Double.valueOf((String) getValueAt(i, EXPAND_COLUMN));
                    use.probSideslip = Double.valueOf((String) getValueAt(i, SIDESLIP_COLUMN));
                    themeUses.add(use); // add a new ThemeUse to the arraylist with respective elements

                    if( getValueAt(i, NAME_COLUMN) != null )
                      {
                        //if the theme has a name assign it to the theme
                        use.theme.name = (String) getValueAt(i, NAME_COLUMN);
                      }
                  }
              }
          }
        if (themeUses.isEmpty())
        {
            enteredIncorrectly.setVisible(true);
            return;
        }

        myGenerateSolo(themeUses, cm);
        playSelection();

        //Set play button to say Stop Playing
        soloPlaying = false;
        stopPlaytoggle.setSelected(false);
        stopPlaytoggle.setText("<html><center>Stop Playing</center></html>");
    }//GEN-LAST:event_generateSoloJButtonActionPerformed

    private void generateThemeJButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_generateThemeJButtonActionPerformed
        generateTheme();
    }//GEN-LAST:event_generateThemeJButtonActionPerformed

    private void currentSelectionJButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_currentSelectionJButtonActionPerformed
        // int index = soloTable.getSelectedRow();
        MelodyPart sel = notate.getCurrentStave().getMelodyPart().extract(
                notate.getCurrentSelectionStart(),
                notate.getCurrentSelectionEnd());

        // The commented-out code below illustrates how we can get the relative-pitch
        // melody from a selection, then use it over other chords at other parts
        // of the progression. Moreover, the shape of the original melody
        // will be roughly maintained (except for possible octave displacements).
        // We could use the relative-pitch melody as the Theme in lieu of the
        // absolute pitch one we are now using.
        Polylist relativePitchMelody = 
            NoteConverter.melodyPart2Relative(sel, 
                                              notate.getChordProg(), 
                                              notate.getCurrentSelectionStart());

        System.out.println("FYI: relative pitch melody: "+ relativePitchMelody);
        
        MelodyPart gen = fillMelody(BEAT, 
                                    relativePitchMelody, 
                                    notate.getChordProg(),  
                                    notate.getCurrentSelectionStart());
        
        System.out.println("FYI: filled melody: "+ gen);


        Part.PartIterator i = sel.iterator();
        String theme = "";
        while( i.hasNext() )
          {
            theme += i.next().toLeadsheet() + " ";
          }
        for( int j = 0; j < soloTable.getRowCount(); j++ )
          {
            if( (getValueAt(j, NAME_COLUMN) == null)
                    && (getValueAt(j, THEME_COLUMN) == null)
                    && (getValueAt(j, LENGTH_COLUMN) == null) )
              {
                setValueAt(theme, j, THEME_COLUMN);
                setValueAt(sel.getSize() / BEAT + "", j, LENGTH_COLUMN);

                MelodyPart melody = new MelodyPart((String) getValueAt(j, THEME_COLUMN));

                for( Map.Entry pair : allThemes.entrySet() )
                  {
                    //loop through all the entry sets of {Theme,name} in allThemes
                    Theme ThemeKey = (Theme) pair.getKey(); //get the Theme of each entry

                    if( melody.toString().equals(ThemeKey.melody.toString()) )
                      {
                        //if the melody in allThemes is the name as the melody in the table
                        setValueAt(pair.getValue(), j, NAME_COLUMN);
                        //set the name to the one that matches that theme
                      }
                    else
                      {// if there is no matching theme in allThemes
                        setValueAt(null, j, NAME_COLUMN); //set the name to empty
                      }
                  }
                break;
              }
          }
    }//GEN-LAST:event_currentSelectionJButtonActionPerformed

    private void loadThemesMIActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_loadThemesMIActionPerformed
    {//GEN-HEADEREND:event_loadThemesMIActionPerformed
        themesfc.setDialogTitle("Load Themes File");

        themesfc.resetChoosableFileFilters();

        themesfc.addChoosableFileFilter(new ThemesFilter());

        if( themesfc.showOpenDialog(this) == JFileChooser.APPROVE_OPTION )
          {
            cm.execute(new LoadThemesCommand(themesfc.getSelectedFile(), this, notate));
          }

        savedThemes = themesfc.getSelectedFile();
    }//GEN-LAST:event_loadThemesMIActionPerformed

    private void saveAsThemesActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_saveAsThemesActionPerformed
    {//GEN-HEADEREND:event_saveAsThemesActionPerformed
        if( themesfc == null )
          {
            return;
          }

        themesfc.setDialogTitle("Save Themes As");
        themesfc.setCurrentDirectory(ImproVisor.getVocabDirectory());

        // If never saved before, used the name specified in vocFile.
        // Otherwise use previous file.

        if( savedThemes == null )
          {
            themesfc.setSelectedFile(new File(themesFile));
          }

        themesfc.resetChoosableFileFilters();
        themesfc.addChoosableFileFilter(new ThemesFilter());

        if( themesfc.showSaveDialog(this) == JFileChooser.APPROVE_OPTION )
          {
            if( themesfc.getSelectedFile().getName().endsWith(themesExt) )
              {
                new SaveThemesCommand(themesfc.getSelectedFile(), this).execute();

                savedThemes = themesfc.getSelectedFile();
              }
            else
              {
                String file = themesfc.getSelectedFile().getAbsolutePath() + themesExt;

                savedThemes = new File(file);

                new SaveThemesCommand(savedThemes, this).execute();
              }
          }
    }//GEN-LAST:event_saveAsThemesActionPerformed

    private void stopPlaytoggleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stopPlaytoggleActionPerformed
        soloPlaying = stopPlaytoggle.isSelected();

        if( soloPlaying )
          {
            stopPlaytoggle.setText("<html><center>Play Solo</center></html>");
            stopPlaying();
          }
        else
          {
            soloPlaying = false;
            stopPlaytoggle.setSelected(false);
            stopPlaytoggle.setText("<html><center>Stop Playing</center></html>");
            playSelection();
          }
    }//GEN-LAST:event_stopPlaytoggleActionPerformed

    private void deleteRowbuttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_deleteRowbuttonActionPerformed
        int index = soloTable.getSelectedRow();
        soloTableModel.removeRow(index);
    }//GEN-LAST:event_deleteRowbuttonActionPerformed

    private void deleteThemebuttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_deleteThemebuttonActionPerformed

        String name = (String) themeList.getSelectedValue();

        //delete the desired theme from the table
        for( int j = 0; j < soloTable.getRowCount(); j++ )
          {
            //System.out.println(name.concat ("- ") + j);
            if( (soloTable.getValueAt(j, NAME_COLUMN) == name)
                    || (soloTable.getValueAt(j, NAME_COLUMN) == name.concat("- 1")) )
              {
                soloTable.setValueAt(null, j, NAME_COLUMN);
                soloTable.setValueAt(null, j, LENGTH_COLUMN);
                soloTable.setValueAt(null, j, THEME_COLUMN);
              }
          }

        //delete the selected theme from file
        for( int i = 0; i < orderedThemes.size(); i++ )
          {
            if( themeList.isSelectedIndex(i) )
              {
                deleteTheme(name);
              }
          }
    }//GEN-LAST:event_deleteThemebuttonActionPerformed

    private void pitchRangeMaxSliderMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_pitchRangeMaxSliderMouseReleased
        if (pitchRangeMaxSlider.getValue() < pitchRangeMinSlider.getValue())
        {
            pitchRangeMaxSlider.setValue(pitchRangeMinSlider.getValue());
        }
    }//GEN-LAST:event_pitchRangeMaxSliderMouseReleased

    private void pitchRangeMaxSliderMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_pitchRangeMaxSliderMouseDragged
            
    }//GEN-LAST:event_pitchRangeMaxSliderMouseDragged

    private void trans1ComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_trans1ComboBoxActionPerformed
        transformNum = 1;
        adjustItemsInComboBox(trans1ComboBox, trans2ComboBox, 5);
    }//GEN-LAST:event_trans1ComboBoxActionPerformed

    private void trans2ComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_trans2ComboBoxActionPerformed
        if (canEnter2)
        {
            System.out.println("2");
            transformNum = 2;
            adjustItemsInComboBox(trans2ComboBox, trans3ComboBox, 4);
        }
    }//GEN-LAST:event_trans2ComboBoxActionPerformed

    private void trans3ComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_trans3ComboBoxActionPerformed
        if (canEnter3)
        {
            System.out.println("3");
            transformNum = 3;
            adjustItemsInComboBox(trans3ComboBox, trans4ComboBox, 3);
        }
    }//GEN-LAST:event_trans3ComboBoxActionPerformed

    private void trans4ComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_trans4ComboBoxActionPerformed
        if (canEnter4)
        {
            System.out.println("4");
            transformNum = 4;
            adjustItemsInComboBox(trans4ComboBox, trans5ComboBox, 2);
        }
    }//GEN-LAST:event_trans4ComboBoxActionPerformed

    private void adjustItemsInComboBox(javax.swing.JComboBox box, javax.swing.JComboBox nextBox, int numItems)
    {
        itemsLeft.clear();
        Object chosenItem = box.getSelectedItem();
        for (int i=0; i<numItems; i++)
        {
            Object currItem = box.getItemAt(i);
            if (!currItem.equals(chosenItem))
            {
                itemsLeft.add(currItem);
            }
        }
        nextBox.removeAllItems();
        for (int i=0; i<numItems-1; i++)
        {
            nextBox.addItem(itemsLeft.get(i));
        }
        if (transformNum == 1)
        {
            canEnter2=true;
        }
        else if (transformNum == 2)
        {
            canEnter3=true;
            canEnter2=false;
        }
        else if (transformNum == 3)
        {
            canEnter4=true;
            canEnter3=false;
        }
    }
    
    
boolean soloPlaying = false;
protected ThemeWeaver themeWeaver;
private int themeLength = 8;
private Notate notate;
private int minPitch = 60;
private int maxPitch = 82;
private int minInterval = 0;
private int maxInterval = 6;
private double probWholeToneTranspose = .7;
private double probSemitoneTranspose = .3;
private double leapProb = 0.2;
private boolean avoidRepeats = true;
private LickGen lickgen;
private CommandManager cm;
static final int NAME_COLUMN = 0;
static final int LENGTH_COLUMN = 1;
static final int THEME_COLUMN = 2;
static final int USE_COLUMN = 3;
static final int TRANSPOSE_COLUMN = 4;
static final int INVERT_COLUMN = 5;
static final int REVERSE_COLUMN = 6;
static final int EXPAND_COLUMN = 7;
static final int SIDESLIP_COLUMN = 8;
static final String USE_DEFAULT_VALUE = "1.0";
static final String TRANSPOSE_DEFAULT_VALUE = "0.0";
static final String INVERT_DEFAULT_VALUE = "0.0";
static final String REVERSE_DEFAULT_VALUE = "0.0";
static final String EXPAND_DEFAULT_VALUE = "0.0";
static final String SIDESLIP_DEFAULT_VALUE = "0.0";
private ArrayList<Object> itemsLeft = new ArrayList<Object>();
private boolean canEnter2 = false;
private boolean canEnter3 = false;
private boolean canEnter4 = false;
private boolean throughOnce = false;
private int transformNum = 0;
//private boolean usedSideslip = false;
private String themeUsageText = "";
static final int ROW_COUNT = 20;
double probnoTheme;
public ThemeListModel themeListModel = new ThemeListModel();
Random random;
File fileName = ImproVisor.getThemesFile();
private SoloGeneratorTableModel soloTableModel = new SoloGeneratorTableModel(
        new Object[][]
  {
    {
        null, null, null, null, null, null, null, null
      },
    {
        null, null, null, null, null, null, null, null
      },
    {
        null, null, null, null, null, null, null, null
      },
    {
        null, null, null, null, null, null, null, null
      },
    {
        null, null, null, null, null, null, null, null
      },
    {
        null, null, null, null, null, null, null, null
      },
    {
        null, null, null, null, null, null, null, null
      },
    {
        null, null, null, null, null, null, null, null
      },
    {
        null, null, null, null, null, null, null, null
      },
    {
        null, null, null, null, null, null, null, null
      },
    {
        null, null, null, null, null, null, null, null
      },
    {
        null, null, null, null, null, null, null, null
      },
    {
        null, null, null, null, null, null, null, null
      },
    {
        null, null, null, null, null, null, null, null
      },
    {
        null, null, null, null, null, null, null, null
      },
    {
        null, null, null, null, null, null, null, null
      },
    {
        null, null, null, null, null, null, null, null
      },
    {
        null, null, null, null, null, null, null, null
      },
    {
        null, null, null, null, null, null, null, null
      },
    {
        null, null, null, null, null, null, null, null
      }
  },
        new String[]
  {
    "Name", "Length", "Theme", "Use", "Transpose", "Invert", "Reverse", "Expand", "Side Slip"
  });

public class SoloGeneratorTableModel extends DefaultTableModel
{

private static final int columnCount = 9;
boolean[] canEdit = new boolean[]
  {
    //name, theme, length, use, transpose, invert, reverse, expand, side slip
    true, true, true, true, true, true, true, true, true
  };
int[] columnWidths = new int[]
  {
    80, 4, 100, 3, 6, 9, 5, 5, 5
  };
int[] columnAdjustment =
  {
    DefaultTableCellRenderer.LEFT,
    DefaultTableCellRenderer.LEFT,
    DefaultTableCellRenderer.LEFT,
    DefaultTableCellRenderer.RIGHT,
    DefaultTableCellRenderer.RIGHT,
    DefaultTableCellRenderer.RIGHT,
    DefaultTableCellRenderer.RIGHT,
    DefaultTableCellRenderer.RIGHT,
    DefaultTableCellRenderer.RIGHT,
  };

public SoloGeneratorTableModel(Object[][] myTable, String[] columnHeaders)
  {
    super(myTable, columnHeaders);
  }

public int getColumnWidths(int index)
  {
    return columnWidths[index];
  }
//

public int getColumnAdjustments(int index)
  {
    return columnAdjustment[index];
  }

@Override
public boolean isCellEditable(int rowIndex, int columnIndex)
  {
    return canEdit[columnIndex];
  }

public void tableRefresh()
  {
    for( int i = 0; i < soloTable.getRowCount(); i++ )
      {

        //add back rows that were deleted
        if( soloTable.getRowCount() != ROW_COUNT )
          {
            for( int x = 0; x < ROW_COUNT - soloTable.getRowCount(); x++ )
              {
                soloTableModel.addARow();
              }
          }

        soloTable.setValueAt(null, i, NAME_COLUMN);
        soloTable.setValueAt(null, i, LENGTH_COLUMN);
        soloTable.setValueAt(null, i, THEME_COLUMN);
        soloTable.setValueAt(null, i, USE_COLUMN);
        soloTable.setValueAt(null, i, TRANSPOSE_COLUMN);
        soloTable.setValueAt(null, i, INVERT_COLUMN);
        soloTable.setValueAt(null, i, REVERSE_COLUMN);
      }

    fireTableDataChanged();
    themeUsageTextArea.setText(null);
  }

public void tableReset()
  {

    tableRefresh();
  }

@Override
public int getColumnCount()
  {
    return columnCount;
  }

public void addARow()
  {
    soloTableModel.insertRow(0, new Object[]
      {
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null
      });
  }

@Override
public Class getColumnClass(int column)
  {
    switch( column )
      {
        case 0:
            return Object.class;
      }
    return Object.class;
  }

@Override
public void setValueAt(Object value, int row, int col)
  {
    super.setValueAt(value, row, col);
    if( themeList.hasFocus() )
      {
        return;
      }

    switch( col )
      {
        //for naming a theme
        case NAME_COLUMN:
            if( soloTable.isCellSelected(row, NAME_COLUMN)
                    && (getValueAt(row, THEME_COLUMN) != null)
                    && (getValueAt(row, NAME_COLUMN) != null) )
              {
                namingSaving(row, col, row);
              }
            break;

        case LENGTH_COLUMN:
            break;

        //for editing a theme
        case THEME_COLUMN:
            if( (soloTable.isCellSelected(row, THEME_COLUMN))
                    && (getValueAt(row, THEME_COLUMN) != null)
                    && (getValueAt(row, LENGTH_COLUMN) != null) )
              {
                updateLength(row, col, row);
                return;
              }

            //for typing in own theme
            if( (soloTable.isCellSelected(row, THEME_COLUMN))
                    && (getValueAt(row, THEME_COLUMN) != null)
                    && (getValueAt(row, LENGTH_COLUMN) == null) )
              {
                addLength(row, col, row);
              }
            break;
      }
  }

}

public void setValueAt(Object value, int row, int col)
  {
    soloTable.setValueAt(value, row, col);
    if( !themeList.hasFocus() )
      {
        enteringValue(row, col);
      }
  }

public Object getValueAt(int row, int col)
  {
    return soloTable.getValueAt(row, col);
  }

//if a theme is edited 
public void updateLength(int row, int col, int i)
  {
    MelodyPart melody = new MelodyPart((String) getValueAt(i, THEME_COLUMN));

    int themelength = melody.size() / BEAT;

    if( themelength != (Integer) getValueAt(i, LENGTH_COLUMN) )
      {
        //if the lengths are different
        soloTable.setValueAt(themelength + "", i, LENGTH_COLUMN);

        for( Map.Entry pair : allThemes.entrySet() )
          {
            //loop through all the entry sets of {Theme,name} in allThemes
            Theme ThemeKey = (Theme) pair.getKey();
            //get the Theme of each entry

            if( melody.toString().equals(ThemeKey.melody.toString()) )
              {
                //if the melody in allThemes is the name as the melody in the table
                soloTable.setValueAt(pair.getValue(), i, NAME_COLUMN);
                //set the name to the one that matches that theme
              }
            else
              {// if there is no matching theme in allThemes
                soloTable.setValueAt(null, i, NAME_COLUMN);
                //set the name to empty
              }
          }
      }
  }

//if a theme is typed in 
public void addLength(int row, int col, int i)
  {
    MelodyPart melody = new MelodyPart((String) getValueAt(i, THEME_COLUMN));

    int themelength = melody.size() / BEAT;

    if( (getValueAt(i, NAME_COLUMN) == null) )
      { //if there is no name
        soloTable.setValueAt(themelength + "", i, LENGTH_COLUMN);
        //set themelength in the table
      }
    else
      { //if there is already a name
        soloTable.setValueAt(themelength + "", i, LENGTH_COLUMN);
        for( Map.Entry pair : allThemes.entrySet() )
          {
            //loop through all the entry sets of {Theme,name} in allThemes
            Theme ThemeKey = (Theme) pair.getKey();
            //get the Theme of each entry

            if( melody.toString().equals(ThemeKey.melody.toString()) )
              {
                //if the melody in allThemes is the name as the melody in the table
                soloTable.setValueAt(pair.getValue(), i, NAME_COLUMN);
                //set the name to the one that matches that theme
              }
            else
              {// if there is no matching theme in allThemes
                soloTable.setValueAt(null, i, NAME_COLUMN);
                //set the name to empty
              }
          }
      }
  }

//when a theme is named
public void namingSaving(int row, int col, int i)
  {
    MelodyPart melody = new MelodyPart((String) getValueAt(i, THEME_COLUMN));

    int themelength = melody.size() / BEAT;
    String name = (String) getValueAt(i, NAME_COLUMN);
    String themestring = (String) getValueAt(i, THEME_COLUMN);
    MelodyPart themeMelody = new MelodyPart(themestring);
    Theme theme = Theme.makeTheme(name.trim(), themeMelody);

    if( orderedThemes.contains(name) )
      { //if the user types a name already in the list
        nameErrorMessage.setVisible(true);
        //give name error message to rename the theme
      }
    else
      {
        if( !name.trim().isEmpty() )
          { //if the name is not whitespace

            for( Map.Entry pair : allThemes.entrySet().toArray(new Map.Entry[0]) )
              {
                // loop through the entries of allThemes
                Theme ThemeKey = (Theme) pair.getKey();
                //get the Theme of each entry
                String nameValue = (String) pair.getValue();
                //get the name of each entry

                if( melody.toString().equals(ThemeKey.melody.toString()) )
                  {
                    deleteTheme(nameValue); //delete the old theme
                    addTheme(theme); //add the new one

                    saveRules(fileName);
                    themeListModel.reset();

                    nameErrorMessage.setVisible(false);
                    break;
                  }
                else
                  { //if there is no melody that matches the one in the table
                    addTheme(theme);
                    saveRules(fileName);
                  }
              }
          }
      }
  }

public void enteringValue(int row, int col)
  {
    for( int i = 0; i < soloTable.getRowCount(); i++ )
      { //loop through table
        //updating length
        if( (soloTable.isCellSelected(i, THEME_COLUMN))
                && (getValueAt(i, THEME_COLUMN) != null)
                && (getValueAt(i, LENGTH_COLUMN) != null) )
          {
            updateLength(row, col, i);
            return;
          }
        //for typing in own theme
        if( (soloTable.isCellSelected(i, THEME_COLUMN))
                && (getValueAt(i, THEME_COLUMN) != null)
                && (getValueAt(i, LENGTH_COLUMN) == null) )
          {
            addLength(row, col, i);
            return;
          }

        //naming and saving
        if( soloTable.isCellSelected(i, NAME_COLUMN)
                && (getValueAt(i, THEME_COLUMN) != null)
                && (getValueAt(i, NAME_COLUMN) != null) )
          { //if name cell is selected, it's not empty and the theme isn't empty
            namingSaving(row, col, i);
            return;
          }
      }
  }

private static LinkedHashMap<Theme, String> allThemes = new LinkedHashMap<Theme, String>();
private static ArrayList<String> orderedThemes = null;
int allThemesIndex = allThemes.size() - 1;

public static int numberOfThemes()
  {
    ensureThemeArray();
    return orderedThemes.size();
  }

public static void setTheme(String name, Theme theme)
  {
    allThemes.put(theme, name);
  }

public static String getNth(int index)
  {
    ensureThemeArray();
    return orderedThemes.get(index);
  }

private static void ensureThemeArray()
  {
    orderedThemes = new ArrayList<String>(allThemes.values());
  }

public void addTheme(Theme theme)
  {
    ensureThemeArray();
    int orderedThemesIndex = orderedThemes.size() - 1;
    String name = theme.name;

    for( int i = 0; i < soloTable.getRowCount(); i++ )
      {
        if( (!orderedThemes.contains(name)) )
          {
            // if ordered themes doesn't already have it, add to both 
            //orderedThemes and allThemes
            orderedThemes.add(name);
            allThemes.put(theme, name);
          }
        // reset themeListModel so it will update to add the new theme
        themeListModel.reset();
        orderedThemesIndex = orderedThemes.indexOf(theme);
      }
  }

//delete a theme from a file based on the string name shown in the Themes scroll box
public void deleteTheme(String name)
  {
    orderedThemes.remove(name);

    for( Map.Entry pair : allThemes.entrySet() )
      {
        if( name.equals(pair.getValue()) )
          {
            //if the name in the themeList is equal to the name in the entry
            Theme theme = (Theme) pair.getKey();
            allThemes.remove(theme);
            break;
          }
      }

    saveRules(fileName);
    themeListModel.reset();
  }

//saving themes into My.themes
public void saveRules(File file)
  {
    try
      {
        java.io.PrintStream out = new PrintStream(new FileOutputStream(file));

        for( Map.Entry pair : allThemes.entrySet() )
          {
            Theme key = (Theme) pair.getKey();
            //key.showForm(System.out);
            key.showForm(out);
          }
      }
    catch( IOException e )
      {
        ErrorLog.log(ErrorLog.SEVERE, "Saving themes in file failed: " + file);
      }
  }

//load the themes in My.themes into the Theme Weaver window
public void loadFromFile(File file)
  {
    java.io.FileInputStream themeStream;

    try
      {
        themeStream = new FileInputStream(file);
      }
    catch( Exception e )
      {
        ErrorLog.log(ErrorLog.SEVERE, "Loading themes in file failed: " + file);
        return;
      }

    Tokenizer in = new Tokenizer(themeStream);
    Object ob;

    while( (ob = in.nextSexp()) != Tokenizer.eof )
      {
        if( ob instanceof Polylist )
          {
            Polylist themePoly = (Polylist) ob;
            Theme theme = new Theme(themePoly);
            addTheme(theme);
            //System.out.println("adding " + theme);
            //System.out.println(orderedThemes);
          }
      }
  }

public class ThemeListModel
        extends AbstractListModel
{

public int getSize()
  {
    int number = numberOfThemes();

    return number;

  }

public Object getElementAt(int index)
  {
    return getNth(index);
  }

public void reset()
  {
    fireContentsChanged(this, 0, getSize());
  }

public void adjust()
  {
    fireIntervalAdded(this, 0, getSize());
  }
}

public static boolean isInteger(String s)
  {
    try
      {
        Integer.parseInt(s);
      }
    catch( NumberFormatException e )
      {
        return false;
      }
    return true;
  }

public static boolean isDouble(String s)
  {
    try
      {
        Double.parseDouble(s);
      }
    catch( NumberFormatException e )
      {
        return false;
      }
    return true;
  }

/**
 * This fillMelody is called in three places within ThemeWeaver.
 *
 * @param beatValue
 * @param rhythmString
 * @param chordProg
 * @param start
 * @return
 */
public MelodyPart fillMelody(int beatValue,
                             Polylist rhythmString,
                             ChordPart chordProg,
                             int start)
  {
    MelodyPart result = lickgen.fillMelody(minPitch,
                                           maxPitch,
                                           minInterval,
                                           maxInterval,
                                           beatValue,
                                           leapProb,
                                           rhythmString,
                                           chordProg,
                                           start,
                                           avoidRepeats);
    return result;
  }

//work in progress
public void ExpandCommand(Polylist list)
  {
    Polylist melodyList = (Polylist) list.last(); //get polylist of the melody
    Polylist melodyNotes = melodyList.rest(); //get the notes in a polylist

    PolylistEnum melodyElements = melodyNotes.elements(); //get the notes as elements

    //To get the notes of the theme in a string:
    String melodyString = "";
    while( melodyElements.hasMoreElements() )
      { //while there are more notes
        Object current = melodyElements.nextElement();//get next note
        String currentString = current.toString(); //convert it to String
        if( currentString.length() == 2 )
          {
            int intValue = Integer.parseInt(currentString.charAt(1) + "");
            int newValue = intValue / 2;
            //System.out.println(newValue);
            //System.out.println(currentString.charAt(0));
            String newNote = currentString.charAt(0) + newValue + "";
            // System.out.println(newNote);
            melodyString += newNote + " "; //add the note to the melodyString
          }
        else if( currentString.length() == 3 )
          {
            int newValue = currentString.charAt(2) / 2;
            String newNote = currentString.charAt(0) + currentString.charAt(1) + newValue + "";
            melodyString += newNote + " "; //add the note to the melodyString
          }
        else
          {
            int newValue = currentString.charAt(3) / 2;
            String newNote = currentString.charAt(0) + currentString.charAt(1) + currentString.charAt(2) + newValue + "";
            melodyString += newNote + " "; //add the note to the melodyString
          }
      }
    //System.out.println(melodyString);
    MelodyPart melody = new MelodyPart(melodyString); //create a MelodyPart of the string
  }

public void generateTheme()
  {
    for( int x = 0; x < soloTable.getRowCount(); x++ )
      { //loop through the rows of the table
        if( (getValueAt(x, LENGTH_COLUMN) != null)
                && (!isInteger((String) getValueAt(x, LENGTH_COLUMN))) )
          {
            enteredIncorrectly.setVisible(true);
          }
        else
          {
            if( ((soloTable.isCellSelected(x, LENGTH_COLUMN))
                    && (getValueAt(x, LENGTH_COLUMN) != null))
                    || ((getValueAt(x, LENGTH_COLUMN) != null)
                     && (getValueAt(x, THEME_COLUMN) == null)) )
              {
                //if the theme length cell is selected and has something in it 
                // or if there is something in a length cell and has no theme

                //set default values for weighted values
                soloTable.setValueAt(USE_DEFAULT_VALUE,       x, USE_COLUMN);
                soloTable.setValueAt(TRANSPOSE_DEFAULT_VALUE, x, TRANSPOSE_COLUMN);
                soloTable.setValueAt(INVERT_DEFAULT_VALUE,    x, INVERT_COLUMN);
                soloTable.setValueAt(REVERSE_DEFAULT_VALUE,   x, REVERSE_COLUMN);
                soloTable.setValueAt(EXPAND_DEFAULT_VALUE,    x, EXPAND_COLUMN);
                soloTable.setValueAt(SIDESLIP_DEFAULT_VALUE,    x, SIDESLIP_COLUMN);

                int Length = notate.intFromStringInRange((String) getValueAt(x, LENGTH_COLUMN), 0, 100, themeLength);
                //get length from tablek
                themeLength = BEAT * Length;
                Polylist rhythm = lickgen.generateRhythmFromGrammar(0, themeLength);
                //get rhythm for theme from grammar

                MelodyPart lick = fillMelody(BEAT, rhythm, notate.getChordProg(), 0);
                //get the melody of the theme

                Part.PartIterator i = lick.iterator(); //iterate over lick
                String theme = ""; //set theme as empty to start

                while( i.hasNext() ) //while you can still iterate through the lick
                  {
                    Unit unit = i.next();
                    if( unit != null ) //if next isn't empty
                      {
                        theme += unit.toLeadsheet() + " "; //add it to the theme
                      }
                  }

                soloTable.setValueAt(theme, x, THEME_COLUMN);
                //make theme appear in table 

                if( getValueAt(x, NAME_COLUMN) != null )
                  {
                    soloTable.setValueAt(null, x, NAME_COLUMN);
                  }
              }
          }
      }
  }

public MelodyPart generateSolohelper(ThemeUse chosenthemeUse, MelodyPart chosentheme, MelodyPart solo, CommandManager cm)
        //adjusts chosentheme 
  {
    int length = chosentheme.size(); // get length of theme
    MelodyPart adjustedTheme = chosentheme.copy(); //made a copy of the theme
    imp.ImproVisor.setPlayEntrySounds(false); //don't play yet
    int unmodified = 0;
    int multipleuse = 0;

    if( Notate.bernoulli(chosenthemeUse.probTranspose) )
      {
        // if a random number is greater than the probability not to transpose theme
        multipleuse += 1;
        //System.out.println("Transpose");
        themeUsageTextArea.append("transposed");
        ChordPart chordProg = notate.getChordProg(); //get current chord progression
        int rise = PitchClass.findRise(PitchClass.getPitchClass(chordProg.getCurrentChord(0).getRoot()),
                                       PitchClass.getPitchClass(chordProg.getCurrentChord(length).getRoot()));
        //set rise equal to the rise of semitones from the root of the 0 chord to i chord
        int index = 0;
        Note n = adjustedTheme.getNote(index); //get the note of the theme at index 0

        while( n.isRest() )
          { //while there is still theme left
            index += n.getRhythmValue(); //add the rhythm value of the theme to the index
            n = adjustedTheme.getNote(index); //get the note of the theme at new index
          }

        if( n.getPitch() >= (minPitch + maxPitch) / 2 && rise > 0 )
          { // if pitch of theme is greater than or equal to the average pitch and change in semitones increased
            cm.execute(new ShiftPitchesCommand(-1 * (12 - rise), adjustedTheme,
                                               0, length, 0, 128, notate.getScore().getKeySignature()));
          } //shift theme pitches down an octave + rise from 0 to the end of the theme
        else if( n.getPitch() < (minPitch + maxPitch) / 2 && rise < 0 )
          { //if pitch of theme is less than the average pitch and change in semitones increased
            cm.execute(new ShiftPitchesCommand((12 + rise), adjustedTheme,
                                               0, length, 0, 128, notate.getScore().getKeySignature()));
          } //shift theme pitches up an octave + rise from 0 to end of theme
        else
          {
            cm.execute(new ShiftPitchesCommand(rise, adjustedTheme, 0, length, 0, 128, notate.getScore().getKeySignature()));
            
          }
        //shift theme pitches by the rise in semitones
      }
    else
      {
        unmodified += 1;
      }

    if( Notate.bernoulli(chosenthemeUse.probInvert) )
      { // if a random number is greater than the probability not to invert the theme
        multipleuse += 1;
        if( multipleuse == 2 )
          {
            themeUsageTextArea.append(", and inverted");
          }
        //System.out.println("Invert");
        if( !(multipleuse == 2) )
          {
            themeUsageTextArea.append("inverted");
          }
        cm.execute(new InvertCommand(adjustedTheme, 0, length, false)); //invert theme
      }
    else
      {
        unmodified += 1;
      }

    if( Notate.bernoulli(chosenthemeUse.probReverse) )
      {
        // if a random number is greater than the probability not to reverse the theme
        multipleuse += 1;
        //System.out.println("Reverse");

        if( multipleuse == 1 )
          {
            themeUsageTextArea.append("reversed");
          }

        if( multipleuse != 1 )
          {
            themeUsageTextArea.append(", and reversed");
          }

        cm.execute(new ReverseCommand(adjustedTheme, 0, length, false)); //reverse theme
      }
    else
      {
        unmodified += 1;
      }

    if( unmodified == 3 )
      {
        themeUsageTextArea.append(" unmodified");
      }

    themeUsageTextArea.append("\n");
    ChordPart themeChords = notate.getChordProg().extract(length, length + length);
    //set chords of theme to be the chordpart extracted from length to length +length
    cm.execute(new RectifyPitchesCommand(adjustedTheme, 0, length, themeChords, false, false));
    //resolve pitches of the theme
    solo.setSize(solo.getSize() + length);
    //set size of solo to the existing length of the solo plus the length of the theme
    return adjustedTheme;
  }

public void generateSolohelper2(int themeLength, MelodyPart solo)
  {
    Polylist rhythm = lickgen.generateRhythmFromGrammar(0, themeLength);
    //generate rhythm 

    MelodyPart lick = fillMelody(BEAT, rhythm, notate.getChordProg(), 0);
    //create melody


    Part.PartIterator j = lick.iterator(); //iterate over lick
    lick.setSize(themeLength);
    while( j.hasNext() ) //while any lick is left
      {
        Unit unit = j.next();
        if( unit != null ) //if next is not empty
          {
            solo.addNote(NoteSymbol.toNote(unit.toLeadsheet()));
            //add the unit to the solo
          }
      }
    
  }

public void generateSolo(ArrayList<ThemeUse> themeUses, CommandManager cm)
  {
    themeUsageTextArea.setText(null);
    //System.out.println(themeUses);
    // create four empty lists to start for all the probabilities
    List<Double> probUselist = new ArrayList(Arrays.asList());
    List<Double> probTransposelist = new ArrayList(Arrays.asList());
    List<Double> probInvertlist = new ArrayList(Arrays.asList());
    List<Double> probReverselist = new ArrayList(Arrays.asList());

    int n = 0;

    //loop through the themeUses list and get the probabilities for each
    //themeuse and add it to the corresponding empty list
    for( int i = 0; i < themeUses.size(); i++ )
      {
        probUselist.add(themeUses.get(i).probUse);
        probTransposelist.add(themeUses.get(i).probTranspose);
        probInvertlist.add(themeUses.get(i).probInvert);
        probReverselist.add(themeUses.get(i).probReverse);

        //give names to themes that don't have one for text area
        if( themeUses.get(i).theme.name == null )
          {
            n += 1;
            themeUses.get(i).theme.name = "Theme " + n;
          }
      }


    // find max of probability use to use that corresponding theme first
    double max = Collections.max(probUselist);
    int index = probUselist.indexOf(max); //get the index of the max
    int length = themeUses.get(index).theme.melody.getSize();
    //get length of theme
    themeLength = length; //set themeLength to it
    MelodyPart solo = new MelodyPart(themeLength);
    //set solo equal to a MelodyPart of the theme length

    imp.ImproVisor.setPlayEntrySounds(false); //don't play insertions yet

    solo.pasteSlots(themeUses.get(index).theme.melody, 0);
    //paste theme into solo at starting point

    themeUsageTextArea.append("Bar 1: " + themeUses.get(index).theme.name + " unmodified \n");

    // set totals of probabilities to 0
    int probUsetotal = 0;
    int probTransposetotal = 0;
    int probInverttotal = 0;
    int probReversetotal = 0;

    //loop through each respective list and add elements together to get 
    //the total of each probability
    // multiply each element by 10 so its an integer
    for( int i = 0; i < themeUses.size(); i++ )
      {
        probUsetotal += 10 * probUselist.get(i);
        probTransposetotal += 10 * probTransposelist.get(i);
        probInverttotal += 10 * probInvertlist.get(i);
        probReversetotal += 10 * probReverselist.get(i);
      }

    //use Theme Use Interval from text field
    int themeInterval = new Integer(themeIntervalTextField.getText());
    //int themeIntervalUse = themeInterval * 120;//comment 6.4.15: this is assuming 120 bpm
    int tempo = (int)notate.getTempo();
    int themeIntervalUse = themeInterval * tempo;//change made 6.4.15

    for( int i = length; i <= notate.getScoreLength() - themeIntervalUse; i += themeIntervalUse )
      {
        //loop through the remaining length of the score
        int beat = i / tempo;//this is the beat number that we're on
        int bar = 1 + (beat / notate.getBeatsPerMeasure());//this is the bar number we're on
        Integer noThemevalue = (int) (10 * themeUses.size() * Double.valueOf(noThemeProbTextField.getText()));

        int themei = random.nextInt(probUsetotal + noThemevalue);
        //System.out.println(themei); 
        //pick a random number from 0 inclusive to 10*the probability list size
        //since all the elements in the list are multpled by 10, the size has to be multiplied by 10 too


        //To implement the probabilities I broke up the size of the list times 10 into intervals
        //the first interval is from 0 to to the first probability - 1 
        //so that way the number of slots in that interval is equal
        //to that first probability times 10
        //so if the random number chosen is in that interval, then that first theme is used
        if( themei <= 10 * probUselist.get(0) - 1 )
          {
            //System.out.println("Theme 1");
            MelodyPart chosentheme = themeUses.get(0).theme.melody;
            ThemeUse chosenthemeUse = themeUses.get(0);
            themeUsageTextArea.append("Bar " + bar + ": " + chosenthemeUse.theme.name);
            MelodyPart adjustedTheme = generateSolohelper(chosenthemeUse, chosentheme, solo, cm);

            //this if takes care of the case if the index is out of bounds
            if( i + adjustedTheme.size() >= solo.getSize() )
              {
                generateSolohelper2(themeLength, solo);
              }
            else
              {
                // if there is no index out of bounds issue, then add the adjusted theme into the solo
                solo.pasteSlots(adjustedTheme, i);
              }
          }
        //if the themeUses size is more than one themeuse then the other intervals have to be accounted for 
        else if( themeUses.size() > 1 )
          {
            double A = 0;
            double B = 10 * probUselist.get(0);

            //this loop covers the rest of the intervals
            for( int k = 0; k < probUselist.size() - 1; k++ )
              {
                A += 10 * probUselist.get(k);
                B += 10 * probUselist.get(k + 1);

                if( (themei >= A) && (themei <= B - 1) )
                  {
                    //System.out.println("Theme " + x);
                    ThemeUse chosenthemeUse = themeUses.get(k + 1);
                    MelodyPart chosentheme = themeUses.get(k + 1).theme.melody;
                    themeUsageTextArea.append("Bar " + bar + ": " + chosenthemeUse.theme.name);
                    MelodyPart adjustedTheme = generateSolohelper(chosenthemeUse, chosentheme, solo, cm);

                    if( i + adjustedTheme.size() >= solo.getSize() )
                      {
                        generateSolohelper2(themeLength, solo);

                      }
                    else
                      {
                        solo.pasteSlots(adjustedTheme, i);
                      }
                  }
              }
          }

        //this interval is for not using any theme at all    
        if( (themei <= probUsetotal + noThemevalue) && (themei >= probUsetotal) )
          {
            //System.out.println("no Theme");
            themeUsageTextArea.append("Bar " + bar + ": Used grammar\n");
            generateSolohelper2(themeLength, solo);
          }
      }


    if( notate.getScore().getLength() - solo.getSize() != 0 )
      {//if the length of the score does not equal the length of the solo
       //finishes the solo
        Polylist rhythm = lickgen.generateRhythmFromGrammar(0, notate.getScore().getLength() - solo.getSize());
        // generate rhythm for the space

        MelodyPart lick = fillMelody(BEAT, rhythm, notate.getChordProg(), 0);
        //create melody for the space

        Part.PartIterator j = lick.iterator(); //iterate over the lick
        while( j.hasNext() ) //while lick has next
          {
            solo.addNote(NoteSymbol.toNote(j.next().toLeadsheet()));
            //add the note of the lick to the solo
          }
      }
    notate.setCurrentSelectionStart(0); //start selection at beginning

    // Experimental: Resolve pitches in entire solo: seems to improve things, but
    // may generate some repeated notes.
    cm.execute(new RectifyPitchesCommand(solo, 0, solo.getSize(), notate.getChordProg(), false, false));

    notate.pasteMelody(solo); //paste solo into leadsheet

    imp.ImproVisor.setPlayEntrySounds(true); //play solo
  }
private void setSliderLabels(javax.swing.JSlider slider)
{
    slider.setPaintLabels(true);
    
    Hashtable<Integer, JLabel> table = new Hashtable<Integer, JLabel>();
    table.put (40, new JLabel(new ImageIcon("E2")));
    table.put (50, new JLabel("D3"));
    table.put (60, new JLabel("C4"));
    table.put (70, new JLabel("Bb4"));
    table.put (80, new JLabel("Ab5"));
    table.put (90, new JLabel("Gb6"));
    table.put (100, new JLabel("E7"));
    Font f = table.get(40).getFont();
    for (int i = 1; i < 8; i++)
    {
        Component c = table.get(i*10+30);
        c.setFont(new Font(f.getName(), f.getStyle(), 8));
    }
    slider.setLabelTable (table);
}

public void myGenerateSolo(ArrayList<ThemeUse> themeUses, CommandManager cm)
{
    themeUsageTextArea.setText(null);
    
    maxPitch = (int)pitchRangeMaxSlider.getValue();
    minPitch = (int)pitchRangeMinSlider.getValue();
    
    probnoTheme = Double.parseDouble(noThemeProbTextField.getText());
    MelodyPart solo = new MelodyPart(0);
    
    imp.ImproVisor.setPlayEntrySounds(false); //don't play insertions yet
    
    //use Theme Use Interval from text field
    int themeInterval = new Integer(themeIntervalTextField.getText());
    
    int slots = 120;//(int)notate.getTempo();
    
    int themeIntervalUseIncrement = themeInterval * slots; //amount by which we'll increment over the score
    
    int i=0;
    while (i<notate.getScoreLength())
    {//increment through and fill the whole score 
        
        themeInterval = new Integer(themeIntervalTextField.getText());
        double randProbNT = random.nextDouble();//random number used for no-theme
        
        int beat = i / slots;//this is the beat number that we're on
        int bar = 1 + (beat / notate.getBeatsPerMeasure());//this is the bar number we're on
        
        MelodyPart newMelody = new MelodyPart();
        
        int increaseIncrement = 0;//keeps track of how i should change accordingly 
                                        //and how the solo size should change
        
        if (probnoTheme < randProbNT)
        {
            //choose a theme
            //normalize use probabilities
            double sumUseProb=0;
            for (ThemeUse themeUse : themeUses) 
            {
                sumUseProb += themeUse.getProbUse();
            }
            double randProbUse = random.nextDouble();//random number used for use

            //defaults chosen theme as last in array list (changes it later
            //                                                      if necessary)
            //uses probability to choose a theme in themeUses
            ThemeUse chosenThemeUse=themeUses.get(themeUses.size()-1);
            double tempTotalProb=0;
            for (ThemeUse themeUse : themeUses) 
            {
                tempTotalProb += themeUse.getProbUse();
                if (tempTotalProb/sumUseProb > randProbUse) 
                {
                    chosenThemeUse = themeUse;
                    break;
                }
            }

            MelodyPart chosenTheme = chosenThemeUse.getTheme().melody;
            int originalSize = chosenTheme.getSize();
            
            newMelody.setSize(chosenTheme.getSize());
            //change theme according to given probabilities for transpose, invert, reverse, expand, and side slip
            newMelody = adjustTheme(chosenTheme, chosenThemeUse, cm, themeInterval);//adjustTheme is a helper method
            
            if (newMelody.getSize()+i > notate.getScoreLength())
            {//if it doesn't fit in allotted score space, stop early
                
//                int newMelodySize = notate.getScoreLength()-i;
//                int randStart = random.nextInt(newMelody.getSize()-newMelodySize);
//                int randEnd = randStart + newMelodySize;
//                MelodyPart shortenedMelody = newMelody.extract(randStart, randEnd);
//                themeUsageTextArea.append("Bar " + bar + ": " + chosenThemeUse.theme.name + ": ");
//                themeUsageTextArea.append(themeUsageText + ", shortened to fit in solo" + "\n");
//                newMelody = shortenedMelody;
//                
                newMelody = null; 
                increaseIncrement += themeIntervalUseIncrement;
                System.out.println("done");
            }
            else if(newMelody.getSize() > themeIntervalUseIncrement)
            {//if the theme doesn't fit in the allotted space
                //reset solo size so it fits
                themeUsageTextArea.append("Bar " + bar + ": " + chosenThemeUse.theme.name + ": ");
                themeUsageTextArea.append(themeUsageText + "\n");
                int numIncrements = newMelody.getSize()/themeIntervalUseIncrement + 1;
                
                increaseIncrement += themeIntervalUseIncrement*numIncrements;
            }
//            else if (usedSideslip)
//            {//uses side slip and it fits
//                increaseIncrement += themeIntervalUseIncrement*2;
//                themeUsageTextArea.append("Bar " + bar + ": " + chosenThemeUse.theme.name + ": ");
//                themeUsageTextArea.append(themeUsageText + "\n");
//                usedSideslip = false;
//            }
            else
            {//it fits properly
                themeUsageTextArea.append("Bar " + bar + ": " + chosenThemeUse.theme.name + ": ");
                themeUsageTextArea.append(themeUsageText + "\n");
                
                increaseIncrement += themeIntervalUseIncrement;
            }
            
            themeUsageText = "";
          
            chosenTheme.setSize(originalSize);
            
        }   
        else
        {
            //no theme, use
            themeUsageTextArea.append("Bar " + bar + ": Used grammar\n");
            //set size of solo to the existing length of the solo plus the length of the theme
            newMelody = generateFromGrammar(themeIntervalUseIncrement, solo, i); 
            increaseIncrement += themeIntervalUseIncrement;
            //System.out.println("Grammar No Theme");
        }
        
        solo.setSize(solo.getSize() + increaseIncrement);
        
        solo.pasteSlots(newMelody, i);
        System.out.println("solo "+solo.getSize());
        System.out.println("score "+notate.getScoreLength());
        System.out.println("old "+i);
        i+=increaseIncrement;
        System.out.println("new "+i);
    }
    
    notate.setCurrentSelectionStart(0); //start selection at beginning

    // Resolve pitches in entire solo
    cm.execute(new RectifyPitchesCommand(solo, 0, solo.getSize(), notate.getChordProg(), false, false));

    notate.pasteMelody(solo); //paste solo into leadsheet

    imp.ImproVisor.setPlayEntrySounds(true); //play solo
    
    //System.out.println("*************");
}

//adjustTheme is a helper method for myGenerateSolo
public MelodyPart adjustTheme(MelodyPart chosenTheme, ThemeUse chosenThemeUse, CommandManager cm, int themeInterval)
{
    MelodyPart transposedMelody = chosenTheme.copy();
    MelodyPart adjustedMelody = chosenTheme.copy();
    int length = chosenTheme.size(); 
    
    imp.ImproVisor.setPlayEntrySounds(false); //don't play yet
    
    int numAdjustments = 0;
   
    int slots = 120;//(int)notate.getTempo();
    
    int themeIntervalUseIncrement = themeInterval * slots; //amount by which we'll increment over the score
    
    Object[] transformOrder = new Object[5];
    Object trans1 = trans1ComboBox.getSelectedItem();
    Object trans2 = trans2ComboBox.getSelectedItem();
    Object trans3 = trans3ComboBox.getSelectedItem();
    Object trans4 = trans4ComboBox.getSelectedItem();
    Object trans5 = trans5ComboBox.getSelectedItem();
    transformOrder[0]=trans1;
    transformOrder[1]=trans2;
    transformOrder[2]=trans3;
    transformOrder[3]=trans4;
    transformOrder[4]=trans5;
    if (trans1==null&&trans2==null&&trans3==null&&trans4==null&&trans5==null)
    {
        transformOrder[0]="Transpose";
        transformOrder[1]="Invert";
        transformOrder[2]="Reverse";
        transformOrder[3]="Expand";
        transformOrder[4]="Side Slip";
    }
    else if (trans1==null||trans2==null||trans3==null||trans4==null||trans5==null)
    {
        //not entered correctly, will use default
        transformOrder[0]="Transpose";
        transformOrder[1]="Invert";
        transformOrder[2]="Reverse";
        transformOrder[3]="Expand";
        transformOrder[4]="Side Slip";
    }
    int count = 0;
    while (count < 5)
    {
        if (transformOrder[count]=="Transpose")
        {
            //decide whether to transpose or not
            if (Notate.bernoulli(chosenThemeUse.getProbTranspose()) ) 
            {    //if random number is > the probability of transposing
                //transpose
                numAdjustments ++;
                if (numAdjustments > 1)
                {
                    themeUsageText+=", transposed";
                }
                else
                {
                    themeUsageText+="transposed";
                }
                while (true)
                {//loop until you find a transposition in range (it will break while loop
                 //                                                        when this happens)
                    //System.out.println("try to transpose");
                    int maxTransposeDist = (maxPitch + minPitch)/2; 
                        //if pitch is exactly in the center or min and max pitch, 
                                        //maximum number of steps to reach min and max pitch
                    //decide to move by semitones or whole tone according to set probability
                    if (Notate.bernoulli(probWholeToneTranspose))
                    {//transpose by whole tones
                        int numWholeSteps = random.nextInt(maxTransposeDist/2);

                        if (Notate.bernoulli(.5))
                        {//transpose down by numWholeSteps

                            int lowest = lowestNote(transposedMelody)-numWholeSteps*2;

                            if (lowest > minPitch)//make sure the new melody will be in range
                            {
                                //transpose copy of chosen theme
                                cm.execute(new ShiftPitchesCommand(-1*numWholeSteps, transposedMelody, 
                                    0, length, 0, 128, notate.getScore().getKeySignature()));
                                break;
                            }
                            /*else
                            {
                                System.out.println("repeat");
                            }*/
                        }
                        else
                        {//transpose up by numWholeSteps

                            int highest = highestNote(transposedMelody)+numWholeSteps*2;

                            if (highest < maxPitch)//make sure the new melody will be in range
                            {
                                //transpose copy of chosen theme
                                cm.execute(new ShiftPitchesCommand(numWholeSteps, transposedMelody, 
                                    0, length, 0, 128, notate.getScore().getKeySignature()));
                                break;
                            }
                            /*else
                            {
                                System.out.println("repeat");
                            }*/
                        }

                    }

                    else
                    {//transpose by semitones
                        int numHalfSteps = random.nextInt(maxTransposeDist);
                        if (Notate.bernoulli(.5))
                        {//transpose down by numWholeSteps

                            int lowest = lowestNote(transposedMelody)-numHalfSteps;

                            if (lowest > minPitch)//make sure the new melody will be in range
                            {
                                //transpose copy of chosen theme
                                cm.execute(new ShiftPitchesCommand(-1*numHalfSteps, transposedMelody, 
                                    0, length, 0, 128, notate.getScore().getKeySignature()));
                                break;
                            }
                            /*else
                            {
                                System.out.println("repeat");
                            }*/
                        }
                        else
                        {//transpose up by numWholeSteps

                            int highest = highestNote(transposedMelody)+numHalfSteps*2;

                            if (highest < maxPitch)//make sure the new melody will be in range
                            {
                                //transpose copy of chosen theme
                                cm.execute(new ShiftPitchesCommand(numHalfSteps, transposedMelody, 
                                    0, length, 0, 128, notate.getScore().getKeySignature()));
                                break;
                            }
                            /*else
                            {
                                System.out.println("repeat");
                            }*/
                        }
                    }
                }
                adjustedMelody = transposedMelody;
            }
        }
        else if (transformOrder[count]=="Invert")
        {
            //decide whether to invert or not
            if (Notate.bernoulli(chosenThemeUse.getProbInvert()) )
                //if random number is > the probability of inverting
            {
                //invert
                numAdjustments++;
                if (numAdjustments > 1)
                {
                    themeUsageText+=", inverted";
                }
                else
                {
                    themeUsageText+="inverted";
                }
                cm.execute(new InvertCommand(adjustedMelody, 0, length, false));
                //System.out.println("Invert");
            }
        }
        else if (transformOrder[count] == "Reverse")
        {
            //decide whether to reverse or not
            if (Notate.bernoulli(chosenThemeUse.getProbReverse()) )
                //if random number is > the probability of reversing
            {
                numAdjustments++;
                if (numAdjustments > 1)
                {
                    themeUsageText+=", reversed";
                }
                else
                {
                    themeUsageText+="reversed";
                }
                //reverse
                cm.execute(new ReverseCommand(adjustedMelody, 0, length, false));
                //System.out.println("Reverse");
            }
        }
        else if (transformOrder[count] == "Expand")
        {
            //decide whether to expand or not
            if (Notate.bernoulli(chosenThemeUse.getProbExpand()))
            {
                numAdjustments ++;
                double probExpandBy3 = probExpandby2or3.getValue()/100; 
                //decide whether to expand by 2 or 3
                if (Notate.bernoulli(probExpandBy3))
                {
                    if (numAdjustments > 1)
                    {
                        themeUsageText+=", expanded by 3";
                    }
                    else
                    {
                        themeUsageText+="expanded by 3";
                    }
                    //expand by 3
                    cm.execute(new TimeWarpCommand(adjustedMelody,0,length, true, 3, 1));
                }
                else
                {
                    if (numAdjustments > 1)
                    {
                        themeUsageText+=", expanded by 2";
                    }
                    else
                    {
                        themeUsageText+="expanded by 2";
                    }
                    //expand by 2
                    cm.execute(new TimeWarpCommand(adjustedMelody,0,length, true, 2, 1));
                }
            }
        }
        else if (transformOrder[count] == "Side Slip")
        {
            //decide whether to side slip or not
            if (Notate.bernoulli(chosenThemeUse.getProbSideslip()))
            {
                numAdjustments ++;
                //usedSideslip = true;
                MelodyPart sideslippedMelody = chosenTheme.copy();
                if (numAdjustments > 1)
                {
                    themeUsageText+=", side slip";
                }
                else
                {
                    themeUsageText+="side slip";
                }
                //add two of the same melodies with one transposed up a half step
                cm.execute(new ShiftPitchesCommand(1, sideslippedMelody, 
                                    0, length, 0, 128, notate.getScore().getKeySignature()));

                adjustedMelody.setSize(adjustedMelody.getSize()+sideslippedMelody.getSize());
                adjustedMelody.pasteSlots(sideslippedMelody, adjustedMelody.getSize()/2);

            }
        }
        count++;
    }
    if (numAdjustments == 0)
    {
        themeUsageText+=" unmotified";
    }
    
    return adjustedMelody;
}

private boolean transformDoubled(Object[] transforms)
{//returns true if any two of the transforms in the array are equal
    for (int i=0; i<transforms.length; i++)
    {
        for (int j=0; j<transforms.length; j++)
        {
            if (transforms[i] == transforms[j] && i != j)
            {
                return true;
            }
        }
    }
    return false;
}

public MelodyPart generateFromGrammar(int themeLength, MelodyPart solo, int slotNum)
  {//adds to the solo using the grammar
    Polylist rhythm = lickgen.generateRhythmFromGrammar(slotNum, themeLength);
    //generate rhythm 

    MelodyPart lick = fillMelody(BEAT, rhythm, notate.getChordProg(), slotNum);
    //create melody
    
    /*Part.PartIterator j = lick.iterator(); //iterate over lick
    lick.setSize(themeLength);
    while( j.hasNext() ) //while any lick is left
      {
        Unit unit = j.next();
        if( unit != null ) //if next is not null 
         {
            solo.addNote(NoteSymbol.toNote(unit.toLeadsheet()));
            //add the unit to the solo
          }
    }*/
    return lick;
}

//inRange is a helper method for myGenerateSolo
public int lowestNote(MelodyPart melody)
{
    //returns the min pitch in melody 
    int lengthOfMelody = melody.size();
    int lowestNote = 127;
    for (int note = 0; note<lengthOfMelody; note++)
    {
        int currentNote = melody.getCurrentNote(note).getPitch();
        if (currentNote < lowestNote)
        {
            lowestNote = currentNote;
        }
    }
    return lowestNote;
}

public int highestNote(MelodyPart melody)
{
    //returns the max pitch in melody 
    int lengthOfMelody = melody.size();
    int highestNote = 0;
    for (int note = 0; note<lengthOfMelody; note++)
    {
        int currentNote = melody.getCurrentNote(note).getPitch();
        if (currentNote > highestNote)
        {
            highestNote = currentNote;
        }
    }
    return highestNote;
}  



    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton CancelButton;
    private javax.swing.JButton NoButton;
    private javax.swing.JButton OkButton;
    private javax.swing.JButton Reset;
    private javax.swing.JLabel Resettable;
    private java.awt.Label SoloGeneratorTitle;
    private javax.swing.JLabel TransformationOrder;
    private javax.swing.JButton YesButton;
    private javax.swing.JMenuItem cascadeMI;
    private javax.swing.JButton cellOkbutton;
    private javax.swing.JLabel chooseName;
    private javax.swing.JMenuItem closeWindowMI;
    private javax.swing.JButton currentSelectionJButton;
    private javax.swing.JButton deleteRowbutton;
    private javax.swing.JButton deleteThemebutton;
    private javax.swing.JDialog enteredIncorrectly;
    private javax.swing.JLabel expandBy2Label;
    private javax.swing.JLabel expandBy3Label;
    private javax.swing.JButton generateSoloJButton;
    private javax.swing.JButton generateThemeJButton;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPopupMenu.Separator jSeparator5;
    private javax.swing.JMenuItem loadThemesMI;
    private javax.swing.JDialog nameErrorMessage;
    private javax.swing.JTextField nameField;
    private javax.swing.JLabel namePicked;
    private javax.swing.JDialog noRowSelected;
    private javax.swing.JLabel noThemeProbLabel;
    private javax.swing.JTextField noThemeProbTextField;
    private javax.swing.JSlider pitchRangeMaxSlider;
    private javax.swing.JLabel pitchRangeMinLabel;
    private javax.swing.JSlider pitchRangeMinSlider;
    private javax.swing.JSlider probExpandby2or3;
    private javax.swing.JDialog resetCheck;
    private javax.swing.JMenuBar roadmapMenuBar;
    private javax.swing.JMenuItem saveAsAdvice;
    private javax.swing.JTable soloTable;
    private javax.swing.JScrollPane soloTableScrollPane;
    private javax.swing.JToggleButton stopPlaytoggle;
    private javax.swing.JLabel themeIntervalLabel;
    private javax.swing.JTextField themeIntervalTextField;
    private javax.swing.JList themeList;
    private javax.swing.JScrollPane themeListScrollPane;
    private javax.swing.JScrollPane themeUsageScrollPane;
    private javax.swing.JTextArea themeUsageTextArea;
    private javax.swing.JComboBox trans1ComboBox;
    private javax.swing.JComboBox trans2ComboBox;
    private javax.swing.JComboBox trans3ComboBox;
    private javax.swing.JComboBox trans4ComboBox;
    private javax.swing.JComboBox trans5ComboBox;
    private javax.swing.JLabel tryAgain;
    private javax.swing.JLabel typedWrong;
    private javax.swing.JMenu windowMenu;
    private javax.swing.JSeparator windowMenuSeparator;
    private javax.swing.JLabel youSure;
    // End of variables declaration//GEN-END:variables
}
