/**
 * This Java Class is part of the Impro-Visor Application
 *
 * Copyright (C) 2015 Robert Keller and Harvey Mudd College
 *
 * Impro-Visor is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * Impro-Visor is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * merchantability or fitness for a particular purpose.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Impro-Visor; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
package imp.gui;

import static imp.Constants.BEAT;
import imp.com.CommandManager;
import imp.com.InvertCommand;
import imp.com.LoadThemesCommand;
import imp.com.PlayScoreCommand;
import imp.com.RectifyPitchesCommand;
import imp.com.ReverseCommand;
import imp.com.SaveThemesCommand;
import imp.com.ShiftPitchesCommand;
import imp.data.ChordPart;
import imp.data.MelodyPart;
import imp.data.Note;
import imp.data.NoteSymbol;
import imp.data.Part;
import imp.data.PitchClass;
import imp.data.Unit;
import imp.util.ThemesFilter;
import polya.Polylist;
import imp.lickgen.LickGen;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import javax.swing.table.DefaultTableModel;
import javax.swing.ListSelectionModel;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Arrays;
import javax.swing.AbstractListModel;
import javax.swing.JFileChooser;
import java.util.List;
import java.util.Random;
import java.util.Collections;
import java.util.LinkedHashMap;
import imp.util.ErrorLog;
import java.util.Map;
import imp.ImproVisor;
import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.io.FileOutputStream;
import java.io.FileInputStream;
import polya.Tokenizer;
import imp.data.Score;
import javax.swing.table.DefaultTableCellRenderer;
import polya.PolylistEnum;
/**
 *
 * @author David Morrison, Nava Dallal
 */
public class ThemeWeaver extends javax.swing.JFrame {
    
 String TITLE = "Theme Weaver";
 LickgenFrame lickgenFrame;
 
 private static String themesExt = ".themes";
 public String themesFile = "My" + themesExt;
 JFileChooser themesfc;
 private File savedThemes;
 
    /**
     * Creates new form ThemeWeaver
     */
    public ThemeWeaver(LickGen lickgen, Notate notate, CommandManager cm) {
        this.random = new Random();
        initComponents();
    //    testDialog.setVisible(true);
    this.cm = cm;
    this.lickgen = lickgen;
    this.notate = notate;
    
    setTitle(TITLE);
    WindowRegistry.registerWindow(this);
    soloTable.setModel(soloTableModel);
    soloTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
    soloTable.addMouseListener(new MouseAdapter() {
        @Override
        public void mouseReleased(MouseEvent e) {
            if(e.getClickCount() >= 1) {
                int row = soloTable.rowAtPoint(e.getPoint());
              soloTable.getSelectionModel().setSelectionInterval(row,row);
            }
           
        }
    });
    setTableColumnWidths();
    
    themesfc = new JFileChooser();
    loadFromFile(fileName);
    }

public void setTableColumnWidths()
  {
      for(int j = 0; j < soloTableModel.getColumnCount();j++)
    {
        soloTable.getColumnModel().getColumn(j).
                setPreferredWidth(soloTableModel.getColumnWidths(j));
    }


    for(int j = 0; j < soloTableModel.getColumnCount(); j++)
    {
        DefaultTableCellRenderer renderer = new DefaultTableCellRenderer();
        renderer.setHorizontalAlignment( soloTableModel.getColumnAdjustments(j));
        soloTable.getColumnModel().getColumn(j).setCellRenderer( renderer );
    }
  }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents()
    {
        java.awt.GridBagConstraints gridBagConstraints;

        nameErrorMessage = new javax.swing.JDialog();
        nameField = new javax.swing.JTextField();
        namePicked = new javax.swing.JLabel();
        CancelButton = new javax.swing.JButton();
        OkButton = new javax.swing.JButton();
        chooseName = new javax.swing.JLabel();
        enteredIncorrectly = new javax.swing.JDialog();
        typedWrong = new javax.swing.JLabel();
        tryAgain = new javax.swing.JLabel();
        cellOkbutton = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        resetCheck = new javax.swing.JDialog();
        Resettable = new javax.swing.JLabel();
        youSure = new javax.swing.JLabel();
        YesButton = new javax.swing.JButton();
        NoButton = new javax.swing.JButton();
        soloTableScrollPane = new javax.swing.JScrollPane();
        soloTable = new javax.swing.JTable();
        themeListScrollPane = new javax.swing.JScrollPane();
        themeList = new javax.swing.JList();
        themeUsageScrollPane = new javax.swing.JScrollPane();
        themeUsageTextArea = new javax.swing.JTextArea();
        ThemesLabel = new java.awt.Label();
        SoloGeneratorTitle = new java.awt.Label();
        Reset = new javax.swing.JButton();
        themeIntervalTextField = new javax.swing.JTextField();
        themeIntervalLabel = new javax.swing.JLabel();
        noThemeProbTextField = new javax.swing.JTextField();
        noThemeProbLabel = new javax.swing.JLabel();
        generateSoloJButton = new javax.swing.JButton();
        generateThemeJButton = new javax.swing.JButton();
        currentSelectionJButton = new javax.swing.JButton();
        stopPlaytoggle = new javax.swing.JToggleButton();
        deleteRowbutton = new javax.swing.JButton();
        deleteThemebutton = new javax.swing.JButton();
        roadmapMenuBar = new javax.swing.JMenuBar();
        javax.swing.JMenu fileMenu = new javax.swing.JMenu();
        loadThemesMI = new javax.swing.JMenuItem();
        saveAsAdvice = new javax.swing.JMenuItem();
        javax.swing.JMenuItem exitMenuItem = new javax.swing.JMenuItem();
        windowMenu = new javax.swing.JMenu();
        closeWindowMI = new javax.swing.JMenuItem();
        cascadeMI = new javax.swing.JMenuItem();
        jSeparator5 = new javax.swing.JPopupMenu.Separator();
        windowMenuSeparator = new javax.swing.JSeparator();

        nameErrorMessage.setMinimumSize(new java.awt.Dimension(500, 400));
        nameErrorMessage.getContentPane().setLayout(new java.awt.GridBagLayout());

        nameField.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                nameFieldActionPerformed(evt);
            }
        });
        nameField.addKeyListener(new java.awt.event.KeyAdapter()
        {
            public void keyPressed(java.awt.event.KeyEvent evt)
            {
                nameFieldKeyPressed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 4;
        gridBagConstraints.ipadx = 309;
        gridBagConstraints.ipady = 12;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 20, 0, 0);
        nameErrorMessage.getContentPane().add(nameField, gridBagConstraints);

        namePicked.setText("The name you have picked is already assigned to a theme. ");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 5;
        gridBagConstraints.ipadx = 75;
        gridBagConstraints.ipady = 15;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(53, 20, 0, 0);
        nameErrorMessage.getContentPane().add(namePicked, gridBagConstraints);

        CancelButton.setText("Cancel");
        CancelButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                CancelButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(12, 43, 105, 0);
        nameErrorMessage.getContentPane().add(CancelButton, gridBagConstraints);

        OkButton.setText("Ok");
        OkButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                OkButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.ipadx = -18;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(12, 20, 105, 0);
        nameErrorMessage.getContentPane().add(OkButton, gridBagConstraints);

        chooseName.setText("Please choose another:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.ipadx = 44;
        gridBagConstraints.ipady = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 20, 0, 0);
        nameErrorMessage.getContentPane().add(chooseName, gridBagConstraints);

        enteredIncorrectly.setMinimumSize(new java.awt.Dimension(400, 300));
        enteredIncorrectly.getContentPane().setLayout(new java.awt.GridBagLayout());

        typedWrong.setText("You have either typed information into a cell incorrectly,");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(80, 24, 0, 21);
        enteredIncorrectly.getContentPane().add(typedWrong, gridBagConstraints);

        tryAgain.setText("Please try again.");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 6, 0, 0);
        enteredIncorrectly.getContentPane().add(tryAgain, gridBagConstraints);

        cellOkbutton.setText("Ok");
        cellOkbutton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                cellOkbuttonActionPerformed(evt);
            }
        });
        cellOkbutton.addKeyListener(new java.awt.event.KeyAdapter()
        {
            public void keyPressed(java.awt.event.KeyEvent evt)
            {
                cellOkbuttonKeyPressed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(18, 79, 107, 0);
        enteredIncorrectly.getContentPane().add(cellOkbutton, gridBagConstraints);

        jLabel1.setText("not finished entering contents into a cell, or left a cell");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 4;
        gridBagConstraints.ipadx = 15;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(12, 24, 0, 21);
        enteredIncorrectly.getContentPane().add(jLabel1, gridBagConstraints);

        jLabel2.setText("blank.");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 24, 0, 0);
        enteredIncorrectly.getContentPane().add(jLabel2, gridBagConstraints);

        resetCheck.setMinimumSize(new java.awt.Dimension(500, 300));
        resetCheck.getContentPane().setLayout(new java.awt.GridBagLayout());

        Resettable.setText("Resetting the table will clear everything you currently have entered. ");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 5;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(96, 39, 0, 77);
        resetCheck.getContentPane().add(Resettable, gridBagConstraints);

        youSure.setText("Are you sure you want to do this?");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 137, 0, 0);
        resetCheck.getContentPane().add(youSure, gridBagConstraints);

        YesButton.setText("Yes, Continue");
        YesButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                YesButtonActionPerformed(evt);
            }
        });
        YesButton.addKeyListener(new java.awt.event.KeyAdapter()
        {
            public void keyPressed(java.awt.event.KeyEvent evt)
            {
                YesButtonKeyPressed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(31, 78, 150, 0);
        resetCheck.getContentPane().add(YesButton, gridBagConstraints);

        NoButton.setText("No, Cancel");
        NoButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                NoButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.ipadx = 16;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(31, 76, 150, 0);
        resetCheck.getContentPane().add(NoButton, gridBagConstraints);

        setLocation(new java.awt.Point(10, 10));
        setLocationByPlatform(true);
        setMaximumSize(new java.awt.Dimension(2140, 800));
        setMinimumSize(new java.awt.Dimension(1000, 500));
        setPreferredSize(new java.awt.Dimension(800, 630));
        setSize(new java.awt.Dimension(1000, 600));
        addWindowListener(new java.awt.event.WindowAdapter()
        {
            public void windowClosed(java.awt.event.WindowEvent evt)
            {
                ThemeWeaver.this.windowClosed(evt);
            }
        });
        addKeyListener(new java.awt.event.KeyAdapter()
        {
            public void keyPressed(java.awt.event.KeyEvent evt)
            {
                formKeyPressed(evt);
            }
        });
        getContentPane().setLayout(new java.awt.GridBagLayout());

        soloTableScrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        soloTableScrollPane.setMaximumSize(new java.awt.Dimension(32767, 400));
        soloTableScrollPane.setMinimumSize(new java.awt.Dimension(23, 350));
        soloTableScrollPane.setPreferredSize(new java.awt.Dimension(469, 200));

        soloTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][]
            {
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null}
            },
            new String []
            {
                "Name", "Theme Length", "Theme", "Prob. to Use", "Prob. to Transpose", "Prob. to Invert", "Prob. to Reverse"
            }
        )
        {
            Class[] types = new Class []
            {
                java.lang.String.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class
            };

            public Class getColumnClass(int columnIndex)
            {
                return types [columnIndex];
            }
        });
        soloTable.setToolTipText("shift-click a cell in a row of a theme to listen to it");
        soloTable.setAlignmentY(1.0F);
        soloTable.setColumnSelectionAllowed(true);
        soloTable.setGridColor(new java.awt.Color(0, 0, 0));
        soloTable.setMinimumSize(new java.awt.Dimension(105, 200));
        soloTable.setPreferredSize(null);
        soloTable.setSelectionBackground(javax.swing.UIManager.getDefaults().getColor("CheckBoxMenuItem.selectionBackground"));
        soloTable.setShowGrid(true);
        soloTable.getTableHeader().setReorderingAllowed(false);
        soloTable.addMouseListener(new java.awt.event.MouseAdapter()
        {
            public void mouseClicked(java.awt.event.MouseEvent evt)
            {
                soloTableMouseClicked(evt);
            }
        });
        soloTable.addComponentListener(new java.awt.event.ComponentAdapter()
        {
            public void componentShown(java.awt.event.ComponentEvent evt)
            {
                soloTableComponentShown(evt);
            }
        });
        soloTable.addKeyListener(new java.awt.event.KeyAdapter()
        {
            public void keyPressed(java.awt.event.KeyEvent evt)
            {
                soloTableKeyPressed(evt);
            }
        });
        soloTableScrollPane.setViewportView(soloTable);
        soloTable.getColumnModel().getSelectionModel().setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.gridwidth = 5;
        gridBagConstraints.ipadx = 600;
        gridBagConstraints.ipady = -100;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.weightx = 0.8;
        gridBagConstraints.weighty = 0.3;
        gridBagConstraints.insets = new java.awt.Insets(18, 35, 10, 0);
        getContentPane().add(soloTableScrollPane, gridBagConstraints);

        themeListScrollPane.setMaximumSize(new java.awt.Dimension(0, 0));
        themeListScrollPane.setMinimumSize(new java.awt.Dimension(0, 0));
        themeListScrollPane.setPreferredSize(new java.awt.Dimension(100, 100));

        themeList.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        themeList.setModel(themeListModel);
        themeList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        themeList.setToolTipText("shift-click a theme to listen to it");
        themeList.setLayoutOrientation(javax.swing.JList.VERTICAL_WRAP);
        themeList.setPreferredSize(null);
        themeList.setVisibleRowCount(30);
        themeList.addMouseListener(new java.awt.event.MouseAdapter()
        {
            public void mouseClicked(java.awt.event.MouseEvent evt)
            {
                themeListClicked(evt);
            }
        });
        themeList.addKeyListener(new java.awt.event.KeyAdapter()
        {
            public void keyPressed(java.awt.event.KeyEvent evt)
            {
                themeListKeyPressed(evt);
            }
        });
        themeListScrollPane.setViewportView(themeList);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 5;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.ipadx = 250;
        gridBagConstraints.ipady = 290;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 0.3;
        gridBagConstraints.insets = new java.awt.Insets(9, 0, 5, 45);
        getContentPane().add(themeListScrollPane, gridBagConstraints);

        themeUsageScrollPane.setMinimumSize(new java.awt.Dimension(300, 100));

        themeUsageTextArea.setColumns(20);
        themeUsageTextArea.setRows(70);
        themeUsageScrollPane.setViewportView(themeUsageTextArea);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 5;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.gridheight = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 0.6;
        gridBagConstraints.weighty = 0.3;
        gridBagConstraints.insets = new java.awt.Insets(0, 10, 5, 0);
        getContentPane().add(themeUsageScrollPane, gridBagConstraints);

        ThemesLabel.setFont(new java.awt.Font("Lucida Grande", 1, 13)); // NOI18N
        ThemesLabel.setText("Themes");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 5;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.ipady = 5;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(23, 78, 0, 0);
        getContentPane().add(ThemesLabel, gridBagConstraints);

        SoloGeneratorTitle.setFont(new java.awt.Font("Lucida Grande", 1, 24)); // NOI18N
        SoloGeneratorTitle.setMaximumSize(new java.awt.Dimension(327, 327));
        SoloGeneratorTitle.setText("Theme Weaver (work in progress)\n");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 6;
        gridBagConstraints.ipady = -7;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(10, 0, 15, 0);
        getContentPane().add(SoloGeneratorTitle, gridBagConstraints);

        Reset.setText("Reset");
        Reset.setToolTipText("Clears the table of all themes currently entered");
        Reset.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                ResetActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 5;
        gridBagConstraints.gridy = 6;
        gridBagConstraints.ipadx = 32;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(10, 75, 0, 0);
        getContentPane().add(Reset, gridBagConstraints);

        themeIntervalTextField.setText("8");
        themeIntervalTextField.setMaximumSize(new java.awt.Dimension(50, 2147483647));
        themeIntervalTextField.setMinimumSize(new java.awt.Dimension(50, 28));
        themeIntervalTextField.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                themeIntervalTextFieldActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        getContentPane().add(themeIntervalTextField, gridBagConstraints);

        themeIntervalLabel.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        themeIntervalLabel.setText("Theme Use Interval");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.ipadx = 5;
        gridBagConstraints.insets = new java.awt.Insets(0, 30, 0, 0);
        getContentPane().add(themeIntervalLabel, gridBagConstraints);

        noThemeProbTextField.setText("0.5");
        noThemeProbTextField.setMaximumSize(new java.awt.Dimension(50, 2147483647));
        noThemeProbTextField.setMinimumSize(new java.awt.Dimension(50, 28));
        noThemeProbTextField.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                noThemeProbTextFieldActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        getContentPane().add(noThemeProbTextField, gridBagConstraints);

        noThemeProbLabel.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        noThemeProbLabel.setText("No-Theme Prob.");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.ipadx = 5;
        gridBagConstraints.insets = new java.awt.Insets(0, 40, 0, 0);
        getContentPane().add(noThemeProbLabel, gridBagConstraints);

        generateSoloJButton.setText("Generate Solo");
        generateSoloJButton.setToolTipText("Creates a solo from the themes in the table and displays and plays the solo in the leadsheet window");
        generateSoloJButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                generateSoloJButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 2.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 35, 0, 0);
        getContentPane().add(generateSoloJButton, gridBagConstraints);

        generateThemeJButton.setText("Generate Theme");
        generateThemeJButton.setToolTipText("Generates a theme for every non empty length cell in the table that doesn't have a corresponding theme");
        generateThemeJButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                generateThemeJButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 5;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 2.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 35, 0, 0);
        getContentPane().add(generateThemeJButton, gridBagConstraints);

        currentSelectionJButton.setText("Use Current Selection in Leadsheet Window as Theme");
        currentSelectionJButton.setToolTipText("Adds the selection from the window into the first empty theme cell in the table");
        currentSelectionJButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                currentSelectionJButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 6;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 2.0;
        gridBagConstraints.insets = new java.awt.Insets(10, 35, 0, 0);
        getContentPane().add(currentSelectionJButton, gridBagConstraints);

        stopPlaytoggle.setBackground(new java.awt.Color(255, 255, 255));
        stopPlaytoggle.setText("Stop Playing");
        stopPlaytoggle.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                stopPlaytoggleActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.insets = new java.awt.Insets(0, 35, 0, 0);
        getContentPane().add(stopPlaytoggle, gridBagConstraints);

        deleteRowbutton.setText("Delete Selected Row");
        deleteRowbutton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                deleteRowbuttonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 7;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.insets = new java.awt.Insets(-20, 35, 0, 0);
        getContentPane().add(deleteRowbutton, gridBagConstraints);

        deleteThemebutton.setText("Delete Theme From File");
        deleteThemebutton.setPreferredSize(new java.awt.Dimension(78, 29));
        deleteThemebutton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                deleteThemebuttonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 5;
        gridBagConstraints.gridy = 5;
        gridBagConstraints.ipadx = 32;
        gridBagConstraints.insets = new java.awt.Insets(-25, 15, 0, 45);
        getContentPane().add(deleteThemebutton, gridBagConstraints);

        fileMenu.setText("File"); // NOI18N
        fileMenu.setMaximumSize(new java.awt.Dimension(50, 40));
        fileMenu.setPreferredSize(new java.awt.Dimension(50, 21));

        loadThemesMI.setText("Load Themes File");
        loadThemesMI.setToolTipText("Load a new vocabulary.");
        loadThemesMI.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                loadThemesMIActionPerformed(evt);
            }
        });
        fileMenu.add(loadThemesMI);

        saveAsAdvice.setText("Save Themes As");
        saveAsAdvice.setToolTipText("Save the current vocabulary in a file.");
        saveAsAdvice.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                saveAsThemesActionPerformed(evt);
            }
        });
        fileMenu.add(saveAsAdvice);

        exitMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Q, java.awt.event.InputEvent.CTRL_MASK));
        exitMenuItem.setText("Close this window."); // NOI18N
        exitMenuItem.setToolTipText("Closes this window."); // NOI18N
        exitMenuItem.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                exitMenuItemexitMIhandler(evt);
            }
        });
        fileMenu.add(exitMenuItem);

        roadmapMenuBar.add(fileMenu);

        windowMenu.setMnemonic('W');
        windowMenu.setText("Window"); // NOI18N
        windowMenu.addMenuListener(new javax.swing.event.MenuListener()
        {
            public void menuSelected(javax.swing.event.MenuEvent evt)
            {
                windowMenuMenuSelected(evt);
            }
            public void menuDeselected(javax.swing.event.MenuEvent evt)
            {
            }
            public void menuCanceled(javax.swing.event.MenuEvent evt)
            {
            }
        });

        closeWindowMI.setMnemonic('C');
        closeWindowMI.setText("Close Window"); // NOI18N
        closeWindowMI.setToolTipText("Closes the current window (exits program if there are no other windows)"); // NOI18N
        closeWindowMI.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                closeWindowMIActionPerformed(evt);
            }
        });
        windowMenu.add(closeWindowMI);

        cascadeMI.setMnemonic('A');
        cascadeMI.setText("Cascade Windows"); // NOI18N
        cascadeMI.setToolTipText("Rearrange windows into a cascade.\n"); // NOI18N
        cascadeMI.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                cascadeMIActionPerformed(evt);
            }
        });
        windowMenu.add(cascadeMI);
        windowMenu.add(jSeparator5);
        windowMenu.add(windowMenuSeparator);

        roadmapMenuBar.add(windowMenu);

        setJMenuBar(roadmapMenuBar);

        pack();
    }// </editor-fold>//GEN-END:initComponents

public void stopPlaying()
  {
  notate.stopPlaying();
  }
private void playSelection()
    {
    notate.getCurrentStave().playSelection(false, notate.getLoopCount(), PlayScoreCommand.USEDRUMS, "LickGenFrame");
    }
    private void soloTableComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_soloTableComponentShown
        // TODO add your handling code here:
    }//GEN-LAST:event_soloTableComponentShown

    private void soloTableKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_soloTableKeyPressed
        int index = soloTable.getSelectedRow();
        int col = soloTable.getSelectedColumn();
        
        if (evt.getKeyCode() == KeyEvent.VK_DELETE) {
            soloTableModel.removeRow(index);
         }


        // When enter is pressed on this cell, keep the same cell selected
        // (This can be conditioned on column later if desired.)
        if (evt.getKeyCode() == KeyEvent.VK_ENTER) {
            //index = index <= 1 ? 0 : index-1;
            //soloTable.setRowSelectionInterval(index, index);
            
            if( col == THEME_COLUMN && getValueAt(index,THEME_COLUMN) != null )
              {
                //System.out.println("Theme at row " + index + " entered");
                MelodyPart melody = new MelodyPart((String) getValueAt(index, THEME_COLUMN)); 
                int themeLengthBeats = melody.getSize()/BEAT;
                soloTable.setValueAt(themeLengthBeats + "", index, LENGTH_COLUMN);
              }
        }
 
          
        
    }//GEN-LAST:event_soloTableKeyPressed

    private void ResetActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ResetActionPerformed
        resetCheck.setVisible(true); 
        
    }//GEN-LAST:event_ResetActionPerformed

    private void soloTableMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_soloTableMouseClicked
       //Play a theme in the table using shift-click
        if (evt.isShiftDown()) {
            int index = soloTable.getSelectedRow(); 
            
            String name = (String) getValueAt(index, NAME_COLUMN);
            Score score = new Score(name);
            
            String themeString = (String) getValueAt(index, THEME_COLUMN);
            MelodyPart melody = new MelodyPart(themeString);
            
            score.addPart(melody);
            PatternDisplay.playScore(notate, score, themeWeaver);

        }
    }//GEN-LAST:event_soloTableMouseClicked

    private void themeListClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_themeListClicked
        if (!evt.isShiftDown()) {
        // add theme into table if clicked and not shift-clicked
        for (int i = 0; i < orderedThemes.size(); i++) { //loop through size of orderedThemes
            for (int j = 0; j < soloTable.getRowCount(); j++) {//loop through table
                
                if (themeList.isSelectedIndex(i) 
                   && (getValueAt(j, NAME_COLUMN) == null) 
                   && (getValueAt(j,THEME_COLUMN) == null) 
                   && (getValueAt(j, LENGTH_COLUMN) == null) 
                       ){
                    //if a theme in the Themes scroll box is clicked and a theme
                    //cell is selected and there is an empty row
                    
                    if ((getValueAt(j, USE_COLUMN) == null)
                     && (getValueAt(j,TRANSPOSE_COLUMN) == null)
                     && (getValueAt(j,INVERT_COLUMN) == null)
                     && (getValueAt(j,REVERSE_COLUMN) == null)) {
                    // if the weighted value cells are null
                    //set default values for weighted values
                    soloTable.setValueAt("1",j,USE_COLUMN);
                    soloTable.setValueAt("0",j,TRANSPOSE_COLUMN);
                    soloTable.setValueAt("0",j,INVERT_COLUMN);
                    soloTable.setValueAt("0",j, REVERSE_COLUMN);
                    }
                    
                    String name = (String) themeList.getSelectedValue();
                    //set name equal to the one clicked in the scroll box
                    
                    for (Map.Entry pair : allThemes.entrySet()) { 
                        //loop through entries in allThemes
                        
                        if (name == pair.getValue()) 
                        { //if the name in the themeList is equal to the name in the entry
                            Theme theme = (Theme) pair.getKey(); 
                            //set theme equal to the corresponding theme in that entry
                            MelodyPart melody = theme.melody; //get the melody of the theme
                            Part.PartIterator k = melody.iterator(); //iterate over melody
                            String themestring = ""; //set theme as empty to start
                            
                            while (k.hasNext()) //while you can still iterate through the melody
                            {
                                Unit unit = k.next();
                                if (unit != null) //if next isn't empty
                                {
                                    themestring += unit.toLeadsheet() + " "; 
                                    //add it to the theme in leadsheet notation
                                }
                            }
                            
                                setValueAt(name, j, NAME_COLUMN);
                                //paste in the name of theme to the table
                                setValueAt(melody.size() / BEAT + "", j, LENGTH_COLUMN);
                                //paste in the theme length
                                setValueAt(themestring, j, THEME_COLUMN);
                                //paste in the theme in leadsheet notation

                                //in case the length is different than the one typed by the user 
                                int n = 0;
                                
                                for (int x = 0; x < soloTable.getRowCount(); x++) { //loop through table
                                    if ((getValueAt(x, NAME_COLUMN) != null)
                                    && ((((String) getValueAt(x, NAME_COLUMN)).equals(name))
                                    || ((String) getValueAt(x, NAME_COLUMN)).equals(name + "- " + n))
                                    && (x != j)
                                    && (((String) getValueAt(x, THEME_COLUMN)).equals(themestring))
                                        ) {
                                        
                                        n += 1; //add one to n so if the same theme 
                                        //is already in the table it will be differentiated from it
                                        //if the names are the same, the rows are different,
                                        //the themes are the same, the lengths are different
                                        setValueAt(melody.size() / BEAT + "", x, LENGTH_COLUMN);
                                        //make the lengths the same 
                                        setValueAt(name + "- " + n, j, NAME_COLUMN);
                                        
                                        //make a copy of the theme and add it to the file and scroll box
                                        Theme copy = Theme.makeTheme(name + "- " + n,melody);
                                        addTheme(copy);
                                        saveRules(fileName);
                                        break;
                                    }
                                }
                                break;
                            }
                        }
                       break;
                    }
                }
            }
        }

        //Play selected theme if shift-clicked
        if (evt.isShiftDown()) {
           for (int i = 0; i < orderedThemes.size(); i++) { //loop through all saved themes
                if (themeList.isSelectedIndex(i)) {
                    String name = (String) themeList.getSelectedValue();
                    Score score = new Score(name); 
                    //create empty score with name of theme selected
                    for (Map.Entry pair : allThemes.entrySet()) {
                        //loop through entries in allThemes

                        if (name == pair.getValue()) { 
                        //if the name in the themeList is equal to the name in the entry
                            Theme theme = (Theme) pair.getKey();
                            //set theme equal to the corresponding theme in that entry
                            MelodyPart melody = theme.melody; //get the melody of the theme
                            score.addPart(melody);
                            PatternDisplay.playScore(notate, score, themeWeaver);
                        }
                    }
                }
            }  
        }
    }//GEN-LAST:event_themeListClicked

    private void OkButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_OkButtonActionPerformed
        if (orderedThemes.contains(nameField.getText())) 
        { //if the user enters a name that is already in orderedThemes
            nameErrorMessage.setVisible(true); //same error message pops up
        }
        
        else {
            for (int i = 0; i < soloTable.getRowCount(); i++) {// loop through table
                
                if (soloTable.isCellSelected(i, NAME_COLUMN)) 
                {  
                        setValueAt(nameField.getText(), i, NAME_COLUMN); 
                        //set the name in the table
                        String name = nameField.getText();
                        String melodyString = (String) getValueAt(i, THEME_COLUMN);
                        MelodyPart themeMelody = new MelodyPart(melodyString);
                        Theme theme = Theme.makeTheme(name, themeMelody);
                        
                        addTheme(theme); 
                        saveRules(fileName);
                        //add the theme to the scroll box and save it
                  }
            }
        }
        nameErrorMessage.setVisible(false); //close the error window
    }//GEN-LAST:event_OkButtonActionPerformed

    private void CancelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CancelButtonActionPerformed
     nameErrorMessage.setVisible(false);   
        
    }//GEN-LAST:event_CancelButtonActionPerformed

    private void cellOkbuttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cellOkbuttonActionPerformed
       enteredIncorrectly.setVisible(false);
    }//GEN-LAST:event_cellOkbuttonActionPerformed

    private void nameFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nameFieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_nameFieldActionPerformed

    private void YesButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_YesButtonActionPerformed
        soloTableModel.tableReset();
        resetCheck.setVisible(false);
    }//GEN-LAST:event_YesButtonActionPerformed

    private void NoButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_NoButtonActionPerformed
        resetCheck.setVisible(false);
    }//GEN-LAST:event_NoButtonActionPerformed

    private void themeListKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_themeListKeyPressed

    }//GEN-LAST:event_themeListKeyPressed

    private void formKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed
        
    }//GEN-LAST:event_formKeyPressed

    private void nameFieldKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_nameFieldKeyPressed
        if (evt.getKeyCode() == KeyEvent.VK_ENTER) {
            
            if (orderedThemes.contains(nameField.getText())) { 
                //if the user enters a name that is already in orderedThemes
                nameErrorMessage.setVisible(true); //same error message pops up
                
            } else {
                for (int i = 0; i < soloTable.getRowCount(); i++) {// loop through table

                    if (soloTable.isCellSelected(i, NAME_COLUMN)) {
                        setValueAt(nameField.getText(), i, NAME_COLUMN);
                        //set the name in the table
                        String name = nameField.getText();
                        String melodyString = (String) getValueAt(i, THEME_COLUMN);
                        MelodyPart themeMelody = new MelodyPart(melodyString);
                        Theme theme = Theme.makeTheme(name, themeMelody);
                        addTheme(theme);
                        saveRules(fileName);
                        //add the theme
                    }
                }
            }
            nameErrorMessage.setVisible(false); //close the error window
        }
    }//GEN-LAST:event_nameFieldKeyPressed

    private void cellOkbuttonKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_cellOkbuttonKeyPressed
      enteredIncorrectly.setVisible(false);
    }//GEN-LAST:event_cellOkbuttonKeyPressed

    private void YesButtonKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_YesButtonKeyPressed
        soloTableModel.tableReset();
        resetCheck.setVisible(false);
    }//GEN-LAST:event_YesButtonKeyPressed

    private void windowClosed(java.awt.event.WindowEvent evt)//GEN-FIRST:event_windowClosed
    {//GEN-HEADEREND:event_windowClosed
    closeWindow();
    }//GEN-LAST:event_windowClosed

    private void exitMenuItemexitMIhandler(java.awt.event.ActionEvent evt)//GEN-FIRST:event_exitMenuItemexitMIhandler
    {//GEN-HEADEREND:event_exitMenuItemexitMIhandler
        closeWindow();
    }//GEN-LAST:event_exitMenuItemexitMIhandler

    private void closeWindowMIActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_closeWindowMIActionPerformed
    {//GEN-HEADEREND:event_closeWindowMIActionPerformed
        closeWindow();
    }//GEN-LAST:event_closeWindowMIActionPerformed

    private void closeWindow()
      {
        WindowRegistry.unregisterWindow(this);
        setVisible(false); 
      }
    
    private void cascadeMIActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_cascadeMIActionPerformed
    {//GEN-HEADEREND:event_cascadeMIActionPerformed
        WindowRegistry.cascadeWindows(this);
    }//GEN-LAST:event_cascadeMIActionPerformed

    private void windowMenuMenuSelected(javax.swing.event.MenuEvent evt)//GEN-FIRST:event_windowMenuMenuSelected
    {//GEN-HEADEREND:event_windowMenuMenuSelected
        windowMenu.removeAll();

        windowMenu.add(closeWindowMI);

        windowMenu.add(cascadeMI);

        for(WindowMenuItem w : WindowRegistry.getWindows())
        windowMenu.add(w.getMI(this));       // these are static, and calling getMI updates the name on them too in case the window title changed

        windowMenu.repaint();
    }//GEN-LAST:event_windowMenuMenuSelected

    private void themeIntervalTextFieldActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_themeIntervalTextFieldActionPerformed
    {//GEN-HEADEREND:event_themeIntervalTextFieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_themeIntervalTextFieldActionPerformed

    private void noThemeProbTextFieldActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_noThemeProbTextFieldActionPerformed
    {//GEN-HEADEREND:event_noThemeProbTextFieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_noThemeProbTextFieldActionPerformed

    private void generateSoloJButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_generateSoloJButtonActionPerformed
        
        ArrayList<ThemeUse> themeUses = new ArrayList<ThemeUse>();
        //create an empty array of themeUses

        for (int i = 0; i < soloTable.getRowCount(); i++) { //loop through table
            
                if ((getValueAt(i, THEME_COLUMN) == null)
                 && (getValueAt(i, LENGTH_COLUMN) != null)) {
                    //if theme cell is empty and length isn't
                    enteredIncorrectly.setVisible(true); //show error message
                    break;
                    
                } else if (getValueAt(i, THEME_COLUMN) != null) {
                    if ((isDouble((String) getValueAt(i, 3)) == false)
                     || (isDouble((String) getValueAt(i, 4)) == false)
                     || (isDouble((String) getValueAt(i, 5)) == false)
                     || (isDouble((String) getValueAt(i, 6)) == false)) {
                        //if theme cell not empty but weighted values are entered wrong
                        enteredIncorrectly.setVisible(true); //show error message 
                        break;
                        
                    } else { //if all cells are entered correctly, form theme uses
                        ThemeUse use = new ThemeUse(new MelodyPart((String) getValueAt(i, THEME_COLUMN)));
                        use.probUse = Double.valueOf((String) getValueAt(i, USE_COLUMN));
                        use.probTranspose = Double.valueOf((String) getValueAt(i, TRANSPOSE_COLUMN));
                        use.probInvert = Double.valueOf((String) getValueAt(i, INVERT_COLUMN));
                        use.probReverse = Double.valueOf((String) getValueAt(i, REVERSE_COLUMN));
                        themeUses.add(use); // add a new ThemeUse to the arraylist with respective elements

                        if (getValueAt(i, NAME_COLUMN) != null) {
                            //if the theme has a name assign it to the theme
                            use.theme.name = (String) getValueAt(i, NAME_COLUMN);
                        }
                    }
                }
            }
        
        generateSolo(themeUses, cm);
        playSelection();
            
           //Set play button to say Stop Playing
            soloPlaying = false;
            stopPlaytoggle.setSelected(false);
            stopPlaytoggle.setText("<html><center>Stop Playing</center></html>");
    }//GEN-LAST:event_generateSoloJButtonActionPerformed

    private void generateThemeJButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_generateThemeJButtonActionPerformed
        generateTheme();
    }//GEN-LAST:event_generateThemeJButtonActionPerformed


    
    private void currentSelectionJButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_currentSelectionJButtonActionPerformed
        // int index = soloTable.getSelectedRow();
        MelodyPart sel = notate.getCurrentStave().getMelodyPart().extract(
                notate.getCurrentSelectionStart(),
                notate.getCurrentSelectionEnd());

        // The commented-out code below illustrates how we can get the relative-pitch
        // melody from a selection, then use it over other chords at other parts
        // of the progression. Moreover, the shape of the original melody
        // will be roughly maintained (except for possible octave displacements).
        // We could use the relative-pitch melody as the Theme in lieu of the
        // absolute pitch one we are now using.
//        Polylist relativePitchMelody = 
//            NoteConverter.melodyPart2Relative(sel, 
//                                              notate.getChordProg(), 
//                                              notate.getCurrentSelectionStart());
//
//        System.out.println("FYI: relative pitch melody: "+ relativePitchMelody);
//        
//        MelodyPart gen = fillMelody(BEAT, 
//                                    relativePitchMelody, 
//                                    notate.getChordProg(),  
//                                    notate.getCurrentSelectionStart());
//        
//        System.out.println("FYI: filled melody: "+ gen);
       
        
        Part.PartIterator i = sel.iterator();
        String theme = "";
        while (i.hasNext()) {
            theme += i.next().toLeadsheet() + " ";
        }
        for (int j = 0; j < soloTable.getRowCount(); j++) { 
         if ((getValueAt(j, NAME_COLUMN) == null) 
          && (getValueAt(j,THEME_COLUMN) == null) 
          && (getValueAt(j, LENGTH_COLUMN) == null)) 
         {
        setValueAt(theme, j, THEME_COLUMN);
        setValueAt(sel.getSize() / BEAT + "", j, LENGTH_COLUMN);
        

           MelodyPart melody = new MelodyPart((String) getValueAt(j, THEME_COLUMN));
           
                for (Map.Entry pair : allThemes.entrySet()) {
                    //loop through all the entry sets of {Theme,name} in allThemes
                    Theme ThemeKey = (Theme) pair.getKey(); //get the Theme of each entry

                    if (melody.toString().equals(ThemeKey.melody.toString())) {
                        //if the melody in allThemes is the name as the melody in the table
                        setValueAt(pair.getValue(), j, NAME_COLUMN);
                        //set the name to the one that matches that theme
                        
                    } else {// if there is no matching theme in allThemes
                        setValueAt(null, j, NAME_COLUMN); //set the name to empty
                    }
                }
                break;
            }
        }
    }//GEN-LAST:event_currentSelectionJButtonActionPerformed

    private void loadThemesMIActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_loadThemesMIActionPerformed
    {//GEN-HEADEREND:event_loadThemesMIActionPerformed

        themesfc.setDialogTitle("Load Themes File");

        themesfc.resetChoosableFileFilters();

        themesfc.addChoosableFileFilter(new ThemesFilter());

        if( themesfc.showOpenDialog(this) == JFileChooser.APPROVE_OPTION )
        {
            cm.execute(new LoadThemesCommand(themesfc.getSelectedFile(), this, notate));
        }

        savedThemes = themesfc.getSelectedFile();
    }//GEN-LAST:event_loadThemesMIActionPerformed

    private void saveAsThemesActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_saveAsThemesActionPerformed
    {//GEN-HEADEREND:event_saveAsThemesActionPerformed

        if( themesfc == null )
        {
            return;
        }

        themesfc.setDialogTitle("Save Themes As");
        themesfc.setCurrentDirectory(ImproVisor.getVocabDirectory());

        // If never saved before, used the name specified in vocFile.
        // Otherwise use previous file.

        if( savedThemes == null )
        {
            themesfc.setSelectedFile(new File(themesFile));
        }

        themesfc.resetChoosableFileFilters();
        themesfc.addChoosableFileFilter(new ThemesFilter());

        if( themesfc.showSaveDialog(this) == JFileChooser.APPROVE_OPTION )
        {
            if( themesfc.getSelectedFile().getName().endsWith(themesExt) )
            {
                new SaveThemesCommand(themesfc.getSelectedFile(), this).execute();

                savedThemes = themesfc.getSelectedFile();
            }
            else
            {
                String file = themesfc.getSelectedFile().getAbsolutePath() + themesExt;

                savedThemes = new File(file);

                new SaveThemesCommand(savedThemes, this).execute();
            }
        }
    }//GEN-LAST:event_saveAsThemesActionPerformed

    private void stopPlaytoggleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stopPlaytoggleActionPerformed
      
        soloPlaying = stopPlaytoggle.isSelected();
        
        if (soloPlaying) {
            stopPlaytoggle.setText("<html><center>Play Solo</center></html>");
             stopPlaying();
             
        } else {
            soloPlaying = false;
            stopPlaytoggle.setSelected(false);
            stopPlaytoggle.setText("<html><center>Stop Playing</center></html>");
            playSelection();
        }
  
    }//GEN-LAST:event_stopPlaytoggleActionPerformed

    private void deleteRowbuttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_deleteRowbuttonActionPerformed
        int index = soloTable.getSelectedRow();
        soloTableModel.removeRow(index);
        
    }//GEN-LAST:event_deleteRowbuttonActionPerformed

    private void deleteThemebuttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_deleteThemebuttonActionPerformed
    
        String name = (String) themeList.getSelectedValue();
        
        
            //delete the desired theme from the table
            for (int j = 0; j < soloTable.getRowCount(); j ++) {
               //System.out.println(name.concat ("- ") + j);
                if ((soloTable.getValueAt(j, NAME_COLUMN) == name ) 
                 || (soloTable.getValueAt(j,NAME_COLUMN) == name.concat("- 1"))) {
                    soloTable.setValueAt(null, j, NAME_COLUMN);
                    soloTable.setValueAt(null, j, LENGTH_COLUMN);
                    soloTable.setValueAt(null, j, THEME_COLUMN);
                }
            }
        
        
            
            //delete the selected theme from file
            for (int i = 0; i < orderedThemes.size(); i++) {
                if (themeList.isSelectedIndex(i)) {
                    deleteTheme(name);
                }
            } 
            
    }//GEN-LAST:event_deleteThemebuttonActionPerformed

boolean soloPlaying = false;

protected ThemeWeaver themeWeaver;

private int themeLength = 8;

private Notate notate;

private int minPitch = 60;

private int maxPitch = 82;

private int minInterval = 0;

private int maxInterval = 6;

private double leapProb = 0.2;

private boolean avoidRepeats = true;

private LickGen lickgen;

private CommandManager cm;

static final int NAME_COLUMN = 0;

static final int LENGTH_COLUMN = 1;

static final int THEME_COLUMN = 2;

static final int USE_COLUMN = 3;

static final int TRANSPOSE_COLUMN = 4;

static final int INVERT_COLUMN = 5;

static final int REVERSE_COLUMN = 6; 

static final int ROW_COUNT = 20;

double probnoTheme;
    
public ThemeListModel themeListModel = new ThemeListModel();

Random random; 

File fileName = ImproVisor.getThemesFile();

private SoloGeneratorTableModel soloTableModel = new SoloGeneratorTableModel (
        new Object [][] {
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null}
            },
            new String [] {
                "Name", "Length", "Theme", "Use", "Transpose", "Invert", "Reverse"
            } ) ;
         
                  
   

public class SoloGeneratorTableModel extends DefaultTableModel 
{
 private static final int columnCount = 7;

    boolean[] canEdit = new boolean [] {
              //name, theme, length, use, transpose, invert, reverse
                true, true , true, true, true, true, true
            };
    
    int [] columnWidths = new int [] {
                55 , 20  , 155   , 7 , 20  , 8,  15
            };
    int [] columnAdjustment = {
                DefaultTableCellRenderer.LEFT, 
                DefaultTableCellRenderer.LEFT, 
                DefaultTableCellRenderer.LEFT, 
                DefaultTableCellRenderer.RIGHT,
                DefaultTableCellRenderer.RIGHT, 
                DefaultTableCellRenderer.RIGHT, 
                DefaultTableCellRenderer.RIGHT, 
            };

    public SoloGeneratorTableModel(Object [][] myTable, String [] columnHeaders)
    {
        super(myTable, columnHeaders);
    }

    public int getColumnWidths(int index) {
        return columnWidths[index];
    }
//
    public int getColumnAdjustments(int index) {
        return columnAdjustment[index];
    }

    @Override
    public boolean isCellEditable(int rowIndex, int columnIndex) {
        return canEdit [columnIndex];
    }

    public void tableRefresh() {
        for (int i = 0; i < soloTable.getRowCount(); i ++ ) {
            
            //add back rows that were deleted
             if (soloTable.getRowCount() != ROW_COUNT) {
                    for (int x = 0; x < ROW_COUNT - soloTable.getRowCount(); x ++)
                    soloTableModel.addARow();
                }
             
                soloTable.setValueAt(null, i, NAME_COLUMN);
                soloTable.setValueAt(null,i, LENGTH_COLUMN);
                soloTable.setValueAt(null,i,THEME_COLUMN); 
                soloTable.setValueAt(null,i,USE_COLUMN);
                soloTable.setValueAt(null,i,TRANSPOSE_COLUMN);
                soloTable.setValueAt(null,i,INVERT_COLUMN);
                soloTable.setValueAt(null,i, REVERSE_COLUMN);
           
        }
        
        fireTableDataChanged();
        themeUsageTextArea.setText(null);
    }
     

    public void tableReset() {

       tableRefresh();
     }


   @Override
    public int getColumnCount() {
        return columnCount;
    }

    public void addARow()
    {
        soloTableModel.insertRow(0, new Object [] {null,
                                                   null,
                                                   null,
                                                   null,
                                                   null,
                                                   null,
                                                   null}
              );
    }
    
  
 @Override
   public Class getColumnClass(int column)
  {
       switch(column)
       {
           case 0:
              return Object.class;
       }
       return Object.class;
  }

  @Override
  public void setValueAt(Object value, int row, int col) {
      super.setValueAt(value,row,col);
      if(themeList.hasFocus())
      {
          return;
      }
      
      switch( col )
      {
          //for naming a theme
          case NAME_COLUMN:
            if (soloTable.isCellSelected(row, NAME_COLUMN)
            && (getValueAt(row, THEME_COLUMN) != null) 
            && (getValueAt(row, NAME_COLUMN) != null)){
                namingSaving(row, col, row);
                return;
            }
              break; 
              
          case LENGTH_COLUMN:
            break; 
          
          //for editing a theme
          case THEME_COLUMN:
            if ((soloTable.isCellSelected(row, THEME_COLUMN)) 
            && (getValueAt(row, THEME_COLUMN) != null)
            && (getValueAt(row,LENGTH_COLUMN) != null)) {
                updateLength(row, col, row);
                return;
            }
            
            //for typing in own theme
            if ((soloTable.isCellSelected(row, THEME_COLUMN)) 
            && (getValueAt(row, THEME_COLUMN) != null)
            && (getValueAt(row,LENGTH_COLUMN) == null)){ 
                addLength(row, col, row);
            }
           break;
      }    
   }
}
  
  public void setValueAt(Object value, int row, int col) {
      soloTable.setValueAt(value,row,col);
      if(!themeList.hasFocus())
        enteringValue(row, col);
  }

    public Object getValueAt(int row, int col) {
      return soloTable.getValueAt(row,col);
  }
 
    //if a theme is edited 
    public void updateLength(int row, int col, int i) {
        MelodyPart melody = new MelodyPart((String) getValueAt(i, THEME_COLUMN));

        int themelength = melody.size() / BEAT;

        if (themelength != getValueAt(i, LENGTH_COLUMN)) { 
        //if the lengths are different
            soloTable.setValueAt(themelength + "", i, LENGTH_COLUMN);
            
            for (Map.Entry pair : allThemes.entrySet()) {
            //loop through all the entry sets of {Theme,name} in allThemes
                Theme ThemeKey = (Theme) pair.getKey();
                //get the Theme of each entry

                if (melody.toString().equals(ThemeKey.melody.toString())) { 
                //if the melody in allThemes is the name as the melody in the table
                    soloTable.setValueAt(pair.getValue(), i, NAME_COLUMN);
                    //set the name to the one that matches that theme
                    
                } else {// if there is no matching theme in allThemes
                    soloTable.setValueAt(null, i, NAME_COLUMN);
                    //set the name to empty
                }
            }
        }
    }
    
    //if a theme is typed in 
    public void addLength(int row, int col, int i) {
        MelodyPart melody = new MelodyPart((String) getValueAt(i, THEME_COLUMN));

        int themelength = melody.size() / BEAT;

        if ((getValueAt(i, NAME_COLUMN) == null)) { //if there is no name
            soloTable.setValueAt(themelength + "", i, LENGTH_COLUMN);
            //set themelength in the table
            
        } else { //if there is already a name
            soloTable.setValueAt(themelength + "", i, LENGTH_COLUMN);
            for (Map.Entry pair : allThemes.entrySet()) {
                //loop through all the entry sets of {Theme,name} in allThemes
                Theme ThemeKey = (Theme) pair.getKey();
                //get the Theme of each entry

                if (melody.toString().equals(ThemeKey.melody.toString())) { 
                //if the melody in allThemes is the name as the melody in the table
                    soloTable.setValueAt(pair.getValue(), i, NAME_COLUMN);
                    //set the name to the one that matches that theme
                } else {// if there is no matching theme in allThemes
                    soloTable.setValueAt(null, i, NAME_COLUMN);
                    //set the name to empty
                }
            }
        }
    }
    
    //when a theme is named
    public void namingSaving(int row, int col, int i) {
        MelodyPart melody = new MelodyPart((String) getValueAt(i, THEME_COLUMN));
        
        int themelength = melody.size() / BEAT;
        String name = (String) getValueAt(i, NAME_COLUMN);
        String themestring = (String) getValueAt(i, THEME_COLUMN);
        MelodyPart themeMelody = new MelodyPart(themestring);
        Theme theme = Theme.makeTheme(name.trim(), themeMelody);

        if (orderedThemes.contains(name)) { //if the user types a name already in the list
            nameErrorMessage.setVisible(true);
            //give name error message to rename the theme
            
        } else {
            if (!name.trim().isEmpty()) { //if the name is not whitespace
                
                for (Map.Entry pair : allThemes.entrySet().toArray(new Map.Entry[0])) {
                    // loop through the entries of allThemes
                    Theme ThemeKey = (Theme) pair.getKey();
                    //get the Theme of each entry
                    String nameValue = (String) pair.getValue();
                    //get the name of each entry

                    if (melody.toString().equals(ThemeKey.melody.toString())) {

                        deleteTheme(nameValue); //delete the old theme
                        addTheme(theme); //add the new one

                        saveRules(fileName);
                        themeListModel.reset();

                        nameErrorMessage.setVisible(false);
                        break;

                    } else { //if there is no melody that matches the one in the table
                        addTheme(theme);
                        saveRules(fileName);
                    }
                }
            }
        }
    }
    
    public void enteringValue(int row, int col) {
        for (int i = 0; i < soloTable.getRowCount(); i++) { //loop through table
            //updating length
            if ((soloTable.isCellSelected(i, THEME_COLUMN)) 
            && (getValueAt(i, THEME_COLUMN) != null)
            && (getValueAt(i,LENGTH_COLUMN) != null)) {
                updateLength(row, col, i);
                return;
            }
            //for typing in own theme
            if ((soloTable.isCellSelected(i, THEME_COLUMN)) 
            && (getValueAt(i, THEME_COLUMN) != null)
            && (getValueAt(i,LENGTH_COLUMN) == null)
                    )        
            { 
                addLength(row, col, i);
                return;
            }
            
            //naming and saving
            if (soloTable.isCellSelected(i, NAME_COLUMN)
            && (getValueAt(i, THEME_COLUMN) != null) 
            && (getValueAt(i, NAME_COLUMN) != null))
            { //if name cell is selected, it's not empty and the theme isn't empty
                namingSaving(row, col, i);
                return;
            }
        }
     }
  


 private static LinkedHashMap<Theme, String> allThemes = new LinkedHashMap<Theme, String>();
 private static ArrayList<String> orderedThemes = null;
 int allThemesIndex = allThemes.size() - 1;
  
  public static int numberOfThemes()
    {
      ensureThemeArray();
      return orderedThemes.size(); 
    }
  
  public static void setTheme(String name, Theme theme)
    {
      allThemes.put(theme, name);
    }
  
    public static String getNth(int index)
      {
        ensureThemeArray();
        return orderedThemes.get(index);
      }
    
    private static void ensureThemeArray()
      {
            orderedThemes = new ArrayList<String>(allThemes.values());
       }
    
public void addTheme(Theme theme)
    {
        ensureThemeArray();
        int orderedThemesIndex = orderedThemes.size() - 1;
        String name = theme.name;
        
        for (int i = 0; i < soloTable.getRowCount(); i++) {
            if ( (!orderedThemes.contains(name))) {
            // if ordered themes doesn't already have it, add to both 
                //orderedThemes and allThemes
                orderedThemes.add(name);
                allThemes.put(theme, name);
            }
            // reset themeListModel so it will update to add the new theme
            themeListModel.reset();
            orderedThemesIndex = orderedThemes.indexOf(theme);
        }
    }


//delete a theme from a file based on the string name shown in the Themes scroll box
public void deleteTheme(String name) {
    
    orderedThemes.remove(name);
    
    for (Map.Entry pair : allThemes.entrySet()) {
        if (name.equals(pair.getValue())) { 
        //if the name in the themeList is equal to the name in the entry
            Theme theme = (Theme) pair.getKey(); 
            allThemes.remove(theme);
            break;
        }
    }
     
    saveRules(fileName);
    themeListModel.reset();
}

//saving themes into My.themes
    public void saveRules(File file) {
        try {
            java.io.PrintStream out = new PrintStream(new FileOutputStream(file));
            
            for (Map.Entry pair : allThemes.entrySet()) {
                Theme key = (Theme) pair.getKey();
                //key.showForm(System.out);
                key.showForm(out);
            }
            
        } catch (IOException e) {
            ErrorLog.log(ErrorLog.SEVERE, "Saving themes in file failed: " + file);
        }
    }

//load the themes in My.themes into the Theme Weaver window
public void loadFromFile(File file) {
    java.io.FileInputStream themeStream;

        try {
            themeStream = new FileInputStream(file);
        } catch(Exception e) {
            ErrorLog.log(ErrorLog.SEVERE, "Loading themes in file failed: " + file); 
            return;
        }

        Tokenizer in = new Tokenizer(themeStream);
        Object ob;

        while( (ob = in.nextSexp()) != Tokenizer.eof ) {
            if( ob instanceof Polylist)  {
                Polylist themePoly = (Polylist)ob;
                Theme theme = new Theme(themePoly);
                addTheme(theme);
                //System.out.println("adding " + theme);
                //System.out.println(orderedThemes);
            }
        }
    }

public class ThemeListModel
    extends AbstractListModel
{
  
public int getSize()
  {
   int number = numberOfThemes();
    
    return number;
      
  }

public Object getElementAt(int index)
  {
     return getNth(index);
  }

public void reset()
  {
    fireContentsChanged(this, 0, getSize());
  }

public void adjust()
  {
    fireIntervalAdded(this, 0, getSize());
  }

}

public static boolean isInteger(String s) {
    try {
        Integer.parseInt(s);
    }
    catch(NumberFormatException e) {
        return false;
    }
    return true;
}

public static boolean isDouble(String s) {
    try {
        Double.parseDouble(s);
    }
    catch (NumberFormatException e) {
        return false;
    }
    return true;
}
  
/**
 * This fillMelody is called in three places within ThemeWeaver.
 * 
 * @param beatValue
 * @param rhythmString
 * @param chordProg
 * @param start
 * @return 
 */
public MelodyPart fillMelody(int beatValue,
                             Polylist rhythmString, 
                             ChordPart chordProg,
                             int start)
  {
    MelodyPart result = lickgen.fillMelody(minPitch, 
                                           maxPitch, 
                                           minInterval, 
                                           maxInterval,
                                           beatValue, 
                                           leapProb, 
                                           rhythmString, 
                                           chordProg,
                                           start, 
                                           avoidRepeats);

    return result;
  } 

//work in progress
public void ExpandCommand(Polylist list) {
     Polylist melodyList = (Polylist)list.last(); //get polylist of the melody
         Polylist melodyNotes = melodyList.rest(); //get the notes in a polylist
         
         PolylistEnum melodyElements = melodyNotes.elements(); //get the notes as elements
         
         //To get the notes of the theme in a string:
         String melodyString = "";
         while (melodyElements.hasMoreElements()) { //while there are more notes
           Object current =  melodyElements.nextElement();//get next note
             String currentString = current.toString(); //convert it to String
             if (currentString.length() == 2) {
             int intValue = Integer.parseInt(currentString.charAt(1) + "");
             int newValue = intValue/2;
            //System.out.println(newValue);
            //System.out.println(currentString.charAt(0));
             String newNote = currentString.charAt(0) + newValue + "";
            // System.out.println(newNote);
             melodyString += newNote + " "; //add the note to the melodyString
             }
             else if (currentString.length() == 3) {
                 int newValue = currentString.charAt(2)/2;
                 String newNote = currentString.charAt(0) + currentString.charAt(1) + newValue + "";
                 melodyString += newNote + " "; //add the note to the melodyString
             }
             else {
                 int newValue = currentString.charAt(3)/2;
                 String newNote = currentString.charAt(0) + currentString.charAt(1) + currentString.charAt(2) + newValue + "";
                 melodyString += newNote + " "; //add the note to the melodyString
                 
             }
         }  
         //System.out.println(melodyString);
         MelodyPart melody = new MelodyPart(melodyString); //create a MelodyPart of the string
}

    public MelodyPart generateTheme() { 
        for (int x = 0; x < soloTable.getRowCount(); x++) { //loop through the rows of the table
            if ((getValueAt(x, LENGTH_COLUMN) != null)
             && (!isInteger((String) getValueAt(x, LENGTH_COLUMN)))) {
                enteredIncorrectly.setVisible(true);
              } 
            else {
                
               if  (((soloTable.isCellSelected(x, LENGTH_COLUMN)) 
                  && (getValueAt(x, LENGTH_COLUMN) != null))
                  || ((getValueAt(x, LENGTH_COLUMN) != null) 
                  && (getValueAt(x,THEME_COLUMN) == null))){
                   //if the theme length cell is selected and has something in it 
                 // or if there is something in a length cell and has no theme
                   
                   //set default values for weighted values
                    soloTable.setValueAt("1",x,USE_COLUMN);
                    soloTable.setValueAt("0",x,TRANSPOSE_COLUMN);
                    soloTable.setValueAt("0",x,INVERT_COLUMN);
                    soloTable.setValueAt("0",x, REVERSE_COLUMN);
                    
                    int Length = notate.intFromStringInRange((String) getValueAt(x, LENGTH_COLUMN), 0, 100, themeLength); 
                    //get length from tablek
                    themeLength = BEAT * Length;
                    Polylist rhythm = lickgen.generateRhythmFromGrammar(0, themeLength); 
                    //get rhythm for theme from grammar

                    MelodyPart lick = fillMelody(BEAT, rhythm, notate.getChordProg(), 0); 
                    //get the melody of the theme

                    Part.PartIterator i = lick.iterator(); //iterate over lick
                    String theme = ""; //set theme as empty to start
                    
                    while (i.hasNext()) //while you can still iterate through the lick
                    {
                        Unit unit = i.next();
                        if (unit != null) //if next isn't empty
                        {
                            theme += unit.toLeadsheet() + " "; //add it to the theme
                        }
                    }

                    soloTable.setValueAt(theme, x, THEME_COLUMN); 
                    //make theme appear in table 
                    
                    if (getValueAt(x, NAME_COLUMN) != null) {
                        soloTable.setValueAt(null, x, NAME_COLUMN);
                    }
                }
            }
        }
        return null;
    }


       public MelodyPart generateSolohelper(ThemeUse chosenthemeUse, MelodyPart chosentheme, MelodyPart solo, CommandManager cm) {
        int length = chosentheme.size(); // get length of theme
        MelodyPart adjustedTheme = chosentheme.copy(); //made a copy of the theme
        imp.ImproVisor.setPlayEntrySounds(false); //don't play yet
        int unmodified = 0; 
        int multipleuse = 0;
        
        if (Notate.bernoulli(chosenthemeUse.probTranspose)) {
            // if a random number is greater than the probability not to transpose theme
            multipleuse += 1;
            //System.out.println("Transpose");
            themeUsageTextArea.append("transposed");
            ChordPart chordProg = notate.getChordProg(); //get current chord progression
            int rise = PitchClass.findRise(PitchClass.getPitchClass(chordProg.getCurrentChord(0).getRoot()),
                    PitchClass.getPitchClass(chordProg.getCurrentChord(length).getRoot()));
            //set rise equal to the rise of semitones from the root of the 0 chord to i chord
            int index = 0;
            Note n = adjustedTheme.getNote(index); //get the note of the theme at index 0

            while (n.isRest()) 
            { //while there is still theme left
                index += n.getRhythmValue(); //add the rhythm value of the theme to the index
                n = adjustedTheme.getNote(index); //get the note of the theme at new index
            }

            if (n.getPitch() >= (minPitch + maxPitch) / 2 && rise > 0)
            { // if pitch of theme is greater than or equal to the average pitch and change in semitones increased
                cm.execute(new ShiftPitchesCommand(-1 * (12 - rise), adjustedTheme,
                        0, length, 0, 128, notate.getScore().getKeySignature()));
            } //shift theme pitches down an octave + rise from 0 to the end of the theme
            
            else if (n.getPitch() < (minPitch + maxPitch) / 2 && rise < 0)
            { //if pitch of theme is less than the average pitch and change in semitones increased
                cm.execute(new ShiftPitchesCommand((12 + rise), adjustedTheme,
                        0, length, 0, 128, notate.getScore().getKeySignature()));
            } //shift theme pitches up an octave + rise from 0 to end of theme
            
            else {
                cm.execute(new ShiftPitchesCommand(rise, adjustedTheme, 0, length, 0, 128, notate.getScore().getKeySignature()));
            }
            //shift theme pitches by the rise in semitones
        } 
        
        else {
            unmodified += 1;
        }

        if (Notate.bernoulli(chosenthemeUse.probInvert))
        { // if a random number is greater than the probability not to invert the theme
            multipleuse += 1;
            if (multipleuse == 2) {
                themeUsageTextArea.append(", and inverted");
            }
            //System.out.println("Invert");
            if (!(multipleuse == 2)) {
               themeUsageTextArea.append("inverted"); 
            }
            cm.execute(new InvertCommand(adjustedTheme, 0, length, false)); //invert theme
           }
        
           else {
               unmodified += 1;
           }

           if (Notate.bernoulli(chosenthemeUse.probReverse)) { 
           // if a random number is greater than the probability not to reverse the theme
               multipleuse += 1;
               //System.out.println("Reverse");
               
               if (multipleuse == 1) {
                   themeUsageTextArea.append("reversed");
               }
               
               if (multipleuse != 1) {
                   themeUsageTextArea.append(", and reversed");
               }
               
               cm.execute(new ReverseCommand(adjustedTheme, 0, length, false)); //reverse theme
               
           } else {
               unmodified += 1;
           }

           if (unmodified == 3) {
               themeUsageTextArea.append(" unmodified");
           }
        
        themeUsageTextArea.append("\n");
        ChordPart themeChords = notate.getChordProg().extract(length, length + length);
        //set chords of theme to be the chordpart extracted from length to length +length
        cm.execute(new RectifyPitchesCommand(adjustedTheme, 0, length, themeChords, false, false)); 
        //resolve pitches of the theme
        solo.setSize(solo.getSize() + length); 
        //set size of solo to the existing length of the solo plus the length of the theme
        return adjustedTheme;

    }
        
      public void generateSolohelper2(int themeLength, MelodyPart solo) {
        Polylist rhythm = lickgen.generateRhythmFromGrammar(0, themeLength); 
        //generate rhythm 

        MelodyPart lick = fillMelody(BEAT, rhythm, notate.getChordProg(), 0);
        //create melody


        Part.PartIterator j = lick.iterator(); //iterate over lick
        lick.setSize(themeLength);
        while (j.hasNext()) //while any lick is left
        {
            Unit unit = j.next();
            if (unit != null) //if next is not empty
            {
                solo.addNote(NoteSymbol.toNote(unit.toLeadsheet())); 
                //add the unit to the solo
            }
        }
    }
        

    public void generateSolo(ArrayList<ThemeUse> themeUses, CommandManager cm) {
        themeUsageTextArea.setText(null);
        //System.out.println(themeUses);
        // create four empty lists to start for all the probabilities
        List<Double> probUselist = new ArrayList(Arrays.asList());
        List<Double> probTransposelist = new ArrayList(Arrays.asList());
        List<Double> probInvertlist = new ArrayList(Arrays.asList());
        List<Double> probReverselist = new ArrayList(Arrays.asList());
        
        int n = 0;
        
        //loop through the themeUses list and get the probabilities for each
        //themeuse and add it to the corresponding empty list
        for (int i = 0; i < themeUses.size(); i++) {
            
            probUselist.add(themeUses.get(i).probUse);
            probTransposelist.add(themeUses.get(i).probTranspose);
            probInvertlist.add(themeUses.get(i).probInvert);
            probReverselist.add(themeUses.get(i).probReverse); 
            
            //give names to themes that don't have one for text area
            if (themeUses.get(i).theme.name == null) {
                n += 1;
                themeUses.get(i).theme.name = "Theme " + n;
            }
        }
        
       
        // find max of probability use to use that corresponding theme first
        double max = Collections.max(probUselist);
        int index = probUselist.indexOf(max); //get the index of the max
        int length = themeUses.get(index).theme.melody.getSize(); 
        //get length of theme
        themeLength = length; //set themeLength to it
        MelodyPart solo = new MelodyPart(themeLength); 
        //set solo equal to a MelodyPart of the theme length

        imp.ImproVisor.setPlayEntrySounds(false); //don't play insertions yet

        solo.pasteSlots(themeUses.get(index).theme.melody, 0); 
        //paste theme into solo at starting point
        
        themeUsageTextArea.append("Bar 1: " + themeUses.get(index).theme.name + " unmodified \n");
        
        // set totals of probabilities to 0
        int probUsetotal = 0;
        int probTransposetotal = 0;
        int probInverttotal = 0;
        int probReversetotal = 0;

        //loop through each respective list and add elements together to get 
        //the total of each probability
        // multiply each element by 10 so its an integer
        for (int i = 0; i < themeUses.size(); i++) {
            probUsetotal += 10 * probUselist.get(i);
            probTransposetotal += 10 * probTransposelist.get(i);
            probInverttotal += 10 * probInvertlist.get(i);
            probReversetotal += 10 * probReverselist.get(i);
        }
        
        //use Theme Use Interval from text field
        int themeInterval = new Integer(themeIntervalTextField.getText());
        int themeIntervalUse = themeInterval * 120;
        
        for (int i = length; i <= notate.getScoreLength() - themeIntervalUse; i += themeIntervalUse) { 
            //loop through the remaining length of the score
             int beat = i/120;
             int bar = 1 + (beat/notate.getBeatsPerMeasure());
             Integer noThemevalue = (int)(10*themeUses.size()*Double.valueOf(noThemeProbTextField.getText()));
            
            int themei = random.nextInt(probUsetotal + noThemevalue);
            //System.out.println(themei); 
            //pick a random number from 0 inclusive to 10*the probability list size
            //since all the elements in the list are multpled by 10, the size has to be multiplied by 10 too
            
            
            //To implement the probabilities I broke up the size of the list times 10 into intervals
            //the first interval is from 0 to to the first probability - 1 
            //so that way the number of slots in that interval is equal
            //to that first probability times 10
            //so if the random number chosen is in that interval, then that first theme is used
            if (themei <= 10 * probUselist.get(0) - 1) {
                //System.out.println("Theme 1");
                MelodyPart chosentheme = themeUses.get(0).theme.melody;
                ThemeUse chosenthemeUse = themeUses.get(0);
                themeUsageTextArea.append( "Bar " + bar + ": " + chosenthemeUse.theme.name );
                MelodyPart adjustedTheme = generateSolohelper(chosenthemeUse, chosentheme, solo, cm);
                
                //this if takes care of the case if the index is out of bounds
                if (i + adjustedTheme.size() >= solo.getSize()) {
                    generateSolohelper2(themeLength, solo);
                } 
                
                else {
                // if there is no index out of bounds issue, then add the adjusted theme into the solo
                    solo.pasteSlots(adjustedTheme, i);
                }
            } 
            //if the themeUses size is more than one themeuse then the other intervals have to be accounted for 
            
            else if (themeUses.size() > 1) {

                double A = 0;
                double B = 10 * probUselist.get(0);

                //this loop covers the rest of the intervals
                for (int k = 0; k < probUselist.size() - 1; k++) {
                    A += 10 * probUselist.get(k);
                    B += 10 * probUselist.get(k + 1);

                    if ((themei >= A) && (themei <= B - 1)) {
                        
                        int x = k + 2;
                        //System.out.println("Theme " + x);
                        ThemeUse chosenthemeUse = themeUses.get(k + 1);
                        MelodyPart chosentheme = themeUses.get(k + 1).theme.melody;
                        themeUsageTextArea.append("Bar " + bar + ": " + chosenthemeUse.theme.name);
                        MelodyPart adjustedTheme = generateSolohelper(chosenthemeUse, chosentheme, solo, cm);

                        if (i + adjustedTheme.size() >= solo.getSize()) {
                            generateSolohelper2(themeLength, solo);
                            
                        } else {
                            solo.pasteSlots(adjustedTheme, i);
                        }
                    }
                }
            }

            //this interval is for not using any theme at all    
            if ((themei <= probUsetotal + noThemevalue) && (themei >= probUsetotal)) {
                //System.out.println("no Theme");
                themeUsageTextArea.append("Bar " + bar + ": No Theme used\n");
                generateSolohelper2(themeLength, solo);
            }
        }


        if (notate.getScore().getLength() - solo.getSize() != 0) { 
            //if the length of the score does not equal the length of the solo
            Polylist rhythm = lickgen.generateRhythmFromGrammar(0, notate.getScore().getLength() - solo.getSize());
            // generate rhythm for the space

            MelodyPart lick = fillMelody(BEAT, rhythm, notate.getChordProg(), 0); 
            //create melody for the space

            Part.PartIterator j = lick.iterator(); //iterate over the lick
            while (j.hasNext()) //while lick has next
            {
                solo.addNote(NoteSymbol.toNote(j.next().toLeadsheet())); 
                //add the note of the lick to the solo
            }
        }
        notate.setCurrentSelectionStart(0); //start selection at beginning

        // Experimental: Resolve pitches in entire solo: seems to improve things, but
        // may generate some repeated notes.
        cm.execute(new RectifyPitchesCommand(solo, 0, solo.getSize(), notate.getChordProg(), false, false));

        notate.pasteMelody(solo); //paste solo into leadsheet

        imp.ImproVisor.setPlayEntrySounds(true); //play solo
    }



    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton CancelButton;
    private javax.swing.JButton NoButton;
    private javax.swing.JButton OkButton;
    private javax.swing.JButton Reset;
    private javax.swing.JLabel Resettable;
    private java.awt.Label SoloGeneratorTitle;
    private java.awt.Label ThemesLabel;
    private javax.swing.JButton YesButton;
    private javax.swing.JMenuItem cascadeMI;
    private javax.swing.JButton cellOkbutton;
    private javax.swing.JLabel chooseName;
    private javax.swing.JMenuItem closeWindowMI;
    private javax.swing.JButton currentSelectionJButton;
    private javax.swing.JButton deleteRowbutton;
    private javax.swing.JButton deleteThemebutton;
    private javax.swing.JDialog enteredIncorrectly;
    private javax.swing.JButton generateSoloJButton;
    private javax.swing.JButton generateThemeJButton;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JPopupMenu.Separator jSeparator5;
    private javax.swing.JMenuItem loadThemesMI;
    private javax.swing.JDialog nameErrorMessage;
    private javax.swing.JTextField nameField;
    private javax.swing.JLabel namePicked;
    private javax.swing.JLabel noThemeProbLabel;
    private javax.swing.JTextField noThemeProbTextField;
    private javax.swing.JDialog resetCheck;
    private javax.swing.JMenuBar roadmapMenuBar;
    private javax.swing.JMenuItem saveAsAdvice;
    private javax.swing.JTable soloTable;
    private javax.swing.JScrollPane soloTableScrollPane;
    private javax.swing.JToggleButton stopPlaytoggle;
    private javax.swing.JLabel themeIntervalLabel;
    private javax.swing.JTextField themeIntervalTextField;
    private javax.swing.JList themeList;
    private javax.swing.JScrollPane themeListScrollPane;
    private javax.swing.JScrollPane themeUsageScrollPane;
    private javax.swing.JTextArea themeUsageTextArea;
    private javax.swing.JLabel tryAgain;
    private javax.swing.JLabel typedWrong;
    private javax.swing.JMenu windowMenu;
    private javax.swing.JSeparator windowMenuSeparator;
    private javax.swing.JLabel youSure;
    // End of variables declaration//GEN-END:variables
} 


