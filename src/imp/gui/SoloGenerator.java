/**
 * This Java Class is part of the Impro-Visor Application
 *
 * Copyright (C) 2014 Robert Keller and Harvey Mudd College
 *
 * Impro-Visor is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * Impro-Visor is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * merchantability or fitness for a particular purpose.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Impro-Visor; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
package imp.gui;

import static imp.Constants.BEAT;
import imp.com.CommandManager;
import imp.com.InvertCommand;
import imp.com.PlayScoreCommand;
import imp.com.RectifyPitchesCommand;
import imp.com.ReverseCommand;
import imp.com.ShiftPitchesCommand;
import imp.data.ChordPart;
import imp.data.MelodyPart;
import imp.data.Note;
import imp.data.NoteSymbol;
import imp.data.Part;
import imp.data.PitchClass;
import imp.data.Unit;
import polya.Polylist;
import imp.lickgen.LickGen;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import javax.swing.table.DefaultTableModel;
import javax.swing.ListSelectionModel;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Arrays;
import javax.swing.AbstractListModel;
import javax.swing.JLabel;
import java.util.List;
import java.util.Random;
import java.util.Collections;
import java.util.LinkedHashMap;
import imp.util.ErrorLog;
import java.util.Map;
import imp.ImproVisor;
import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.io.FileOutputStream;
import java.io.FileInputStream;
import polya.Tokenizer;
import imp.gui.PatternDisplay;
import imp.data.Score;
import javax.swing.table.DefaultTableCellRenderer;
import polya.PolylistEnum;
/**
 *
 * @author David Morrison, Nava Dallal
 */
public class SoloGenerator extends javax.swing.JFrame {
    
 String TITLE = "Solo Generator";
 LickgenFrame lickgenFrame;

    /**
     * Creates new form SoloGenerator
     */
    public SoloGenerator(LickGen lickgen, Notate notate, CommandManager cm) {
        this.random = new Random();
        initComponents();
    //    testDialog.setVisible(true);
    this.cm = cm;
    this.lickgen = lickgen;
    this.notate = notate;
    
    setTitle(TITLE);
    WindowRegistry.registerWindow(this);
    soloTable.setModel(soloTableModel);
    soloTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
    soloTable.addMouseListener(new MouseAdapter() {
        public void mouseReleased(MouseEvent e) {
            if(e.getClickCount() >= 1) {
                int row = soloTable.rowAtPoint(e.getPoint());
              soloTable.getSelectionModel().setSelectionInterval(row,row);
            }
           
        }
    });
    setTableColumnWidths();
    loadFromFile(fileName);
    }

public void setTableColumnWidths()
  {
      for(int j = 0; j < soloTableModel.getColumnCount();j++)
    {
        soloTable.getColumnModel().getColumn(j).
                setPreferredWidth(soloTableModel.getColumnWidths(j));
    }


    for(int j = 0; j < soloTableModel.getColumnCount(); j++)
    {
        DefaultTableCellRenderer renderer = new DefaultTableCellRenderer();
        renderer.setHorizontalAlignment( soloTableModel.getColumnAdjustments(j));
        soloTable.getColumnModel().getColumn(j).setCellRenderer( renderer );
    }
  }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        nameErrorMessage = new javax.swing.JDialog();
        nameField = new javax.swing.JTextField();
        namePicked = new javax.swing.JLabel();
        CancelButton = new javax.swing.JButton();
        OkButton = new javax.swing.JButton();
        chooseName = new javax.swing.JLabel();
        enteredIncorrectly = new javax.swing.JDialog();
        typedWrong = new javax.swing.JLabel();
        tryAgain = new javax.swing.JLabel();
        cellOkbutton = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        resetCheck = new javax.swing.JDialog();
        Resettable = new javax.swing.JLabel();
        youSure = new javax.swing.JLabel();
        YesButton = new javax.swing.JButton();
        NoButton = new javax.swing.JButton();
        AlreadyNamed = new javax.swing.JDialog();
        OverwriteOption = new javax.swing.JLabel();
        YesOverwrite = new javax.swing.JButton();
        NoOverwrite = new javax.swing.JButton();
        deleteCheck = new javax.swing.JDialog();
        deletesure = new javax.swing.JLabel();
        Okdelete = new javax.swing.JButton();
        Nodelete = new javax.swing.JButton();
        soloTableScrollPane = new javax.swing.JScrollPane();
        soloTable = new javax.swing.JTable();
        themeListScrollPane = new javax.swing.JScrollPane();
        themeList = new javax.swing.JList();
        themeUsageScrollPane = new javax.swing.JScrollPane();
        themeUsageTextArea = new javax.swing.JTextArea();
        ThemesLabel = new java.awt.Label();
        generateSolo = new java.awt.Button();
        generateTheme = new java.awt.Button();
        currentSelection = new java.awt.Button();
        playSolo = new java.awt.Button();
        stopPlaying = new java.awt.Button();
        SoloGeneratorTitle = new java.awt.Label();
        Reset = new javax.swing.JButton();
        themeIntervalTextField = new javax.swing.JTextField();
        themeIntervalLabel = new javax.swing.JLabel();
        noThemeProbTextField = new javax.swing.JTextField();
        noThemeProbLabel = new javax.swing.JLabel();
        roadmapMenuBar = new javax.swing.JMenuBar();
        javax.swing.JMenu fileMenu = new javax.swing.JMenu();
        javax.swing.JMenuItem exitMenuItem = new javax.swing.JMenuItem();
        windowMenu = new javax.swing.JMenu();
        closeWindowMI = new javax.swing.JMenuItem();
        cascadeMI = new javax.swing.JMenuItem();
        jSeparator5 = new javax.swing.JPopupMenu.Separator();
        windowMenuSeparator = new javax.swing.JSeparator();

        nameErrorMessage.setMinimumSize(new java.awt.Dimension(500, 400));
        nameErrorMessage.getContentPane().setLayout(new java.awt.GridBagLayout());

        nameField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nameFieldActionPerformed(evt);
            }
        });
        nameField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                nameFieldKeyPressed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 4;
        gridBagConstraints.ipadx = 309;
        gridBagConstraints.ipady = 12;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 20, 0, 0);
        nameErrorMessage.getContentPane().add(nameField, gridBagConstraints);

        namePicked.setText("The name you have picked is already assigned to a theme. ");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 5;
        gridBagConstraints.ipadx = 75;
        gridBagConstraints.ipady = 15;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(53, 20, 0, 0);
        nameErrorMessage.getContentPane().add(namePicked, gridBagConstraints);

        CancelButton.setText("Cancel");
        CancelButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CancelButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(12, 43, 105, 0);
        nameErrorMessage.getContentPane().add(CancelButton, gridBagConstraints);

        OkButton.setText("Ok");
        OkButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                OkButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.ipadx = -18;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(12, 20, 105, 0);
        nameErrorMessage.getContentPane().add(OkButton, gridBagConstraints);

        chooseName.setText("Please choose another:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.ipadx = 44;
        gridBagConstraints.ipady = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 20, 0, 0);
        nameErrorMessage.getContentPane().add(chooseName, gridBagConstraints);

        enteredIncorrectly.setMinimumSize(new java.awt.Dimension(400, 300));
        enteredIncorrectly.getContentPane().setLayout(new java.awt.GridBagLayout());

        typedWrong.setText("You have either typed information into a cell incorrectly,");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(80, 24, 0, 21);
        enteredIncorrectly.getContentPane().add(typedWrong, gridBagConstraints);

        tryAgain.setText("Please try again.");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 6, 0, 0);
        enteredIncorrectly.getContentPane().add(tryAgain, gridBagConstraints);

        cellOkbutton.setText("Ok");
        cellOkbutton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cellOkbuttonActionPerformed(evt);
            }
        });
        cellOkbutton.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                cellOkbuttonKeyPressed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(18, 79, 107, 0);
        enteredIncorrectly.getContentPane().add(cellOkbutton, gridBagConstraints);

        jLabel1.setText("not finished entering contents into a cell, or left a cell");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 4;
        gridBagConstraints.ipadx = 15;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(12, 24, 0, 21);
        enteredIncorrectly.getContentPane().add(jLabel1, gridBagConstraints);

        jLabel2.setText("blank.");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 24, 0, 0);
        enteredIncorrectly.getContentPane().add(jLabel2, gridBagConstraints);

        resetCheck.setMinimumSize(new java.awt.Dimension(500, 300));
        resetCheck.getContentPane().setLayout(new java.awt.GridBagLayout());

        Resettable.setText("Resetting the table will clear everything you currently have entered. ");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 5;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(96, 39, 0, 77);
        resetCheck.getContentPane().add(Resettable, gridBagConstraints);

        youSure.setText("Are you sure you want to do this?");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 137, 0, 0);
        resetCheck.getContentPane().add(youSure, gridBagConstraints);

        YesButton.setText("Yes, Continue");
        YesButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                YesButtonActionPerformed(evt);
            }
        });
        YesButton.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                YesButtonKeyPressed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(31, 78, 150, 0);
        resetCheck.getContentPane().add(YesButton, gridBagConstraints);

        NoButton.setText("No, Cancel");
        NoButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                NoButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.ipadx = 16;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(31, 76, 150, 0);
        resetCheck.getContentPane().add(NoButton, gridBagConstraints);

        AlreadyNamed.setBounds(new java.awt.Rectangle(22, 22, 22, 22));
        AlreadyNamed.getContentPane().setLayout(new java.awt.GridBagLayout());

        OverwriteOption.setText("This theme already has a name. Would you like to overwrite it? ");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(120, 20, 0, 22);
        AlreadyNamed.getContentPane().add(OverwriteOption, gridBagConstraints);

        YesOverwrite.setText("Yes");
        YesOverwrite.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                YesOverwriteActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(18, 84, 147, 0);
        AlreadyNamed.getContentPane().add(YesOverwrite, gridBagConstraints);

        NoOverwrite.setText("No");
        NoOverwrite.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                NoOverwriteActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(18, 70, 147, 0);
        AlreadyNamed.getContentPane().add(NoOverwrite, gridBagConstraints);

        deleteCheck.setBounds(new java.awt.Rectangle(22, 22, 22, 22));
        deleteCheck.setMinimumSize(new java.awt.Dimension(450, 350));
        deleteCheck.getContentPane().setLayout(new java.awt.GridBagLayout());

        deletesure.setText("Are you sure you want to delete this row?");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.ipadx = 67;
        gridBagConstraints.ipady = 13;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(89, 68, 0, 6);
        deleteCheck.getContentPane().add(deletesure, gridBagConstraints);

        Okdelete.setText("Yes");
        Okdelete.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                OkdeleteActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(18, 78, 135, 0);
        deleteCheck.getContentPane().add(Okdelete, gridBagConstraints);

        Nodelete.setText("No");
        Nodelete.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                NodeleteActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(18, 71, 135, 0);
        deleteCheck.getContentPane().add(Nodelete, gridBagConstraints);

        setLocation(new java.awt.Point(10, 10));
        setLocationByPlatform(true);
        setMaximumSize(new java.awt.Dimension(2140, 800));
        setMinimumSize(new java.awt.Dimension(1000, 500));
        setPreferredSize(new java.awt.Dimension(800, 630));
        setSize(new java.awt.Dimension(1000, 600));
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosed(java.awt.event.WindowEvent evt) {
                SoloGenerator.this.windowClosed(evt);
            }
        });
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
        });
        getContentPane().setLayout(new java.awt.GridBagLayout());

        soloTableScrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        soloTableScrollPane.setMaximumSize(new java.awt.Dimension(32767, 400));
        soloTableScrollPane.setMinimumSize(new java.awt.Dimension(23, 350));
        soloTableScrollPane.setPreferredSize(new java.awt.Dimension(469, 200));

        soloTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null}
            },
            new String [] {
                "Name", "Theme Length", "Theme", "Prob. to Use", "Prob. to Transpose", "Prob. to Invert", "Prob. to Reverse"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }
        });
        soloTable.setAlignmentY(1.0F);
        soloTable.setColumnSelectionAllowed(true);
        soloTable.setGridColor(new java.awt.Color(0, 0, 0));
        soloTable.setMinimumSize(new java.awt.Dimension(105, 200));
        soloTable.setPreferredSize(null);
        soloTable.setSelectionBackground(javax.swing.UIManager.getDefaults().getColor("CheckBoxMenuItem.selectionBackground"));
        soloTable.setShowGrid(true);
        soloTable.getTableHeader().setReorderingAllowed(false);
        soloTable.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                soloTableMouseClicked(evt);
            }
        });
        soloTable.addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentShown(java.awt.event.ComponentEvent evt) {
                soloTableComponentShown(evt);
            }
        });
        soloTable.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                soloTableKeyPressed(evt);
            }
        });
        soloTableScrollPane.setViewportView(soloTable);
        soloTable.getColumnModel().getSelectionModel().setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.gridwidth = 5;
        gridBagConstraints.ipadx = 600;
        gridBagConstraints.ipady = -100;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.weightx = 0.8;
        gridBagConstraints.weighty = 0.3;
        gridBagConstraints.insets = new java.awt.Insets(18, 35, 10, 0);
        getContentPane().add(soloTableScrollPane, gridBagConstraints);

        themeListScrollPane.setMaximumSize(new java.awt.Dimension(0, 0));
        themeListScrollPane.setMinimumSize(new java.awt.Dimension(0, 0));
        themeListScrollPane.setPreferredSize(new java.awt.Dimension(100, 100));

        themeList.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        themeList.setModel(themeListModel);
        themeList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        themeList.setLayoutOrientation(javax.swing.JList.VERTICAL_WRAP);
        themeList.setPreferredSize(null);
        themeList.setVisibleRowCount(30);
        themeList.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                themeListClicked(evt);
            }
        });
        themeList.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                themeListKeyPressed(evt);
            }
        });
        themeListScrollPane.setViewportView(themeList);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 5;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.ipadx = 250;
        gridBagConstraints.ipady = 290;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 0.3;
        gridBagConstraints.insets = new java.awt.Insets(9, 0, 5, 45);
        getContentPane().add(themeListScrollPane, gridBagConstraints);

        themeUsageScrollPane.setMinimumSize(new java.awt.Dimension(300, 100));

        themeUsageTextArea.setColumns(20);
        themeUsageTextArea.setRows(70);
        themeUsageScrollPane.setViewportView(themeUsageTextArea);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.gridheight = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 0.6;
        gridBagConstraints.weighty = 0.3;
        gridBagConstraints.insets = new java.awt.Insets(0, 10, 5, 0);
        getContentPane().add(themeUsageScrollPane, gridBagConstraints);

        ThemesLabel.setFont(new java.awt.Font("Lucida Grande", 1, 13)); // NOI18N
        ThemesLabel.setText("Themes");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 5;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.ipady = 5;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(23, 78, 0, 0);
        getContentPane().add(ThemesLabel, gridBagConstraints);

        generateSolo.setLabel("Generate Solo");
        generateSolo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                generateSoloActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(23, 35, 0, 0);
        getContentPane().add(generateSolo, gridBagConstraints);

        generateTheme.setLabel("Generate Theme");
        generateTheme.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                generateThemeActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(23, 35, 0, 0);
        getContentPane().add(generateTheme, gridBagConstraints);

        currentSelection.setLabel("Use Current Selection in Leadsheet Window as Theme");
        currentSelection.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                currentSelectionActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(10, 35, 0, 0);
        getContentPane().add(currentSelection, gridBagConstraints);

        playSolo.setLabel("Play Solo");
        playSolo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                playSoloActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 5;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(10, 35, 0, 0);
        getContentPane().add(playSolo, gridBagConstraints);

        stopPlaying.setLabel("Stop Playing");
        stopPlaying.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                stopPlayingActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 6;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(10, 35, 0, 0);
        getContentPane().add(stopPlaying, gridBagConstraints);

        SoloGeneratorTitle.setFont(new java.awt.Font("Lucida Grande", 1, 36)); // NOI18N
        SoloGeneratorTitle.setMaximumSize(new java.awt.Dimension(327, 327));
        SoloGeneratorTitle.setText("Theme Weaver");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 6;
        gridBagConstraints.ipady = -5;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(10, 0, 0, 0);
        getContentPane().add(SoloGeneratorTitle, gridBagConstraints);

        Reset.setText("Reset");
        Reset.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ResetActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 5;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.ipadx = 32;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(10, 15, 0, 0);
        getContentPane().add(Reset, gridBagConstraints);

        themeIntervalTextField.setText("8");
        themeIntervalTextField.setMaximumSize(new java.awt.Dimension(50, 2147483647));
        themeIntervalTextField.setMinimumSize(new java.awt.Dimension(50, 28));
        themeIntervalTextField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                themeIntervalTextFieldActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        getContentPane().add(themeIntervalTextField, gridBagConstraints);

        themeIntervalLabel.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        themeIntervalLabel.setText("Theme Use Interval");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.ipadx = 5;
        getContentPane().add(themeIntervalLabel, gridBagConstraints);

        noThemeProbTextField.setText("0.5");
        noThemeProbTextField.setMaximumSize(new java.awt.Dimension(50, 2147483647));
        noThemeProbTextField.setMinimumSize(new java.awt.Dimension(50, 28));
        noThemeProbTextField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                noThemeProbTextFieldActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        getContentPane().add(noThemeProbTextField, gridBagConstraints);

        noThemeProbLabel.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        noThemeProbLabel.setText("No-Theme Prob.");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.ipadx = 5;
        getContentPane().add(noThemeProbLabel, gridBagConstraints);

        fileMenu.setText("File"); // NOI18N
        fileMenu.setMaximumSize(new java.awt.Dimension(50, 40));
        fileMenu.setPreferredSize(new java.awt.Dimension(50, 21));

        exitMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Q, java.awt.event.InputEvent.CTRL_MASK));
        exitMenuItem.setText("Close this window."); // NOI18N
        exitMenuItem.setToolTipText("Closes this window."); // NOI18N
        exitMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitMenuItemexitMIhandler(evt);
            }
        });
        fileMenu.add(exitMenuItem);

        roadmapMenuBar.add(fileMenu);

        windowMenu.setMnemonic('W');
        windowMenu.setText("Window"); // NOI18N
        windowMenu.addMenuListener(new javax.swing.event.MenuListener() {
            public void menuSelected(javax.swing.event.MenuEvent evt) {
                windowMenuMenuSelected(evt);
            }
            public void menuDeselected(javax.swing.event.MenuEvent evt) {
            }
            public void menuCanceled(javax.swing.event.MenuEvent evt) {
            }
        });

        closeWindowMI.setMnemonic('C');
        closeWindowMI.setText("Close Window"); // NOI18N
        closeWindowMI.setToolTipText("Closes the current window (exits program if there are no other windows)"); // NOI18N
        closeWindowMI.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                closeWindowMIActionPerformed(evt);
            }
        });
        windowMenu.add(closeWindowMI);

        cascadeMI.setMnemonic('A');
        cascadeMI.setText("Cascade Windows"); // NOI18N
        cascadeMI.setToolTipText("Rearrange windows into a cascade.\n"); // NOI18N
        cascadeMI.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cascadeMIActionPerformed(evt);
            }
        });
        windowMenu.add(cascadeMI);
        windowMenu.add(jSeparator5);
        windowMenu.add(windowMenuSeparator);

        roadmapMenuBar.add(windowMenu);

        setJMenuBar(roadmapMenuBar);

        pack();
    }// </editor-fold>//GEN-END:initComponents

public void stopPlaying()
  {
  notate.stopPlaying();
  }
private void playSelection()
    {
    notate.getCurrentStave().playSelection(false, notate.getLoopCount(), PlayScoreCommand.USEDRUMS, "LickGenFrame");
    }
    private void soloTableComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_soloTableComponentShown
        // TODO add your handling code here:
    }//GEN-LAST:event_soloTableComponentShown

    private void generateThemeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_generateThemeActionPerformed
    
       generateTheme();
     
    }//GEN-LAST:event_generateThemeActionPerformed

    private void generateSoloActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_generateSoloActionPerformed

        int themeUsesize = 0; // set size of the input themeUses to 0
        
        for (int i = 0; i < soloTable.getRowCount(); i++) { //loop through table
            if (getValueAt(i, THEME_COLUMN) != null) { 
                //for every theme entered in the table
                themeUsesize += 1; //add one to the size
            }
        }
        System.out.println(themeUsesize);
        
        ArrayList<ThemeUse> themeUses = new ArrayList<ThemeUse>();
        //create an empty array of themeUses

        for (int i = 0; i < soloTable.getRowCount(); i++) { //loop through size of themeUses
            { 
                if ((getValueAt(i,THEME_COLUMN) == null)
                 && (getValueAt(i, LENGTH_COLUMN) != null)) {
                     enteredIncorrectly.setVisible(true); //show error message
                    break;
                }
                
               else if (getValueAt(i, THEME_COLUMN) != null) { 
                    if ((isDouble((String) getValueAt(i, 3)) == false) 
              || (isDouble((String) getValueAt(i, 4)) == false)
              || (isDouble((String) getValueAt(i, 5)) == false) 
              || (isDouble((String) getValueAt(i, 6)) == false)) {
                enteredIncorrectly.setVisible(true); //show error message 
                break;
            }
               else {
                ThemeUse use = new ThemeUse(new MelodyPart((String) getValueAt(i, THEME_COLUMN)));
                use.probUse = Double.valueOf((String) getValueAt(i, USE_COLUMN));
                use.probTranspose = Double.valueOf((String) getValueAt(i, TRANSPOSE_COLUMN));
                use.probInvert = Double.valueOf((String) getValueAt(i, INVERT_COLUMN));
                use.probReverse = Double.valueOf((String) getValueAt(i, REVERSE_COLUMN));
                themeUses.add(use); // add a new ThemeUse to the arraylist with respective elements
                if (getValueAt(i, NAME_COLUMN)!= null) {
                    use.theme.name = (String)getValueAt(i,NAME_COLUMN); 
                }
                
                if (getValueAt(i, NAME_COLUMN) == null) {
                    int x = 0;
                    for (int j = 0; j < soloTable.getRowCount(); j++) {
                        if ((getValueAt(j, NAME_COLUMN) == null) 
                         && (getValueAt(j, THEME_COLUMN) != null)
                         && (getValueAt(j, LENGTH_COLUMN) != null)) {
                            x += 1;
                        }
                    }
                    use.theme.name = "Theme " + x + " " ; 
                }
                
                System.out.println(use);
                }
              }
           }
        }
        generateSolo(themeUses, cm);
        playSelection();
        


    }//GEN-LAST:event_generateSoloActionPerformed

    private void currentSelectionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_currentSelectionActionPerformed
       // int index = soloTable.getSelectedRow();
        MelodyPart sel = notate.getCurrentStave().getDisplayPart().extract(
                notate.getCurrentSelectionStart(),
                notate.getCurrentSelectionEnd());
        Part.PartIterator i = sel.iterator();
        String theme = "";
        while (i.hasNext()) {
            theme += i.next().toLeadsheet() + " ";
        }
        for (int j = 0; j < soloTable.getRowCount(); j++) { 
         if ((getValueAt(j, NAME_COLUMN) == null) 
          && (getValueAt(j,THEME_COLUMN) == null) 
          && (getValueAt(j, LENGTH_COLUMN) == null)) 
         {
        setValueAt(theme, j, THEME_COLUMN);
        setValueAt(sel.getSize() / BEAT + "", j, LENGTH_COLUMN);
        
//        if (getValueAt(j, NAME_COLUMN) != null) {
           MelodyPart melody = new MelodyPart((String) getValueAt(j, THEME_COLUMN));
//            int themelength = melody.size() / BEAT;
//            setValueAt(themelength + "", j, LENGTH_COLUMN);
//            
            for (Map.Entry pair : allThemes.entrySet()) { //loop through all the entry sets of {Theme,name} in allThemes
                Theme ThemeKey = (Theme) pair.getKey(); //get the Theme of each entry
                
                if (melody.toString().equals(ThemeKey.melody.toString())) { 
                    //if the melody in allThemes is the name as the melody in the table
                    setValueAt(pair.getValue(), j, NAME_COLUMN); 
                    //set the name to the one that matches that theme
                } 
                else 
                {// if there is no matching theme in allThemes
                    setValueAt(null, j, NAME_COLUMN); //set the name to empty
                }
            }
            break;
        }
      }
    }//GEN-LAST:event_currentSelectionActionPerformed

    private void playSoloActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_playSoloActionPerformed
        playSelection();
        
    }//GEN-LAST:event_playSoloActionPerformed

    private void stopPlayingActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stopPlayingActionPerformed
        stopPlaying();
    }//GEN-LAST:event_stopPlayingActionPerformed

    private void soloTableKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_soloTableKeyPressed
        int index = soloTable.getSelectedRow();
        int col = soloTable.getSelectedColumn();
        if (evt.getKeyCode() == KeyEvent.VK_DELETE) {
          //  deleteCheck.setVisible(true);
          soloTableModel.removeRow(index);
          return;
        }

        if (evt.getKeyCode() == KeyEvent.VK_INSERT) {
            soloTableModel.addARow();
            return;
        }


        // When enter is pressed on this cell, keep the same cell selected
        // (This can be conditioned on column later if desired.)
        if (evt.getKeyCode() == KeyEvent.VK_ENTER) {
            //index = index <= 1 ? 0 : index-1;
            //soloTable.setRowSelectionInterval(index, index);
            
            if( col == THEME_COLUMN && getValueAt(index,THEME_COLUMN) != null )
              {
                System.out.println("Theme at row " + index + " entered");
                MelodyPart melody = new MelodyPart((String) getValueAt(index, THEME_COLUMN)); 
                int themeLengthBeats = melody.getSize()/BEAT;
                soloTable.setValueAt(themeLengthBeats + "", index, LENGTH_COLUMN);
              }
        }
 
          
        
    }//GEN-LAST:event_soloTableKeyPressed

    private void ResetActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ResetActionPerformed
        resetCheck.setVisible(true); 
        
    }//GEN-LAST:event_ResetActionPerformed

    private void soloTableMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_soloTableMouseClicked

    }//GEN-LAST:event_soloTableMouseClicked

    private void themeListClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_themeListClicked
        if (!evt.isShiftDown()) { 
        for (int i = 0; i < orderedThemes.size(); i++) { //loop through size of orderedThemes
            for (int j = 0; j < soloTable.getRowCount(); j++) {//loop through table
                
                if (themeList.isSelectedIndex(i) 
                   && (getValueAt(j, NAME_COLUMN) == null) 
                   && (getValueAt(j,THEME_COLUMN) == null) 
                   && (getValueAt(j, LENGTH_COLUMN) == null) 
                       )
                        {
                    //if a theme in the Themes scroll box is clicked and a theme cell is selected
                    String name = (String) themeList.getSelectedValue();
                    //set name equal to the one clicked in the scroll box
                    
                    for (Map.Entry pair : allThemes.entrySet()) { 
                        //loop through entries in allThemes
                        
                        if (name == pair.getValue()) 
                        { //if the name in the themeList is equal to the name in the entry
                            Theme theme = (Theme) pair.getKey(); 
                            //set theme equal to the corresponding theme in that entry
                            MelodyPart melody = theme.melody; //get the melody of the theme
                            Part.PartIterator k = melody.iterator(); //iterate over melody
                            String themestring = ""; //set theme as empty to start
                            
                            while (k.hasNext()) //while you can still iterate through the melody
                            {
                                Unit unit = k.next();
                                if (unit != null) //if next isn't empty
                                {
                                    themestring += unit.toLeadsheet() + " "; 
                                    //add it to the theme in leadsheet notation
                                }
                            }
                            
                            setValueAt(name, j, NAME_COLUMN); 
                            //paste in the name of theme to the table
                          //  setValueAt(theme.ThemeLength + "", j, LENGTH_COLUMN); 
                            setValueAt(melody.size() / BEAT + "", j, LENGTH_COLUMN);
                            //paste in the theme length
                            setValueAt(themestring, j, THEME_COLUMN); 
                            //paste in the theme in leadsheet notation

                            //in case the length is different than the one typed by the user 
                            int n = 0;
                            for (int x = 0; x < soloTable.getRowCount(); x++) { //loop through table
                                if (getValueAt(x, NAME_COLUMN) != null 
                                && ((((String) getValueAt(x, NAME_COLUMN)).equals(name))
                                || ((String) getValueAt(x, NAME_COLUMN)).equals(name + "-" + n))
                                && (x != j) 
                                && (((String) getValueAt(x, THEME_COLUMN)).equals(themestring))  
                                        //&& (!((String) getValueAt(x, 1)).equals(theme.ThemeLength + ""))
                                        ) {
                                    n += 1; //add one to n so if the same theme 
                                    //is already in the table it will be differentiated from it
                                    //if the names are the same, the rows are different,
                                    //the themes are the same, the lengths are different
                                    setValueAt(theme.ThemeLength + "", x, LENGTH_COLUMN); 
                                    //make the lengths the same 
                                    setValueAt(name + "-" + n,j,NAME_COLUMN);
                                    // System.out.println(theme.ThemeLength);
                                }
                            }
                        }
                    }
                   break;
                }
            }
          }   
        }
        
        if (evt.isShiftDown()) {
           for (int i = 0; i < orderedThemes.size(); i++) { //loop through all saved themes
                if (themeList.isSelectedIndex(i)) {
                    String name = (String) themeList.getSelectedValue();
                    Score score = new Score(name); 
                    //create empty score with name of theme selected
                    for (Map.Entry pair : allThemes.entrySet()) {
                        //loop through entries in allThemes

                        if (name == pair.getValue()) { //if the name in the themeList is equal to the name in the entry
                            Theme theme = (Theme) pair.getKey();
                            //set theme equal to the corresponding theme in that entry
                            MelodyPart melody = theme.melody; //get the melody of the theme
                            score.addPart(melody);
                            System.out.println(score);
                            PatternDisplay.playScore(notate, score, soloGenerator);
                        }
                    }
                }
            }  
        }
    }//GEN-LAST:event_themeListClicked

    private void OkButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_OkButtonActionPerformed
        if (orderedThemes.contains(nameField.getText())) 
        { //if the user enters a name that is already in orderedThemes
            nameErrorMessage.setVisible(true); //same error message pops up
        }
        
        else {
            for (int i = 0; i < soloTable.getRowCount(); i++) {// loop through table
                
                if (soloTable.isCellSelected(i, NAME_COLUMN)) 
                {  
                        setValueAt(nameField.getText(), i, NAME_COLUMN); 
                        //set the name in the table
                        String name = nameField.getText();
                        String melodyString = (String) getValueAt(i, THEME_COLUMN);
                        MelodyPart themeMelody = new MelodyPart(melodyString);
                        Theme theme = Theme.makeTheme(name, themeMelody);
                        addTheme(theme); 
                        saveRules(fileName);
                        //add the theme
                  }
                
            }
        }
        nameErrorMessage.setVisible(false); //close the error window
    }//GEN-LAST:event_OkButtonActionPerformed

    private void CancelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CancelButtonActionPerformed
     nameErrorMessage.setVisible(false);   
        
    }//GEN-LAST:event_CancelButtonActionPerformed

    private void cellOkbuttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cellOkbuttonActionPerformed
       enteredIncorrectly.setVisible(false);
    }//GEN-LAST:event_cellOkbuttonActionPerformed

    private void nameFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nameFieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_nameFieldActionPerformed

    private void YesButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_YesButtonActionPerformed
        soloTableModel.tableReset();
        resetCheck.setVisible(false);
    }//GEN-LAST:event_YesButtonActionPerformed

    private void NoButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_NoButtonActionPerformed
        resetCheck.setVisible(false);
    }//GEN-LAST:event_NoButtonActionPerformed

    private void YesOverwriteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_YesOverwriteActionPerformed
        MelodyPart theme = null; 
        for (int j = 0; j < soloTable.getRowCount(); j++) { 

            if (soloTable.isCellSelected(j,NAME_COLUMN)) {
                theme = (MelodyPart)getValueAt(j,THEME_COLUMN);
            }
            
        for (Map.Entry pair : allThemes.entrySet()) {
            Theme KeyTheme = (Theme)pair.getKey();
            
                 if (theme == KeyTheme.melody) {
                     allThemes.put(KeyTheme, nameField.getText());
                    ensureThemeArray(); 
                    setValueAt(nameField.getText(),j,NAME_COLUMN);
                  }
                 
            }
        }

    }//GEN-LAST:event_YesOverwriteActionPerformed

    private void NoOverwriteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_NoOverwriteActionPerformed
        AlreadyNamed.setVisible(false);
        MelodyPart theme = null;
        
        for (int j = 0; j < soloTable.getRowCount(); j++) { 
            
            if (soloTable.isCellSelected(j,NAME_COLUMN)) {
                theme = (MelodyPart)getValueAt(j,THEME_COLUMN);
            }
            
        for (Map.Entry pair : allThemes.entrySet()) {
            Theme KeyTheme = (Theme)pair.getKey();
            
                 if (theme == KeyTheme.melody) {
                   String name =  (String)pair.getValue();
                   setValueAt(name, j, NAME_COLUMN);
                  }
                 
            }
        }
    }//GEN-LAST:event_NoOverwriteActionPerformed

    private void OkdeleteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_OkdeleteActionPerformed
       int index = soloTable.getSelectedRow();
       soloTableModel.removeRow(index);
       
       for (int i = 0; i < soloTable.getColumnCount(); i++){
           
           if (soloTable.isCellSelected(index,i)) {
               System.out.println("delete");
               setValueAt(null,index,i);
           }
           
       }
      //  soloTableModel.removeRow(index);
       deleteCheck.setVisible(false); 
    }//GEN-LAST:event_OkdeleteActionPerformed

    private void NodeleteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_NodeleteActionPerformed
       deleteCheck.setVisible(false);
    }//GEN-LAST:event_NodeleteActionPerformed

    private void themeListKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_themeListKeyPressed
//   if (evt.getKeyCode() == KeyEvent.VK_ENTER) {
//        for (int i = 0; i < orderedThemes.size(); i++) { //loop through size of orderedThemes
//            for (int j = 0; j < soloTable.getRowCount(); j++) {//loop through table
//                
//                if (themeList.isSelectedIndex(i) 
//                   && (getValueAt(j, NAME_COLUMN) == null) 
//                   && (getValueAt(j,THEME_COLUMN) == null) 
//                   && (getValueAt(j, LENGTH_COLUMN) == null) 
//                       )
//                        {
//                    //if a theme in the Themes scroll box is clicked and a theme cell is selected
//                    String name = (String) themeList.getSelectedValue();
//                    //set name equal to the one clicked in the scroll box
//                    
//                    for (Map.Entry pair : allThemes.entrySet()) { 
//                        //loop through entries in allThemes
//                        
//                        if (name == pair.getValue()) 
//                        { //if the name in the themeList is equal to the name in the entry
//                            Theme theme = (Theme) pair.getKey(); 
//                            //set theme equal to the corresponding theme in that entry
//                            MelodyPart melody = theme.melody; //get the melody of the theme
//                            Part.PartIterator k = melody.iterator(); //iterate over melody
//                            String themestring = ""; //set theme as empty to start
//                            
//                            while (k.hasNext()) //while you can still iterate through the melody
//                            {
//                                Unit unit = k.next();
//                                if (unit != null) //if next isn't empty
//                                {
//                                    themestring += unit.toLeadsheet() + " "; 
//                                    //add it to the theme in leadsheet notation
//                                }
//                            }
//                            
//                            setValueAt(name, j, NAME_COLUMN); 
//                            //paste in the name of theme to the table
//                          //  setValueAt(theme.ThemeLength + "", j, LENGTH_COLUMN); 
//                            setValueAt(melody.size() / BEAT + "", j, LENGTH_COLUMN);
//                            //paste in the theme length
//                            setValueAt(themestring, j, THEME_COLUMN); 
//                            //paste in the theme in leadsheet notation
//
//                            //in case the length is different than the one typed by the user 
//                            int n = 0;
//                            for (int x = 0; x < soloTable.getRowCount(); x++) { //loop through table
//                                if (getValueAt(x, NAME_COLUMN) != null 
//                                && ((((String) getValueAt(x, NAME_COLUMN)).equals(name))
//                                || ((String) getValueAt(x, NAME_COLUMN)).equals(name + "-" + n))
//                                && (x != j) 
//                                && (((String) getValueAt(x, THEME_COLUMN)).equals(themestring))  
//                                        //&& (!((String) getValueAt(x, 1)).equals(theme.ThemeLength + ""))
//                                        ) {
//                                    n += 1; //add one to n so if the same theme 
//                                    //is already in the table it will be differentiated from it
//                                    //if the names are the same, the rows are different,
//                                    //the themes are the same, the lengths are different
//                                    setValueAt(theme.ThemeLength + "", x, LENGTH_COLUMN); 
//                                    //make the lengths the same 
//                                    setValueAt(name + "-" + n,j,NAME_COLUMN);
//                                    // System.out.println(theme.ThemeLength);
//                                }
//                            }
//                        }
//                    }
//                   break;
//                }
//            }
//        }
//      }
    }//GEN-LAST:event_themeListKeyPressed

    private void formKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed
        
    }//GEN-LAST:event_formKeyPressed

    private void nameFieldKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_nameFieldKeyPressed
        if (evt.getKeyCode() == KeyEvent.VK_ENTER) {
             System.out.println("name");
             if (orderedThemes.contains(nameField.getText())) 
        { //if the user enters a name that is already in orderedThemes
            nameErrorMessage.setVisible(true); //same error message pops up
        }
        
        else {
            for (int i = 0; i < soloTable.getRowCount(); i++) {// loop through table
                
                if (soloTable.isCellSelected(i, NAME_COLUMN)) 
                {  
                        setValueAt(nameField.getText(), i, NAME_COLUMN); 
                        //set the name in the table
                        String name = nameField.getText();
                        String melodyString = (String) getValueAt(i, THEME_COLUMN);
                        MelodyPart themeMelody = new MelodyPart(melodyString);
                        Theme theme = Theme.makeTheme(name, themeMelody);
                        addTheme(theme); 
                        saveRules(fileName);
                        //add the theme
                  }
                
            }
        }
        nameErrorMessage.setVisible(false); //close the error window
         }
                                  

    }//GEN-LAST:event_nameFieldKeyPressed

    private void cellOkbuttonKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_cellOkbuttonKeyPressed
      enteredIncorrectly.setVisible(false);
    }//GEN-LAST:event_cellOkbuttonKeyPressed

    private void YesButtonKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_YesButtonKeyPressed
        soloTableModel.tableReset();
        resetCheck.setVisible(false);
    }//GEN-LAST:event_YesButtonKeyPressed

    private void windowClosed(java.awt.event.WindowEvent evt)//GEN-FIRST:event_windowClosed
    {//GEN-HEADEREND:event_windowClosed
    closeWindow();
    }//GEN-LAST:event_windowClosed

    private void exitMenuItemexitMIhandler(java.awt.event.ActionEvent evt)//GEN-FIRST:event_exitMenuItemexitMIhandler
    {//GEN-HEADEREND:event_exitMenuItemexitMIhandler
        closeWindow();
    }//GEN-LAST:event_exitMenuItemexitMIhandler

    private void closeWindowMIActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_closeWindowMIActionPerformed
    {//GEN-HEADEREND:event_closeWindowMIActionPerformed
        closeWindow();
    }//GEN-LAST:event_closeWindowMIActionPerformed

    private void closeWindow()
      {
        WindowRegistry.unregisterWindow(this);
        setVisible(false); 
      }
    
    private void cascadeMIActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_cascadeMIActionPerformed
    {//GEN-HEADEREND:event_cascadeMIActionPerformed
        WindowRegistry.cascadeWindows(this);
    }//GEN-LAST:event_cascadeMIActionPerformed

    private void windowMenuMenuSelected(javax.swing.event.MenuEvent evt)//GEN-FIRST:event_windowMenuMenuSelected
    {//GEN-HEADEREND:event_windowMenuMenuSelected
        windowMenu.removeAll();

        windowMenu.add(closeWindowMI);

        windowMenu.add(cascadeMI);

        for(WindowMenuItem w : WindowRegistry.getWindows())
        windowMenu.add(w.getMI(this));       // these are static, and calling getMI updates the name on them too in case the window title changed

        windowMenu.repaint();
    }//GEN-LAST:event_windowMenuMenuSelected

    private void themeIntervalTextFieldActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_themeIntervalTextFieldActionPerformed
    {//GEN-HEADEREND:event_themeIntervalTextFieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_themeIntervalTextFieldActionPerformed

    private void noThemeProbTextFieldActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_noThemeProbTextFieldActionPerformed
    {//GEN-HEADEREND:event_noThemeProbTextFieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_noThemeProbTextFieldActionPerformed


 protected SoloGenerator soloGenerator;
 private int themeLength = 8;

private Notate notate;

private int minPitch = 60;

private int maxPitch = 82;

private int minInterval = 0;

private int maxInterval = 6;

private double leapProb = 0.2;

private boolean avoidRepeats = true;

private LickGen lickgen;

private CommandManager cm;

static final int NAME_COLUMN = 0;

static final int LENGTH_COLUMN = 1;

static final int THEME_COLUMN = 2;

static final int USE_COLUMN = 3;

static final int TRANSPOSE_COLUMN = 4;

static final int INVERT_COLUMN = 5;

static final int REVERSE_COLUMN = 6; 

static final int ROW_COUNT = 20;

double probnoTheme;
    
public ThemeListModel themeListModel = new ThemeListModel();

  
private SoloGeneratorTableModel soloTableModel = new SoloGeneratorTableModel (
        new Object [][] {
                {null, null, null, "1", "0", "0", "0"},
                {null, null, null, "1", "0", "0", "0"},
                {null, null, null, "1", "0", "0", "0"},
                {null, null, null, "1", "0", "0", "0"},
                {null, null, null, "1", "0", "0", "0"},
                {null, null, null, "1", "0", "0", "0"},
                {null, null, null, "1", "0", "0", "0"},
                {null, null, null, "1", "0", "0", "0"},
                {null, null, null, "1", "0", "0", "0"},
                {null, null, null, "1", "0", "0", "0"},
                {null, null, null, "1", "0", "0", "0"},
                {null, null, null, "1", "0", "0", "0"},
                {null, null, null, "1", "0", "0", "0"},
                {null, null, null, "1", "0", "0", "0"},
                {null, null, null, "1", "0", "0", "0"},
                {null, null, null, "1", "0", "0", "0"},
                {null, null, null, "1", "0", "0", "0"},
                {null, null, null, "1", "0", "0", "0"},
                {null, null, null, "1", "0", "0", "0"},
                {null, null, null, "1", "0", "0", "0"}
            },
            new String [] {
                "Name", "Length", "Theme", "Use", "Transpose", "Invert", "Reverse"
            } ) ;
         
                  
   

public class SoloGeneratorTableModel extends DefaultTableModel 
{
 private static final int columnCount = 7;

    boolean[] canEdit = new boolean [] {
              //name, theme, length, use, transpose, invert, reverse
                true, true , true, true, true, true, true
            };
    
    int [] columnWidths = new int [] {
                55 , 20  , 155   , 7 , 20  , 8,  15
            };
    int [] columnAdjustment = {
                DefaultTableCellRenderer.LEFT, 
                DefaultTableCellRenderer.LEFT, 
                DefaultTableCellRenderer.LEFT, 
                DefaultTableCellRenderer.RIGHT,
                DefaultTableCellRenderer.RIGHT, 
                DefaultTableCellRenderer.RIGHT, 
                DefaultTableCellRenderer.RIGHT, 
            };

    public SoloGeneratorTableModel(Object [][] myTable, String [] columnHeaders)
    {
        super(myTable, columnHeaders);
    }

    public int getColumnWidths(int index) {
        return columnWidths[index];
    }
//
    public int getColumnAdjustments(int index) {
        return columnAdjustment[index];
    }

    @Override
    public boolean isCellEditable(int rowIndex, int columnIndex) {
        return canEdit [columnIndex];
    }

    public void tableRefresh() {
        for (int i = 0; i < soloTable.getRowCount(); i ++ ) {
         //   for (int j = 0; j < soloTable.getColumnCount(); j++) {
             if (soloTable.getRowCount() != ROW_COUNT) {
                    for (int x = 0; x < ROW_COUNT - soloTable.getRowCount(); x ++)
                    soloTableModel.addARow();
                }
                soloTable.setValueAt(null, i, NAME_COLUMN);
                soloTable.setValueAt(null,i, LENGTH_COLUMN);
                soloTable.setValueAt(null,i,THEME_COLUMN); 
                soloTable.setValueAt("1",i,USE_COLUMN);
                soloTable.setValueAt("0",i,TRANSPOSE_COLUMN);
                soloTable.setValueAt("0",i,INVERT_COLUMN);
                soloTable.setValueAt("0",i, REVERSE_COLUMN);
                
               
                
         //   }
        }
        fireTableDataChanged();
    }
     

    public void tableReset() {

       tableRefresh();
     }


   @Override
    public int getColumnCount() {
        return columnCount;
    }

    public void addARow()
    {
        soloTableModel.insertRow(0, new Object [] {null,
                                                    null,
                                                    null,
                                                    null,
                                                    null,
                                                    null,
                                                    null}
              );
    }
    
  
//
  @Override
   public Class getColumnClass(int column)
  {
       switch(column)
       {
           case 0:
              return Object.class;
       }
       return Object.class;
  }
  
 
  @Override
  public void setValueAt(Object value, int row, int col) {
      super.setValueAt(value,row,col);
      if(themeList.hasFocus())
      {
          return;
      }
      
      switch( col )
      {
          case NAME_COLUMN:
              if (soloTable.isCellSelected(row, NAME_COLUMN)
            && (getValueAt(row, THEME_COLUMN) != null) 
            && (getValueAt(row, NAME_COLUMN) != null) 
           // && (getValueAt(i,NAME_COLUMN) != " ")
                    )
            { //if name cell is selected, it's not empty and the theme isn't empty
                namingSaving(row, col, row);
                return;
            }
              break;
          case LENGTH_COLUMN:
            break; 
          case THEME_COLUMN:
            if ((soloTable.isCellSelected(row, THEME_COLUMN)) 
            && (getValueAt(row, THEME_COLUMN) != null)
            && (getValueAt(row,LENGTH_COLUMN) != null)) {
                updateLength(row, col, row);
                return;
            }
            //for typing in own theme
            if ((soloTable.isCellSelected(row, THEME_COLUMN)) 
            && (getValueAt(row, THEME_COLUMN) != null)
            && (getValueAt(row,LENGTH_COLUMN) == null)
                    )        
            { 
                addLength(row, col, row);
                return;
            }
           break;
      }
//      if(!themeList.hasFocus())
//        enteringValue(row, col);
//      
  }
}
  
  public void setValueAt(Object value, int row, int col) {
      soloTable.setValueAt(value,row,col);
      if(!themeList.hasFocus())
        enteringValue(row, col);
  }

    public Object getValueAt(int row, int col) {
      return soloTable.getValueAt(row,col);
  }
 
    public void updateLength(int row, int col, int i) {
               MelodyPart melody = new MelodyPart((String) getValueAt(i, THEME_COLUMN)); 
            
               int themelength = melody.size() / BEAT;
               
              if (themelength != getValueAt(i,LENGTH_COLUMN)){
                  soloTable.setValueAt(themelength + "", i, LENGTH_COLUMN); 
                  for (Map.Entry pair : allThemes.entrySet()) { 
                        //loop through all the entry sets of {Theme,name} in allThemes
                        Theme ThemeKey = (Theme) pair.getKey(); 
                        //get the Theme of each entry

                        if (melody.toString().equals(ThemeKey.melody.toString())) 
                        { //if the melody in allThemes is the name as the melody in the table
                            soloTable.setValueAt(pair.getValue(), i, NAME_COLUMN);
                            //set the name to the one that matches that theme
                        } 
                        
                        else 
                        {// if there is no matching theme in allThemes
                            soloTable.setValueAt(null, i, NAME_COLUMN); 
                            //set the name to empty
                        }
                    }
                  
              }
                  
            }
    
    public void addLength(int row, int col, int i) {
           MelodyPart melody = new MelodyPart((String) getValueAt(i, THEME_COLUMN)); 
            
            int themelength = melody.size() / BEAT;
            
             if ((getValueAt(i, NAME_COLUMN) == null))
                { //if there is no name
                    soloTable.setValueAt(themelength + "", i, LENGTH_COLUMN); 
                    //set themelength in the table
                  } 
//                
                else { //if there is already a name
                    soloTable.setValueAt(themelength + "", i, LENGTH_COLUMN);
                    for (Map.Entry pair : allThemes.entrySet()) { 
                        //loop through all the entry sets of {Theme,name} in allThemes
                        Theme ThemeKey = (Theme) pair.getKey(); 
                        //get the Theme of each entry

                        if (melody.toString().equals(ThemeKey.melody.toString())) 
                        { //if the melody in allThemes is the name as the melody in the table
                            soloTable.setValueAt(pair.getValue(), i, NAME_COLUMN);
                            //set the name to the one that matches that theme
                        } 
                        
                        else 
                        {// if there is no matching theme in allThemes
                            soloTable.setValueAt(null, i, NAME_COLUMN); 
                            //set the name to empty
                        }
                    }
                }
    }
    
    public void namingSaving(int row, int col, int i) {
          MelodyPart melody = new MelodyPart((String) getValueAt(i, THEME_COLUMN)); 
            
            int themelength = melody.size() / BEAT;
            
                System.out.println(melody);
                String name = (String) getValueAt(i, NAME_COLUMN);
                System.out.println(name);
                String themestring = (String) getValueAt(i, THEME_COLUMN);
                MelodyPart themeMelody = new MelodyPart(themestring);
                Theme theme = Theme.makeTheme(name,themeMelody);
                
                if (orderedThemes.contains(name))
                { //if the user types a name already in the list
                    System.out.println("contains");
                    nameErrorMessage.setVisible(true); 
                    //give name error message to rename the theme
                } 
                
                else {
                    for (Map.Entry pair : allThemes.entrySet().toArray(new Map.Entry[0])) {
                        // loop through the entries of allThemes
                        Theme ThemeKey = (Theme) pair.getKey(); 
                        //get the Theme of each entry
                        System.out.println(ThemeKey.melody);

                        if (melody.toString().equals(ThemeKey.melody.toString())) 
                        { //if the melody of the Theme is the same as the one in the table
//                     System.out.println("themeproblem");
//                     AlreadyNamed.setVisible(true); 
                            System.out.println("same");
                            addTheme(theme); //add the theme to the list
                            saveRules(fileName);
                            //   soloTable.setValueAt(pair.getValue(), i, 0); 
                            //set the name to the one in the list(what is was before user changed it)
                            for (int k = 0; k < soloTable.getRowCount(); k++) { //loop through table

                                if ((getValueAt(k, NAME_COLUMN) == null)
                                && (getValueAt(k, LENGTH_COLUMN) == null)
                                && (getValueAt(k, THEME_COLUMN) == null)) 
                                { //if there is a null row (besides probabilities)
                                    soloTable.setValueAt(name, k, NAME_COLUMN); 
                                    //set name to one user typed
                                    soloTable.setValueAt(themestring, k, THEME_COLUMN);
                                    //set theme to the one 

                                    if (!(row == i && col == LENGTH_COLUMN)) {
                                        soloTable.setValueAt(getValueAt(i, LENGTH_COLUMN), k, LENGTH_COLUMN); 
                                        //set the themelength
                                    }
                                    break;
                                }
                            }
                            
                            soloTable.setValueAt(pair.getValue(), i, NAME_COLUMN); 
                            //set the name to the one in the list(what is was before user changed it)
                            nameErrorMessage.setVisible(false);
                            break;
                        }
                        
                        else { //if there is no melody that matches the one in the table
                            System.out.println("Adding");
                            addTheme(theme);
                            saveRules(fileName);
                        }
                    }
                   


                }
    }
    
    public void enteringValue(int row, int col) {
        for (int i = 0; i < soloTable.getRowCount(); i++) { //loop through table
            //updating length
            if ((soloTable.isCellSelected(i, THEME_COLUMN)) 
            && (getValueAt(i, THEME_COLUMN) != null)
            && (getValueAt(i,LENGTH_COLUMN) != null)) {
                updateLength(row, col, i);
                return;
            }
            //for typing in own theme
            if ((soloTable.isCellSelected(i, THEME_COLUMN)) 
            && (getValueAt(i, THEME_COLUMN) != null)
            && (getValueAt(i,LENGTH_COLUMN) == null)
                    )        
            { 
                addLength(row, col, i);
                return;
            }
            
            //naming and saving
            if (soloTable.isCellSelected(i, NAME_COLUMN)
            && (getValueAt(i, THEME_COLUMN) != null) 
            && (getValueAt(i, NAME_COLUMN) != null) 
           // && (getValueAt(i,NAME_COLUMN) != " ")
                    )
            { //if name cell is selected, it's not empty and the theme isn't empty
                System.out.println("lala");
                namingSaving(row, col, i);
                return;
            }
        }
        
        System.out.println(orderedThemes);

    }
  


private static LinkedHashMap<Theme, String> allThemes = new LinkedHashMap<Theme, String>();
 private static ArrayList<String> orderedThemes = null;
 int allThemesIndex = allThemes.size() - 1;
  
  public static int numberOfThemes()
    {
      ensureThemeArray();
      return orderedThemes.size(); 
    }
  
// public static Theme getTheme(String name)
//    {
//      return allThemes.get(name);
//    }
  
  public static void setTheme(String name, Theme theme)
    {
      allThemes.put(theme, name);
    }
  
    public static String getNth(int index)
      {
        ensureThemeArray();
        return orderedThemes.get(index);
      }
    
    private static void ensureThemeArray()
      {
            {
                
           orderedThemes = new ArrayList<String>(allThemes.values());
            }       
      }
public void addTheme(Theme theme)
    {
        ensureThemeArray();
        int orderedThemesIndex = orderedThemes.size() - 1;
        System.out.println(allThemes);
        System.out.println(orderedThemes);
        String name = theme.name;
        for (int i = 0; i < soloTable.getRowCount(); i++) {
            //  Theme theme = allThemes.get(themestring);
            if ( (!orderedThemes.contains(name))) {
                orderedThemes.add(name);
                allThemes.put(theme, name);
            }

            themeListModel.reset();
            orderedThemesIndex = orderedThemes.indexOf(theme);
            //  allThemesIndex = allThemes.indexOf(theme);
        }
        System.out.println(orderedThemes);
        System.out.println(allThemes);
        System.out.println("here");
       //saveRules(fileName);
    }


File fileName = ImproVisor.getThemesFile();

public void saveRules(File file)
  {
   try
    {
    java.io.PrintStream out = new PrintStream(new FileOutputStream(file)); 
  //  .... iterate over your Themes structure calling showForm(out) on each
     for (Map.Entry pair : allThemes.entrySet()) {
            Theme key = (Theme)pair.getKey();
            key.showForm(System.out);
            key.showForm(out);
    }
    }
  catch( IOException e )
    {
    ErrorLog.log(ErrorLog.SEVERE, "Saving themes in file failed: " + file);
    }
  } 

private void loadFromFile(File file) {
    java.io.FileInputStream themeStream;

        try {
            themeStream = new FileInputStream(file);
        } catch(Exception e) {
            ErrorLog.log(ErrorLog.SEVERE, "Loading themes in file failed: " + file); 
            return;
        }

        Tokenizer in = new Tokenizer(themeStream);
        Object ob;

        while( (ob = in.nextSexp()) != Tokenizer.eof ) {
            if( ob instanceof Polylist)  {
                Polylist themePoly = (Polylist)ob;
                //ExpandCommand(themePoly);
                Theme theme = new Theme(themePoly);
            //     ... put the Theme into your structure ...
                addTheme(theme);
                System.out.println("adding " + theme);
                System.out.println(orderedThemes);
            }
        
        }
        

}

public class ThemeListModel
    extends AbstractListModel
{
  
public int getSize()
  {
   int number = numberOfThemes();
    
    return number;
      
  }

public Object getElementAt(int index)
  {
    //System.out.println("requesting " + index + " of " + getSize() + " " + Style.getNth(index));
    return getNth(index);
  }

public void reset()
  {
    //System.out.println("reset");
    fireContentsChanged(this, 0, getSize());
  }

public void adjust()
  {
    //System.out.println("adjust");
    fireIntervalAdded(this, 0, getSize());
  }

}

public static boolean isInteger(String s) {
    try {
        Integer.parseInt(s);
    }
    catch(NumberFormatException e) {
        return false;
    }
    return true;
}

public static boolean isDouble(String s) {
    try {
        Double.parseDouble(s);
    }
    catch (NumberFormatException e) {
        return false;
    }
    return true;
}
  
// \
public MelodyPart fillMelody(int beatValue,
                             Polylist rhythmString, 
                             ChordPart chordProg,
                             int start)
  {
    MelodyPart result = lickgen.fillMelody(minPitch, 
                                           maxPitch, 
                                           minInterval, 
                                           maxInterval,
                                           beatValue, 
                                           leapProb, 
                                           rhythmString, 
                                           chordProg,
                                           start, 
                                           avoidRepeats);

    return result;
  } 

//in progress
public void ExpandCommand(Polylist list) {
     Polylist melodyList = (Polylist)list.last(); //get polylist of the melody
         Polylist melodyNotes = (Polylist)melodyList.rest(); //get the notes in a polylist
         
         PolylistEnum melodyElements = melodyNotes.elements(); //get the notes as elements
         
         //To get the notes of the theme in a string:
         String melodyString = "";
         while (melodyElements.hasMoreElements()) { //while there are more notes
           Object current =  melodyElements.nextElement();//get next note
             String currentString = current.toString(); //convert it to String
             if (currentString.length() == 2) {
             int intValue = Integer.parseInt(currentString.charAt(1) + "");
             int newValue = intValue/2;
            System.out.println(newValue);
            System.out.println(currentString.charAt(0));
             String newNote = currentString.charAt(0) + newValue + "";
            //  System.out.println(newNote);
             melodyString += newNote + " "; //add the note to the melodyString
             }
             else if (currentString.length() == 3) {
                 int newValue = currentString.charAt(2)/2;
                 String newNote = currentString.charAt(0) + currentString.charAt(1) + newValue + "";
                 melodyString += newNote + " "; //add the note to the melodyString
             }
             else {
                 int newValue = currentString.charAt(3)/2;
                 String newNote = currentString.charAt(0) + currentString.charAt(1) + currentString.charAt(2) + newValue + "";
                 melodyString += newNote + " "; //add the note to the melodyString
                 
             }
            // System.out.println(melodyString);
         }  
         System.out.println(melodyString);
         MelodyPart melody = new MelodyPart(melodyString); //create a MelodyPart of the string
}

    public MelodyPart generateTheme() { 
        for (int x = 0; x < soloTable.getRowCount(); x++) { //loop through the rows of the table
            if ((getValueAt(x, LENGTH_COLUMN) != null)
           &&  (!isInteger((String) getValueAt(x, LENGTH_COLUMN)))) {
                System.out.println("error");
                enteredIncorrectly.setVisible(true);
              } 
            else {
                
               if  (((soloTable.isCellSelected(x, LENGTH_COLUMN)) 
                && (getValueAt(x, LENGTH_COLUMN) != null))
                || ((getValueAt(x, LENGTH_COLUMN) != null) 
                && (getValueAt(x,THEME_COLUMN) == null))){
                    //if the theme length cell is selected and has something in it 
                   // or if there is something in a length cell and has no theme
                    int Length = notate.intFromStringInRange((String) getValueAt(x, LENGTH_COLUMN), 0, 100, themeLength); 
                    //get length from tablek
                    themeLength = BEAT * Length;
                    Polylist rhythm = lickgen.generateRhythmFromGrammar(0, themeLength); 
                    //get rhythm for theme from grammar

                    MelodyPart lick = fillMelody(BEAT, rhythm, notate.getChordProg(), 0); 
                    //get the melody of the theme

                    Part.PartIterator i = lick.iterator(); //iterate over lick
                    String theme = ""; //set theme as empty to start
                    
                    while (i.hasNext()) //while you can still iterate through the lick
                    {
                        Unit unit = i.next();
                        if (unit != null) //if next isn't empty
                        {
                            theme += unit.toLeadsheet() + " "; //add it to the theme
                        }
                    }

                    soloTable.setValueAt(theme, x, THEME_COLUMN); 
                    //make theme appear in table 
                    
                    if (getValueAt(x, NAME_COLUMN) != null) {
                        soloTable.setValueAt(null, x, NAME_COLUMN);
                    }
                    
                   // return lick;
                }
            }
        }
        return null;
    }

Random random;

       public MelodyPart generateSolohelper(ThemeUse chosenthemeUse, MelodyPart chosentheme, MelodyPart solo, CommandManager cm) {
        int length = chosentheme.size(); // get length of theme
        MelodyPart adjustedTheme = chosentheme.copy(); //made a copy of the theme
        imp.ImproVisor.setPlayEntrySounds(false); //don't play yet

        if (Notate.bernoulli(chosenthemeUse.probTranspose)) {
            // if a random number is greater than the probability not to transpose theme
            System.out.println("Transpose");
            themeUsageTextArea.append("Theme was transposed\n");
            ChordPart chordProg = notate.getChordProg(); //get current chord progression
            int rise = PitchClass.findRise(PitchClass.getPitchClass(chordProg.getCurrentChord(0).getRoot()),
                    PitchClass.getPitchClass(chordProg.getCurrentChord(length).getRoot()));
            //set rise equal to the rise of semitones from the root of the 0 chord to i chord
            int index = 0;
            Note n = adjustedTheme.getNote(index); //get the note of the theme at index 0

            while (n.isRest()) 
            { //while there is still theme left
                index += n.getRhythmValue(); //add the rhythm value of the theme to the index
                n = adjustedTheme.getNote(index); //get the note of the theme at new index
            }

            if (n.getPitch() >= (minPitch + maxPitch) / 2 && rise > 0)
            { // if pitch of theme is greater than or equal to the average pitch and change in semitones increased
                cm.execute(new ShiftPitchesCommand(-1 * (12 - rise), adjustedTheme,
                        0, length, 0, 128, notate.getScore().getKeySignature()));
            } //shift theme pitches down an octave + rise from 0 to the end of the theme
            
            else if (n.getPitch() < (minPitch + maxPitch) / 2 && rise < 0)
            { //if pitch of theme is less than the average pitch and change in semitones increased
                cm.execute(new ShiftPitchesCommand((12 + rise), adjustedTheme,
                        0, length, 0, 128, notate.getScore().getKeySignature()));
            } //shift theme pitches up an octave + rise from 0 to end of theme
            
            else {
                cm.execute(new ShiftPitchesCommand(rise, adjustedTheme, 0, length, 0, 128, notate.getScore().getKeySignature()));
            }
            //shift theme pitches by the rise in semitones
        }

        if (Notate.bernoulli(chosenthemeUse.probInvert))
        { // if a random number is greater than the probability not to invert the theme
            System.out.println("Invert");
            themeUsageTextArea.append("Theme was inverted\n");
        }
        cm.execute(new InvertCommand(adjustedTheme, 0, length, false)); //invert theme

        if (Notate.bernoulli(chosenthemeUse.probReverse))
        { // if a random number is greater than the probability not to reverse the theme
            System.out.println("Reverse");
            themeUsageTextArea.append("Theme was reversed\n");
        cm.execute(new ReverseCommand(adjustedTheme, 0, length, false)); //reverse theme
        }
        
//        else {
//           themeUsageTextArea.append("Theme was left as is\n"); 
//         }
//        
        ChordPart themeChords = notate.getChordProg().extract(length, length + length);
        //set chords of theme to be the chordpart extracted from length to length +length
        cm.execute(new RectifyPitchesCommand(adjustedTheme, 0, length, themeChords, false, false)); 
        //resolve pitches of the theme
        System.out.println("paste");
        solo.setSize(solo.getSize() + length); 
        //set size of solo to the existing length of the solo plus the length of the theme
        return adjustedTheme;

    }
        
      public void generateSolohelper2(int themeLength, MelodyPart solo) {
        Polylist rhythm = lickgen.generateRhythmFromGrammar(0, themeLength); 
        //generate rhythm 

        MelodyPart lick = fillMelody(BEAT, rhythm, notate.getChordProg(), 0);
        //create melody


        Part.PartIterator j = lick.iterator(); //iterate over lick
        while (j.hasNext()) //while any lick is left
        {
            Unit unit = j.next();
            if (unit != null) //if next is not empty
            {
                solo.addNote(NoteSymbol.toNote(unit.toLeadsheet())); 
                //add the unit to the solo
            }
        }
    }
        

    public void generateSolo(ArrayList<ThemeUse> themeUses, CommandManager cm) {
        themeUsageTextArea.setText(null);
        System.out.println("start");
        System.out.println(themeUses);
        // create four empty lists to start for all the probabilities
        List<Double> probUselist = new ArrayList(Arrays.asList());
        List<Double> probTransposelist = new ArrayList(Arrays.asList());
        List<Double> probInvertlist = new ArrayList(Arrays.asList());
        List<Double> probReverselist = new ArrayList(Arrays.asList());

        //loop through the themeUses list and get the probabilities for each
        //themeuse and add it to the corresponding empty list
        for (int i = 0; i < themeUses.size(); i++) {
            probUselist.add(themeUses.get(i).probUse);
         // System.out.println(themeUses.get(i).probUse);
            probTransposelist.add(themeUses.get(i).probTranspose);
            probInvertlist.add(themeUses.get(i).probInvert);
            probReverselist.add(themeUses.get(i).probReverse);
        }
        
       
        // find max of probability use to use that corresponding theme first
        double max = Collections.max(probUselist);
       // System.out.println(max);
        int index = probUselist.indexOf(max); //get the index of the max
        int length = themeUses.get(index).theme.melody.getSize(); 
        //get length of theme
        themeLength = length; //set themeLength to it
        MelodyPart solo = new MelodyPart(themeLength); 
        //set solo equal to a MelodyPart of the theme length

        imp.ImproVisor.setPlayEntrySounds(false); //don't play insertions yet

        solo.pasteSlots(themeUses.get(index).theme.melody, 0); 
        themeUsageTextArea.append(themeUses.get(index).theme.name + "\n");
               // + "used at slot 0\n");
        //paste theme into solo at starting point
        
        // set totals of probabilities to 0
        int probUsetotal = 0;
        int probTransposetotal = 0;
        int probInverttotal = 0;
        int probReversetotal = 0;

        //loop through each respective list and add elements together to get 
        //the total of each probability
        // multiply each element by 10 so its an integer
        for (int i = 0; i < themeUses.size(); i++) {
            probUsetotal += 10 * probUselist.get(i);
            probTransposetotal += 10 * probTransposelist.get(i);
            probInverttotal += 10 * probInvertlist.get(i);
            probReversetotal += 10 * probReverselist.get(i);
        }

        //set the variables the the very first themeUse and theme in the list to start with
        
        //use Theme Use Interval from text field
        int themeInterval = new Integer(themeIntervalTextField.getText());
        int themeIntervalUse = themeInterval * 120;
        
        for (int i = length; i <= notate.getScoreLength() - themeIntervalUse; i += themeIntervalUse) { 
            //loop through the remaining length of the score
            
            Integer noThemevalue = (int)(10*themeUses.size()*Double.valueOf(noThemeProbTextField.getText()));
            
            int themei = random.nextInt(probUsetotal + noThemevalue);
            System.out.println(themei);
            //pick a random number from 0 inclusive to 10*the probability list size
            //since all the elements in the list are multpled by 10, the size has to be multiplied by 10 too

            //To implement the probabilities I broke up the size of the list times 10 into intervals
            //the first interval is from 0 to to the first probability - 1 
            //so that way the number of slots in that interval is equal
            //to that first probability times 10
            //so if the random number chosen is in that interval, then that first theme is used
            if (themei <= 10 * probUselist.get(0) - 1) {
                System.out.println("Theme1");
                MelodyPart chosentheme = themeUses.get(0).theme.melody;
                ThemeUse chosenthemeUse = themeUses.get(0);
                themeUsageTextArea.append(chosenthemeUse.theme.name + "\n");
                        //"used at slot " + i + "\n");
                MelodyPart adjustedTheme = generateSolohelper(chosenthemeUse, chosentheme, solo, cm);

                //this if takes care of the case if the index is out of bounds
                if (i + adjustedTheme.size() >= solo.getSize()) {
                    generateSolohelper2(themeLength, solo);
                } 
                
                else {
                // if there is no index out of bounds issue, then add the adjusted theme into the solo
                    solo.pasteSlots(adjustedTheme, i);
                }
            } 
            //if the themeUses size is more than one themeuse then the other intervals have to be accounted for 
            
            else if (themeUses.size() > 1) {

                double A = 10 * probUselist.get(0);
                double B = 10 * probUselist.get(0) + 10 * probUselist.get(1);

                //the interval for the second ThemeUse
                if ((themei >= A) && (themei <= B - 1)) {
                    System.out.println("Theme2");
                    ThemeUse chosenthemeUse = themeUses.get(1);
                    MelodyPart chosentheme = themeUses.get(1).theme.melody;
                    themeUsageTextArea.append(chosenthemeUse.theme.name + "\n");
                            //"used at slot " + i + "\n");
                    MelodyPart adjustedTheme = generateSolohelper(chosenthemeUse, chosentheme, solo, cm);

                    if (i + adjustedTheme.size() >= solo.getSize()) {
                        generateSolohelper2(themeLength, solo);
                    } 
                    
                    else {
                        solo.pasteSlots(adjustedTheme, i);
                    }
                 }
                
                else {
                    //this loop covers the rest of the intervals
                    for (int k = 1; k < probUselist.size() - 1; k++) {
                        A += 10 * probUselist.get(k);
                        B += 10 * probUselist.get(k + 1);

                        if ((themei >= A) && (themei <= B - 1)) {
                            System.out.println("SubsequentThemes!");
                            ThemeUse chosenthemeUse = themeUses.get(k);
                            MelodyPart chosentheme = themeUses.get(k).theme.melody;
                            themeUsageTextArea.append(chosenthemeUse.theme.name + "\n");
                                    //"used at slot "+ i + "\n");
                            MelodyPart adjustedTheme = generateSolohelper(chosenthemeUse, chosentheme, solo, cm);

                            if (i + adjustedTheme.size() >= solo.getSize()) {
                                generateSolohelper2(themeLength, solo);
                            } 
                            
                            else {
                                solo.pasteSlots(adjustedTheme, i);
                            }
                        }
                    }
                }
            }

            //this interval is for not using any theme at all    
            if ((themei <= probUsetotal + noThemevalue) && (themei >= probUsetotal)) {
                System.out.println("noTheme");
                themeUsageTextArea.append("No Theme " + "\n");
                      //  + "//used at slot "+ i + "\n");
                generateSolohelper2(themeLength, solo);
            }
        }


        if (notate.getScore().getLength() - solo.getSize() != 0) { 
            //if the length of the score does not equal the length of the solo
            Polylist rhythm = lickgen.generateRhythmFromGrammar(0, notate.getScore().getLength() - solo.getSize());
            // generate rhythm for the space

            MelodyPart lick = fillMelody(BEAT, rhythm, notate.getChordProg(), 0); 
            //create melody for the space

            Part.PartIterator j = lick.iterator(); //iterate over the lick
            while (j.hasNext()) //while lick has next
            {
                solo.addNote(NoteSymbol.toNote(j.next().toLeadsheet())); 
                //add the note of the lick to the solo
            }
        }
        notate.setCurrentSelectionStart(0); //start selection at beginning

        // Experimental: Resolve pitches in entire solo: seems to improve things, but
        // may generate some repeated notes.
        cm.execute(new RectifyPitchesCommand(solo, 0, solo.getSize(), notate.getChordProg(), false, false));

        notate.pasteMelody(solo); //paste solo into leadsheet

        imp.ImproVisor.setPlayEntrySounds(true); //play solo
    }



    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JDialog AlreadyNamed;
    private javax.swing.JButton CancelButton;
    private javax.swing.JButton NoButton;
    private javax.swing.JButton NoOverwrite;
    private javax.swing.JButton Nodelete;
    private javax.swing.JButton OkButton;
    private javax.swing.JButton Okdelete;
    private javax.swing.JLabel OverwriteOption;
    private javax.swing.JButton Reset;
    private javax.swing.JLabel Resettable;
    private java.awt.Label SoloGeneratorTitle;
    private java.awt.Label ThemesLabel;
    private javax.swing.JButton YesButton;
    private javax.swing.JButton YesOverwrite;
    private javax.swing.JMenuItem cascadeMI;
    private javax.swing.JButton cellOkbutton;
    private javax.swing.JLabel chooseName;
    private javax.swing.JMenuItem closeWindowMI;
    private java.awt.Button currentSelection;
    private javax.swing.JDialog deleteCheck;
    private javax.swing.JLabel deletesure;
    private javax.swing.JDialog enteredIncorrectly;
    private java.awt.Button generateSolo;
    private java.awt.Button generateTheme;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JPopupMenu.Separator jSeparator5;
    private javax.swing.JDialog nameErrorMessage;
    private javax.swing.JTextField nameField;
    private javax.swing.JLabel namePicked;
    private javax.swing.JLabel noThemeProbLabel;
    private javax.swing.JTextField noThemeProbTextField;
    private java.awt.Button playSolo;
    private javax.swing.JDialog resetCheck;
    private javax.swing.JMenuBar roadmapMenuBar;
    private javax.swing.JTable soloTable;
    private javax.swing.JScrollPane soloTableScrollPane;
    private java.awt.Button stopPlaying;
    private javax.swing.JLabel themeIntervalLabel;
    private javax.swing.JTextField themeIntervalTextField;
    private javax.swing.JList themeList;
    private javax.swing.JScrollPane themeListScrollPane;
    private javax.swing.JScrollPane themeUsageScrollPane;
    private javax.swing.JTextArea themeUsageTextArea;
    private javax.swing.JLabel tryAgain;
    private javax.swing.JLabel typedWrong;
    private javax.swing.JMenu windowMenu;
    private javax.swing.JSeparator windowMenuSeparator;
    private javax.swing.JLabel youSure;
    // End of variables declaration//GEN-END:variables
} 


