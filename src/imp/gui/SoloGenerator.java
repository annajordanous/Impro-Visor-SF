/**
 * This Java Class is part of the Impro-Visor Application
 *
 * Copyright (C) 2014 Robert Keller and Harvey Mudd College
 *
 * Impro-Visor is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * Impro-Visor is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * merchantability or fitness for a particular purpose.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Impro-Visor; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
package imp.gui;

import static imp.Constants.BEAT;
import imp.com.CommandManager;
import imp.com.InvertCommand;
import imp.com.PlayScoreCommand;
import imp.com.RectifyPitchesCommand;
import imp.com.ReverseCommand;
import imp.com.ShiftPitchesCommand;
import imp.data.ChordPart;
import imp.data.MelodyPart;
import imp.data.Note;
import imp.data.NoteSymbol;
import imp.data.Part;
import imp.data.PitchClass;
import imp.data.Unit;
import polya.Polylist;
import imp.lickgen.LickGen;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import javax.swing.table.DefaultTableModel;
import javax.swing.ListSelectionModel;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Arrays;
import javax.swing.AbstractListModel;
import javax.swing.JLabel;
import java.util.List;
import java.util.Random;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;
/**
 *
 * @author David Morrison, Nava Dallal
 */
public class SoloGenerator extends javax.swing.JFrame {

    /**
     * Creates new form SoloGenerator
     */
    public SoloGenerator(LickGen lickgen, Notate notate, CommandManager cm) {
        this.random = new Random();
        initComponents();
    this.cm = cm;
    this.lickgen = lickgen;
    this.notate = notate;
    soloTable.setModel(soloTableModel);
    soloTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
    soloTable.addMouseListener(new MouseAdapter() {
        public void mouseReleased(MouseEvent e) {
            if(e.getClickCount() >= 1) {
                int row = soloTable.rowAtPoint(e.getPoint());
              soloTable.getSelectionModel().setSelectionInterval(row,row);
            }
        }
    });
    }
LickgenFrame lickgenFrame;
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        nameErrorMessage = new javax.swing.JDialog();
        nameField = new javax.swing.JTextField();
        namePicked = new javax.swing.JLabel();
        CancelButton = new javax.swing.JButton();
        OkButton = new javax.swing.JButton();
        chooseName = new javax.swing.JLabel();
        enteredIncorrectly = new javax.swing.JDialog();
        typedWrong = new javax.swing.JLabel();
        tryAgain = new javax.swing.JLabel();
        cellOkbutton = new javax.swing.JButton();
        resetCheck = new javax.swing.JDialog();
        Resettable = new javax.swing.JLabel();
        youSure = new javax.swing.JLabel();
        YesButton = new javax.swing.JButton();
        NoButton = new javax.swing.JButton();
        AlreadyNamed = new javax.swing.JDialog();
        OverwriteOption = new javax.swing.JLabel();
        YesOverwrite = new javax.swing.JButton();
        NoOverwrite = new javax.swing.JButton();
        deleteCheck = new javax.swing.JDialog();
        deletesure = new javax.swing.JLabel();
        Okdelete = new javax.swing.JButton();
        Nodelete = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        soloTable = new javax.swing.JTable();
        jScrollPane3 = new javax.swing.JScrollPane();
        themeList = new javax.swing.JList();
        ThemesLabel = new java.awt.Label();
        generateSolo = new java.awt.Button();
        generateTheme = new java.awt.Button();
        currentSelection = new java.awt.Button();
        playSolo = new java.awt.Button();
        stopPlaying = new java.awt.Button();
        SoloGeneratorTitle = new java.awt.Label();
        Reset = new javax.swing.JButton();

        nameErrorMessage.setMinimumSize(new java.awt.Dimension(500, 400));
        nameErrorMessage.getContentPane().setLayout(new java.awt.GridBagLayout());

        nameField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nameFieldActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 4;
        gridBagConstraints.ipadx = 309;
        gridBagConstraints.ipady = 12;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 20, 0, 0);
        nameErrorMessage.getContentPane().add(nameField, gridBagConstraints);

        namePicked.setText("The name you have picked is already assigned to a theme. ");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 5;
        gridBagConstraints.ipadx = 75;
        gridBagConstraints.ipady = 15;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(53, 20, 0, 0);
        nameErrorMessage.getContentPane().add(namePicked, gridBagConstraints);

        CancelButton.setText("Cancel");
        CancelButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CancelButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(12, 43, 105, 0);
        nameErrorMessage.getContentPane().add(CancelButton, gridBagConstraints);

        OkButton.setText("Ok");
        OkButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                OkButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.ipadx = -18;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(12, 20, 105, 0);
        nameErrorMessage.getContentPane().add(OkButton, gridBagConstraints);

        chooseName.setText("Please choose another:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.ipadx = 44;
        gridBagConstraints.ipady = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 20, 0, 0);
        nameErrorMessage.getContentPane().add(chooseName, gridBagConstraints);

        enteredIncorrectly.setMinimumSize(new java.awt.Dimension(400, 300));
        enteredIncorrectly.getContentPane().setLayout(new java.awt.GridBagLayout());

        typedWrong.setText("You have typed information into a cell incorrectly.");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(91, 46, 0, 67);
        enteredIncorrectly.getContentPane().add(typedWrong, gridBagConstraints);

        tryAgain.setText("Please try again.");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 155, 0, 0);
        enteredIncorrectly.getContentPane().add(tryAgain, gridBagConstraints);

        cellOkbutton.setText("Ok");
        cellOkbutton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cellOkbuttonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(18, 163, 97, 0);
        enteredIncorrectly.getContentPane().add(cellOkbutton, gridBagConstraints);

        resetCheck.setMinimumSize(new java.awt.Dimension(500, 300));
        resetCheck.getContentPane().setLayout(new java.awt.GridBagLayout());

        Resettable.setText("Resetting the table will clear everything you currently have entered. ");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 5;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(96, 39, 0, 77);
        resetCheck.getContentPane().add(Resettable, gridBagConstraints);

        youSure.setText("Are you sure you want to do this?");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(6, 137, 0, 0);
        resetCheck.getContentPane().add(youSure, gridBagConstraints);

        YesButton.setText("Yes, Continue");
        YesButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                YesButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(31, 78, 150, 0);
        resetCheck.getContentPane().add(YesButton, gridBagConstraints);

        NoButton.setText("No, Cancel");
        NoButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                NoButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.ipadx = 16;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(31, 76, 150, 0);
        resetCheck.getContentPane().add(NoButton, gridBagConstraints);

        AlreadyNamed.setBounds(new java.awt.Rectangle(22, 22, 22, 22));
        AlreadyNamed.getContentPane().setLayout(new java.awt.GridBagLayout());

        OverwriteOption.setText("This theme already has a name. Would you like to overwrite it? ");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(120, 20, 0, 22);
        AlreadyNamed.getContentPane().add(OverwriteOption, gridBagConstraints);

        YesOverwrite.setText("Yes");
        YesOverwrite.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                YesOverwriteActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(18, 84, 147, 0);
        AlreadyNamed.getContentPane().add(YesOverwrite, gridBagConstraints);

        NoOverwrite.setText("No");
        NoOverwrite.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                NoOverwriteActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(18, 70, 147, 0);
        AlreadyNamed.getContentPane().add(NoOverwrite, gridBagConstraints);

        deleteCheck.setBounds(new java.awt.Rectangle(22, 22, 22, 22));
        deleteCheck.setMinimumSize(new java.awt.Dimension(450, 350));
        deleteCheck.getContentPane().setLayout(new java.awt.GridBagLayout());

        deletesure.setText("Are you sure you want to delete this row?");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.ipadx = 67;
        gridBagConstraints.ipady = 13;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(89, 68, 0, 6);
        deleteCheck.getContentPane().add(deletesure, gridBagConstraints);

        Okdelete.setText("Yes");
        Okdelete.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                OkdeleteActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(18, 78, 135, 0);
        deleteCheck.getContentPane().add(Okdelete, gridBagConstraints);

        Nodelete.setText("No");
        Nodelete.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                NodeleteActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(18, 71, 135, 0);
        deleteCheck.getContentPane().add(Nodelete, gridBagConstraints);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setLocation(new java.awt.Point(10, 10));
        setLocationByPlatform(true);
        getContentPane().setLayout(new java.awt.GridBagLayout());

        jScrollPane1.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

        soloTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null}
            },
            new String [] {
                "Name", "Theme Length", "Theme", "Prob. to Use", "Prob. to Transpose", "Prob. to Invert", "Prob. to Reverse"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }
        });
        soloTable.setAlignmentY(1.0F);
        soloTable.setColumnSelectionAllowed(true);
        soloTable.setGridColor(new java.awt.Color(0, 0, 0));
        soloTable.setPreferredSize(null);
        soloTable.setShowGrid(true);
        soloTable.getTableHeader().setReorderingAllowed(false);
        soloTable.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                soloTableMouseClicked(evt);
            }
        });
        soloTable.addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentShown(java.awt.event.ComponentEvent evt) {
                soloTableComponentShown(evt);
            }
        });
        soloTable.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                soloTableKeyPressed(evt);
            }
        });
        jScrollPane1.setViewportView(soloTable);
        soloTable.getColumnModel().getSelectionModel().setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.gridheight = 4;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.ipadx = 20;
        gridBagConstraints.ipady = -250;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(9, 37, 0, 0);
        getContentPane().add(jScrollPane1, gridBagConstraints);

        jScrollPane3.setMaximumSize(new java.awt.Dimension(0, 0));
        jScrollPane3.setMinimumSize(new java.awt.Dimension(0, 0));
        jScrollPane3.setPreferredSize(new java.awt.Dimension(150, 100));

        themeList.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        themeList.setModel(themeListModel);
        themeList.setLayoutOrientation(javax.swing.JList.VERTICAL_WRAP);
        themeList.setPreferredSize(null);
        themeList.setVisibleRowCount(30);
        themeList.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                themeListClicked(evt);
            }
        });
        jScrollPane3.setViewportView(themeList);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.gridwidth = 4;
        gridBagConstraints.gridheight = 7;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.ipady = 100;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(1, 18, 0, 37);
        getContentPane().add(jScrollPane3, gridBagConstraints);

        ThemesLabel.setFont(new java.awt.Font("Lucida Grande", 1, 13)); // NOI18N
        ThemesLabel.setText("Themes");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.ipady = 9;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(23, 78, 0, 0);
        getContentPane().add(ThemesLabel, gridBagConstraints);

        generateSolo.setLabel("Generate Solo");
        generateSolo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                generateSoloActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.ipadx = 373;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(10, 57, 0, 0);
        getContentPane().add(generateSolo, gridBagConstraints);

        generateTheme.setLabel("Generate Theme");
        generateTheme.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                generateThemeActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridheight = 2;
        gridBagConstraints.ipadx = 358;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(36, 57, 0, 0);
        getContentPane().add(generateTheme, gridBagConstraints);

        currentSelection.setLabel("Use Current Selection in Leadsheet Window as Theme");
        currentSelection.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                currentSelectionActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 8;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.gridheight = 2;
        gridBagConstraints.ipadx = 133;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(18, 53, 0, 0);
        getContentPane().add(currentSelection, gridBagConstraints);

        playSolo.setLabel("Play Solo");
        playSolo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                playSoloActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 10;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.ipadx = 412;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(10, 53, 0, 0);
        getContentPane().add(playSolo, gridBagConstraints);

        stopPlaying.setLabel("Stop Playing");
        stopPlaying.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                stopPlayingActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 11;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.ipadx = 391;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(10, 50, 0, 0);
        getContentPane().add(stopPlaying, gridBagConstraints);

        SoloGeneratorTitle.setFont(new java.awt.Font("LiSong Pro", 0, 36)); // NOI18N
        SoloGeneratorTitle.setText("Solo Generator");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.ipadx = 174;
        gridBagConstraints.ipady = -5;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(10, 278, 0, 0);
        getContentPane().add(SoloGeneratorTitle, gridBagConstraints);

        Reset.setText("Reset");
        Reset.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ResetActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 4;
        gridBagConstraints.gridy = 11;
        gridBagConstraints.ipadx = 32;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(18, 18, 28, 0);
        getContentPane().add(Reset, gridBagConstraints);

        pack();
    }// </editor-fold>//GEN-END:initComponents

public void stopPlaying()
  {
  notate.stopPlaying();
  }
private void playSelection()
    {
    notate.getCurrentStave().playSelection(false, notate.getLoopCount(), PlayScoreCommand.USEDRUMS, "LickGenFrame");
    }
    private void soloTableComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_soloTableComponentShown
        // TODO add your handling code here:
    }//GEN-LAST:event_soloTableComponentShown

    private void generateThemeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_generateThemeActionPerformed
    generateTheme();
     
    }//GEN-LAST:event_generateThemeActionPerformed

    private void generateSoloActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_generateSoloActionPerformed

        int themeUsesize = 0; // set size of the input themeUses to 0
        
        for (int i = 0; i < soloTable.getRowCount(); i++) { //loop through table
            if (soloTable.getValueAt(i, 2) != null) { //for every theme entered in the table
                themeUsesize += 1; //add one to the size
            }
        }
        
        ArrayList<ThemeUse> themeUses = new ArrayList<ThemeUse>(themeUsesize); //create an empty array of themeUses

        for (int i = 0; i < themeUsesize; i++) { //loop through size of themeUses

            if ((soloTable.getValueAt(i, 2) == null) ||  (soloTable.getValueAt(i, 3) == null) || (soloTable.getValueAt(i, 4) == null)
                    || (soloTable.getValueAt(i, 5) == null) || (soloTable.getValueAt(i, 6) == null)) { //if any cell has incorrect info
                enteredIncorrectly.setVisible(true); //show error message
                break;
             } 
            else if ((isDouble((String) soloTable.getValueAt(i, 3)) == false) || (isDouble((String) soloTable.getValueAt(i, 4)) == false)
                    || (isDouble((String) soloTable.getValueAt(i, 5)) == false) || (isDouble((String) soloTable.getValueAt(i, 6)) == false)) {
                enteredIncorrectly.setVisible(true); //show error message
                break;
            }
            
            else { //if they are all entered correctly
                themeUses.add(new ThemeUse(new MelodyPart((String) soloTable.getValueAt(i, 2)))); // add a new ThemeUse to the arraylist with respective elements
                themeUses.get(i).probUse = Double.valueOf((String) soloTable.getValueAt(i, 3));
                themeUses.get(i).probTranspose = Double.valueOf((String) soloTable.getValueAt(i, 4));
                themeUses.get(i).probInvert = Double.valueOf((String) soloTable.getValueAt(i, 5));
                themeUses.get(i).probReverse = Double.valueOf((String) soloTable.getValueAt(i, 6));
                generateSolo(themeUses, cm);
                playSelection();
            }
        }


    }//GEN-LAST:event_generateSoloActionPerformed

    private void currentSelectionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_currentSelectionActionPerformed
        int index = soloTable.getSelectedRow();
        MelodyPart sel = notate.getCurrentStave().getDisplayPart().extract(
                notate.getCurrentSelectionStart(),
                notate.getCurrentSelectionEnd());
        Part.PartIterator i = sel.iterator();
        String theme = "";
        while (i.hasNext()) {
            theme += i.next().toLeadsheet() + " ";
        }

        soloTable.setValueAt(theme, index, 2);
        soloTable.setValueAt(sel.getSize() / BEAT + "", index, 1);
        
        if (soloTable.getValueAt(index, 0) != null) {
            MelodyPart melody = new MelodyPart((String) soloTable.getValueAt(index, 2));
            int themelength = melody.size() / BEAT;
            soloTable.setValueAt(themelength + "", index, 1);
            
            for (Map.Entry pair : allThemes.entrySet()) { //loop through all the entry sets of {Theme,name} in allThemes
                Theme ThemeKey = (Theme) pair.getKey(); //get the Theme of each entry
                
                if (melody.toString().equals(ThemeKey.melody.toString())) { //if the melody in allThemes is the name as the melody in the table
                    soloTable.setValueAt(pair.getValue(), index, 0); //set the name to the one that matches that theme
                } 
                else 
                {// if there is no matching theme in allThemes
                    soloTable.setValueAt(null, index, 0); //set the name to empty
                }
            }
        }
    }//GEN-LAST:event_currentSelectionActionPerformed

    private void playSoloActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_playSoloActionPerformed
        playSelection();
        
    }//GEN-LAST:event_playSoloActionPerformed

    private void stopPlayingActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stopPlayingActionPerformed
        stopPlaying();
    }//GEN-LAST:event_stopPlayingActionPerformed

    private void soloTableKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_soloTableKeyPressed
        int index = soloTable.getSelectedRow();
        if (evt.getKeyCode() == KeyEvent.VK_DELETE) {
          //  deleteCheck.setVisible(true);
          soloTableModel.removeRow(index);
        }

        if (evt.getKeyCode() == KeyEvent.VK_INSERT) {
            soloTableModel.addARow();
        }





        
    }//GEN-LAST:event_soloTableKeyPressed

    private void ResetActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ResetActionPerformed
        resetCheck.setVisible(true);
    }//GEN-LAST:event_ResetActionPerformed

    private void soloTableMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_soloTableMouseClicked

    }//GEN-LAST:event_soloTableMouseClicked

    private void themeListClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_themeListClicked
        
        for (int i = 0; i < orderedThemes.size(); i++) { //loop through size of orderedThemes
            for (int j = 0; j < soloTable.getRowCount(); j++) {//loop through table
                
                if ((themeList.isSelectedIndex(i) == true) && (soloTable.isCellSelected(j, 2) == true)) {
                    //if a theme in the Themes scroll box is clicked and a theme cell is selected
                    String name = (String) themeList.getSelectedValue(); //set name equal to the one clicked in the scroll box
                    
                    for (Map.Entry pair : allThemes.entrySet()) { //loop through entries in allThemes
                        
                        if (name == pair.getValue()) 
                        { //if the name in the themeList is equal to the name in the entry
                            Theme theme = (Theme) pair.getKey(); //set theme equal to the corresponding theme in that entry
                            MelodyPart melody = theme.melody; //get the melody of the theme
                            Part.PartIterator k = melody.iterator(); //iterate over melody
                            String themestring = ""; //set theme as empty to start
                            
                            while (k.hasNext()) //while you can still iterate through the melody
                            {
                                Unit unit = k.next();
                                if (unit != null) //if next isn't empty
                                {
                                    themestring += unit.toLeadsheet() + " "; //add it to the theme in leadsheet notation
                                }
                            }
                            
                            soloTable.setValueAt(name, j, 0); //paste in the name of theme to the table
                            soloTable.setValueAt(theme.ThemeLength + "", j, 1); //paste in the theme length
                            soloTable.setValueAt(themestring, j, 2); //paste in the theme in leadsheet notation

                            //in case the length is different than the one typed by the user 
                            int n = 0;
                            for (int x = 0; x < soloTable.getRowCount(); x++) { //loop through table
                                if (soloTable.getValueAt(x, 0) != null && ((((String) soloTable.getValueAt(x, 0)).equals(name)) || ((String) soloTable.getValueAt(x, 0)).equals(name + "-" + n))
                                        && (x != j) && (((String) soloTable.getValueAt(x, 2)).equals(themestring))  
                                        //&& (!((String) soloTable.getValueAt(x, 1)).equals(theme.ThemeLength + ""))
                                        ) {
                                    n += 1; //add one to n so if the same theme is already in the table it will be differentiated from it
                                    //if the names are the same, the rows are different, the themes are the same, the lengths are different
                                    soloTable.setValueAt(theme.ThemeLength + "", x, 1); //make the lengths the same 
                                    soloTable.setValueAt(name + "-" + n,j,0);
                                    // System.out.println(theme.ThemeLength);
                                }
                            }
                        }
                    }
                }
            }
        }
    }//GEN-LAST:event_themeListClicked

    private void OkButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_OkButtonActionPerformed
        if (orderedThemes.contains(nameField.getText()) == true) 
        { //if the user enters a name that is already in orderedThemes
            nameErrorMessage.setVisible(true); //same error message pops up
        }
        
        else {
            for (int i = 0; i < soloTable.getRowCount(); i++) {// loop through table
                
                if (soloTable.isCellSelected(i, 0) == true) 
                {  
                        soloTable.setValueAt(nameField.getText(), i, 0); //set the name in the table
                        addTheme(nameField.getText(), (String) soloTable.getValueAt(i, 2)); //add the theme
                  }
                
            }
        }
        nameErrorMessage.setVisible(false); //close the error window
    }//GEN-LAST:event_OkButtonActionPerformed

    private void CancelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CancelButtonActionPerformed
     nameErrorMessage.setVisible(false);   
        
    }//GEN-LAST:event_CancelButtonActionPerformed

    private void cellOkbuttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cellOkbuttonActionPerformed
       enteredIncorrectly.setVisible(false);
    }//GEN-LAST:event_cellOkbuttonActionPerformed

    private void nameFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nameFieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_nameFieldActionPerformed

    private void YesButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_YesButtonActionPerformed
        soloTableModel.tableReset();
        resetCheck.setVisible(false);
    }//GEN-LAST:event_YesButtonActionPerformed

    private void NoButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_NoButtonActionPerformed
        resetCheck.setVisible(false);
    }//GEN-LAST:event_NoButtonActionPerformed

    private void YesOverwriteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_YesOverwriteActionPerformed
        MelodyPart theme = null; 
        for (int j = 0; j < soloTable.getRowCount(); j++) { 

            if (soloTable.isCellSelected(j,0) == true) {
                theme = (MelodyPart)soloTable.getValueAt(j,2);
            }
            
        for (Map.Entry pair : allThemes.entrySet()) {
            Theme KeyTheme = (Theme)pair.getKey();
            
                 if (theme == KeyTheme.melody) {
                     allThemes.put(KeyTheme, nameField.getText());
                    ensureThemeArray(); 
                    soloTable.setValueAt(nameField.getText(),j,0);
                  }
                 
            }
        }

    }//GEN-LAST:event_YesOverwriteActionPerformed

    private void NoOverwriteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_NoOverwriteActionPerformed
        AlreadyNamed.setVisible(false);
        MelodyPart theme = null;
        
        for (int j = 0; j < soloTable.getRowCount(); j++) { 
            
            if (soloTable.isCellSelected(j,0) == true) {
                theme = (MelodyPart)soloTable.getValueAt(j,2);
            }
            
        for (Map.Entry pair : allThemes.entrySet()) {
            Theme KeyTheme = (Theme)pair.getKey();
            
                 if (theme == KeyTheme.melody) {
                   String name =  (String)pair.getValue();
                   soloTable.setValueAt(name, j, 0);
                  }
                 
            }
        }
    }//GEN-LAST:event_NoOverwriteActionPerformed

    private void OkdeleteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_OkdeleteActionPerformed
       int index = soloTable.getSelectedRow();
       soloTableModel.removeRow(index);
       
       for (int i = 0; i < soloTable.getColumnCount(); i++){
           
           if (soloTable.isCellSelected(index,i) == true) {
               System.out.println("delete");
               soloTable.setValueAt(null,index,i);
           }
           
       }
      //  soloTableModel.removeRow(index);
       deleteCheck.setVisible(false); 
    }//GEN-LAST:event_OkdeleteActionPerformed

    private void NodeleteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_NodeleteActionPerformed
       deleteCheck.setVisible(false);
    }//GEN-LAST:event_NodeleteActionPerformed

   
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(SoloGenerator.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(SoloGenerator.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(SoloGenerator.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(SoloGenerator.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
            }
        });
    }
 
 private int themeLength = 8;

private double themeProb = 0.4;

private double transposeProb = 0.5;

private double invertProb = 0.1;

private double reverseProb = 0.1;

private Notate notate;

//private ArrayList<String> melodyData = new ArrayList<String>();
//
//private double roundTo = BEAT;
//
//private int paddingSlots = BEAT / 2;

private int minPitch = 60;

private int maxPitch = 82;

private int minInterval = 0;

private int maxInterval = 6;
//
//private int minDuration = 8;
//
//private int maxDuration = 8;
//
//private double totalBeats = 8;
//
//private int totalSlots = (int) (BEAT * totalBeats);
//
//private double restProb = 0.1;

private double leapProb = 0.2;
//
//private double chordToneWeight = 0.7;
//
//private double scaleToneWeight = 0.1;
//
//private double colorToneWeight = 0.05;
//
//private double chordToneDecayRate = 0.1;

private boolean avoidRepeats = true;

//private boolean useGrammar = true;
//
//private boolean autoFill = true;
//
//private int recurrentIteration = 1;

private LickGen lickgen;

private CommandManager cm;

    
public ThemeListModel themeListModel = new ThemeListModel();

  
private SoloGeneratorTableModel soloTableModel = new SoloGeneratorTableModel (
        new Object [][] {
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null}
            },
            new String [] {
                "Name", "Length", "Theme", "Use", "Transpose", "Invert", "Reverse"
            } ) ;
         
                  
   

public class SoloGeneratorTableModel extends DefaultTableModel 
{
 private static final int columnCount = 7;

    boolean[] canEdit = new boolean [] {
              //name, theme, length, use, transpose, invert, reverse
                true, true , true, true, true, true, true
            };
    
    int [] columnWidths = new int [] {
                30    , 25   , 70   , 25   , 25  , 25,  25
            };
    int [] columnAdjustment = new int [] {
                JLabel.CENTER, JLabel.LEFT, JLabel.LEFT, JLabel.RIGHT,
                JLabel.RIGHT  , JLabel.RIGHT, JLabel.RIGHT, 
            };

    public SoloGeneratorTableModel(Object [][] myTable, String [] columnHeaders)
    {
        super(myTable, columnHeaders);
    }

    public int getColumnWidths(int index) {
        return columnWidths[index];
    }
//
    public int getColumnAdjustments(int index) {
        return columnAdjustment[index];
    }

    @Override
    public boolean isCellEditable(int rowIndex, int columnIndex) {
        return canEdit [columnIndex];
    }

    public void tableRefresh() {
        for (int i = 0; i < soloTable.getRowCount(); i ++ ) {
            for (int j = 0; j < soloTable.getColumnCount(); j++) {
                soloTable.setValueAt(null, i, j);
                
                if (soloTable.getRowCount() != 20) {
                    for (int x = 0; x < 10 - soloTable.getRowCount(); x ++)
                    soloTableModel.addARow();
                }
                
            }
        }
        fireTableDataChanged();
    }
     

    public void tableReset() {

       tableRefresh();
     }


   @Override
    public int getColumnCount() {
        return columnCount;
    }

    public void addARow()
    {
        soloTableModel.insertRow(0, new Object [] {null,
                                                    null,
                                                    null,
                                                    null,
                                                    null,
                                                    null,
                                                    null}
              );
    }
    
  
//
  @Override
   public Class getColumnClass(int column)
  {
       switch(column)
       {
           case 0:
              return Object.class;
       }
       return Object.class;
  }
 
  @Override
  public void setValueAt(Object value, int row, int col) {
      super.setValueAt(value,row,col);
      if(!themeList.hasFocus())
        enteringValue(row, col);
      
  }
  }
  
    public void enteringValue(int row, int col) {
        for (int i = 0; i < soloTable.getRowCount(); i++) { //loop through table
            
            if ((soloTable.isCellSelected(i, 2) == true) && (soloTable.getValueAt(i, 2) != null)) 
            { //if a theme is selected
                
                if (soloTable.getValueAt(i, 0) == null) 
                { //if there is no name
                    MelodyPart melody = new MelodyPart((String) soloTable.getValueAt(i, 2)); //set melody to the leadsheet notation of the theme
                    int themelength = melody.size() / BEAT;
                    soloTable.setValueAt(themelength + "", i, 1); //set themelength in the table
                  } 
                
                else { //if there is already a name
                    MelodyPart melody = new MelodyPart((String) soloTable.getValueAt(i, 2));
                    int themelength = melody.size() / BEAT;
                    soloTable.setValueAt(themelength + "", i, 1);

                    for (Map.Entry pair : allThemes.entrySet()) { //loop through all the entry sets of {Theme,name} in allThemes
                        Theme ThemeKey = (Theme) pair.getKey(); //get the Theme of each entry

                        if (melody.toString().equals(ThemeKey.melody.toString())) 
                        { //if the melody in allThemes is the name as the melody in the table
                            soloTable.setValueAt(pair.getValue(), i, 0); //set the name to the one that matches that theme
                        } 
                        
                        else 
                        {// if there is no matching theme in allThemes
                            soloTable.setValueAt(null, i, 0); //set the name to empty
                        }
                    }
                }

            }
            
            if ((soloTable.isCellSelected(i, 0) == true) && (soloTable.getValueAt(i, 2) != null) 
                    && (soloTable.getValueAt(i, 0) != null)) 
            { //if name cell is selected, it's not empty and the theme isn't empty
                MelodyPart melody = new MelodyPart((String) soloTable.getValueAt(i, 2));
                System.out.println(melody);
                String name = (String) soloTable.getValueAt(i, 0);
                String themestring = (String) soloTable.getValueAt(i, 2);

                if (orderedThemes.isEmpty() == true) {
                    System.out.println("empty");
                    addTheme(name, themestring);
                } 
                
                else if (orderedThemes.contains(name) == true)
                { //if the user types a name already in the list
                    System.out.println("contains");
                    nameErrorMessage.setVisible(true); //give name error message to rename the theme
                } 
                
                else {
                    for (Map.Entry pair : allThemes.entrySet().toArray(new Map.Entry[0])) { // loop through the entries of allThemes
                        Theme ThemeKey = (Theme) pair.getKey(); //get the Theme of each entry
                        System.out.println(ThemeKey.melody);

                        if (melody.toString().equals(ThemeKey.melody.toString())) 
                        { //if the melody of the Theme is the same as the one in the table
//                     System.out.println("themeproblem");
//                     AlreadyNamed.setVisible(true); 
                            System.out.println("same");
                            addTheme(name, themestring); //add the theme to the list
                            //   soloTable.setValueAt(pair.getValue(), i, 0); //set the name to the one in the list(what is was before user changed it)
                            for (int k = 0; k < soloTable.getRowCount(); k++) { //loop through table

                                if ((soloTable.getValueAt(k, 0) == null) && (soloTable.getValueAt(k, 1) == null)
                                        && (soloTable.getValueAt(k, 2) == null)) 
                                { //if there is a null row (besides probabilities)
                                    soloTable.setValueAt(name, k, 0); //set name to one user typed
                                    soloTable.setValueAt(themestring, k, 2); //set theme to the one 

                                    if (!(row == i && col == 1)) {
                                        soloTable.setValueAt(soloTable.getValueAt(i, 1), k, 1); //set the themelength
                                    }
                                    break;
                                }
                            }
                            
                            soloTable.setValueAt(pair.getValue(), i, 0); //set the name to the one in the list(what is was before user changed it)
                            nameErrorMessage.setVisible(false);
                            break;
                        }
                        
                        else { //if there is no melody that matches the one in the table
                            System.out.println("Adding");
                            addTheme(name, themestring);
                        }
                    }
                    break;


                }
            }
        }
        
        System.out.println(orderedThemes);

    }
  


private static LinkedHashMap<Theme, String> allThemes = new LinkedHashMap<Theme, String>();
 private static ArrayList<String> orderedThemes = null;
 int allThemesIndex = allThemes.size() - 1;
  
  public static int numberOfThemes()
    {
      ensureThemeArray();
      return orderedThemes.size(); 
    }
  
// public static Theme getTheme(String name)
//    {
//      return allThemes.get(name);
//    }
  
  public static void setTheme(String name, Theme theme)
    {
      allThemes.put(theme, name);
    }
  
    public static String getNth(int index)
      {
        ensureThemeArray();
        return orderedThemes.get(index);
      }
    
    private static void ensureThemeArray()
      {
            {
                
           orderedThemes = new ArrayList<String>(allThemes.values());
            }       
      }

public void addTheme(String name, String themestring)
    {
        ensureThemeArray();
        int orderedThemesIndex = orderedThemes.size() - 1;
        System.out.println(allThemes);
        System.out.println(orderedThemes);
        
        for (int i = 0; i < soloTable.getRowCount(); i++) {
            Theme newTheme = Theme.makeTheme(name, new MelodyPart(themestring));
            //  Theme theme = allThemes.get(themestring);
            if ((soloTable.getValueAt(i, 0) != null) && (orderedThemes.contains(name) == false)) {
                orderedThemes.add(name);
                allThemes.put(newTheme, name);
            }

            themeListModel.reset();
            orderedThemesIndex = orderedThemes.indexOf(newTheme);
            //  allThemesIndex = allThemes.indexOf(theme);
        }
        System.out.println(orderedThemes);
        System.out.println(allThemes);
    }

public class ThemeListModel
    extends AbstractListModel
{
  
public int getSize()
  {
   int number = numberOfThemes();
    
    return number;
      
  }

public Object getElementAt(int index)
  {
    //System.out.println("requesting " + index + " of " + getSize() + " " + Style.getNth(index));
    return getNth(index);
  }

public void reset()
  {
    //System.out.println("reset");
    fireContentsChanged(this, 0, getSize());
  }

public void adjust()
  {
    //System.out.println("adjust");
    fireIntervalAdded(this, 0, getSize());
  }

}

public static boolean isInteger(String s) {
    try {
        Integer.parseInt(s);
    }
    catch(NumberFormatException e) {
        return false;
    }
    return true;
}

public static boolean isDouble(String s) {
    try {
        Double.parseDouble(s);
    }
    catch (NumberFormatException e) {
        return false;
    }
    return true;
}
  
// \
public MelodyPart fillMelody(int beatValue,
                             Polylist rhythmString, 
                             ChordPart chordProg,
                             int start)
  {
    MelodyPart result = lickgen.fillMelody(minPitch, 
                                           maxPitch, 
                                           minInterval, 
                                           maxInterval,
                                           beatValue, 
                                           leapProb, 
                                           rhythmString, 
                                           chordProg,
                                           start, 
                                           avoidRepeats);

    return result;
  } 

    public MelodyPart generateTheme() { 
        for (int x = 0; x < soloTable.getRowCount(); x++) { //loop through the rows of the table
            
            if (isInteger((String) soloTable.getValueAt(x, 1)) == false) {
                enteredIncorrectly.setVisible(true);
              } 
            else {
                
                if ((soloTable.isCellSelected(x, 1) == true) && (soloTable.getValueAt(x, 1) != null)) {
                    //if the theme length cell is selected and has something in it
                    int Length = notate.intFromStringInRange((String) soloTable.getValueAt(x, 1), 0, 100, themeLength); //get length from table
                    themeLength = BEAT * Length;
                    Polylist rhythm = lickgen.generateRhythmFromGrammar(0, themeLength); //get rhythm for theme from grammar

                    MelodyPart lick = fillMelody(BEAT, rhythm, notate.getChordProg(), 0); //get the melody of the theme

                    Part.PartIterator i = lick.iterator(); //iterate over lick
                    String theme = ""; //set theme as empty to start
                    
                    while (i.hasNext()) //while you can still iterate through the lick
                    {
                        Unit unit = i.next();
                        if (unit != null) //if next isn't empty
                        {
                            theme += unit.toLeadsheet() + " "; //add it to the theme
                        }
                    }

                    soloTable.setValueAt(theme, x, 2);  //make theme appear in table 
                    
                    if (soloTable.getValueAt(x, 0) != null) {
                        soloTable.setValueAt(null, x, 0);
                    }
                    
                    return lick;
                }
            }
        }
        return null;
    }

Random random;

       public MelodyPart generateSolohelper(ThemeUse chosenthemeUse, MelodyPart chosentheme, MelodyPart solo, CommandManager cm) {
        int length = chosentheme.size(); // get length of theme
        MelodyPart adjustedTheme = chosentheme.copy(); //made a copy of the theme
        imp.ImproVisor.setPlayEntrySounds(false); //don't play yet

        if (Notate.bernoulli(chosenthemeUse.probTranspose)) {// if a random number is greater than the probability not to transpose theme
            System.out.println("Transpose");
            ChordPart chordProg = notate.getChordProg(); //get current chord progression
            int rise = PitchClass.findRise(PitchClass.getPitchClass(chordProg.getCurrentChord(0).getRoot()),
                    PitchClass.getPitchClass(chordProg.getCurrentChord(length).getRoot()));
            //set rise equal to the rise of semitones from the root of the 0 chord to i chord
            int index = 0;
            Note n = adjustedTheme.getNote(index); //get the note of the theme at index 0

            while (n.isRest()) 
            { //while there is still theme left
                index += n.getRhythmValue(); //add the rhythm value of the theme to the index
                n = adjustedTheme.getNote(index); //get the note of the theme at new index
            }

            if (n.getPitch() >= (minPitch + maxPitch) / 2 && rise > 0)
            { // if pitch of theme is greater than or equal to the average pitch and change in semitones increased
                cm.execute(new ShiftPitchesCommand(-1 * (12 - rise), adjustedTheme,
                        0, length, 0, 128, notate.getScore().getKeySignature()));
            } //shift theme pitches down an octave + rise from 0 to the end of the theme
            
            else if (n.getPitch() < (minPitch + maxPitch) / 2 && rise < 0)
            { //if pitch of theme is less than the average pitch and change in semitones increased
                cm.execute(new ShiftPitchesCommand((12 + rise), adjustedTheme,
                        0, length, 0, 128, notate.getScore().getKeySignature()));
            } //shift theme pitches up an octave + rise from 0 to end of theme
            
            else {
                cm.execute(new ShiftPitchesCommand(rise, adjustedTheme, 0, length, 0, 128, notate.getScore().getKeySignature()));
            }
            //shift theme pitches by the rise in semitones
        }

        if (Notate.bernoulli(chosenthemeUse.probInvert))
        { // if a random number is greater than the probability not to invert the theme
            System.out.println("Invert");
        }
        cm.execute(new InvertCommand(adjustedTheme, 0, length, false)); //invert theme

        if (Notate.bernoulli(chosenthemeUse.probReverse))
        { // if a random number is greater than the probability not to reverse the theme
            System.out.println("Reverse");
        }
        cm.execute(new ReverseCommand(adjustedTheme, 0, length, false)); //reverse theme

        ChordPart themeChords = notate.getChordProg().extract(length, length + length);
        //set chords of theme to be the chordpart extracted from length to length +length
        cm.execute(new RectifyPitchesCommand(adjustedTheme, 0, length, themeChords, false, false)); 
        //resolve pitches of the theme
        System.out.println("paste");
        solo.setSize(solo.getSize() + length); 
        //set size of solo to the existing length of the solo plus the length of the theme
        return adjustedTheme;

    }
        
      public void generateSolohelper2(int themeLength, MelodyPart solo) {
        Polylist rhythm = lickgen.generateRhythmFromGrammar(0, themeLength); //generate rhythm 

        MelodyPart lick = fillMelody(BEAT, rhythm, notate.getChordProg(), 0);//create melody


        Part.PartIterator j = lick.iterator(); //iterate over lick
        while (j.hasNext()) //while any lick is left
        {
            Unit unit = j.next();
            if (unit != null) //if next is not empty
            {
                solo.addNote(NoteSymbol.toNote(unit.toLeadsheet())); //add the unit to the solo
            }
        }
    }
        

    public void generateSolo(ArrayList<ThemeUse> themeUses, CommandManager cm) {

        // create four empty lists to start for all the probabilities
        List<Double> probUselist = new ArrayList(Arrays.asList());
        List<Double> probTransposelist = new ArrayList(Arrays.asList());
        List<Double> probInvertlist = new ArrayList(Arrays.asList());
        List<Double> probReverselist = new ArrayList(Arrays.asList());

        //loop through the themeUses list and get the probabilities for each
        //themeuse and add it to the corresponding empty list
        for (int i = 0; i < themeUses.size(); i++) {
            probUselist.add(themeUses.get(i).probUse);
         // System.out.println(themeUses.get(i).probUse);
            probTransposelist.add(themeUses.get(i).probTranspose);
            probInvertlist.add(themeUses.get(i).probInvert);
            probReverselist.add(themeUses.get(i).probReverse);
        }
        
       
        // find max of probability use to use that corresponding theme first
        double max = Collections.max(probUselist);
       // System.out.println(max);
        int index = probUselist.indexOf(max); //get the index of the max
        int length = themeUses.get(index).theme.melody.getSize(); 
        //get length of theme
        themeLength = length; //set themeLength to it
        MelodyPart solo = new MelodyPart(themeLength); 
        //set solo equal to a MelodyPart of the theme length

        imp.ImproVisor.setPlayEntrySounds(false); //don't play insertions yet

        solo.pasteSlots(themeUses.get(index).theme.melody, 0); 
        //paste theme into solo at starting point
        
        // set totals of probabilities to 0
        int probUsetotal = 0;
        int probTransposetotal = 0;
        int probInverttotal = 0;
        int probReversetotal = 0;

        //loop through each respective list and add elements together to get 
        //the total of each probability
        // multiply each element by 10 so its an integer
        for (int i = 0; i < themeUses.size(); i++) {
            probUsetotal += 10 * probUselist.get(i);
            probTransposetotal += 10 * probTransposelist.get(i);
            probInverttotal += 10 * probInvertlist.get(i);
            probReversetotal += 10 * probReverselist.get(i);
        }

        //set the variables the the very first themeUse and theme in the list to start with
        MelodyPart chosentheme = themeUses.get(0).theme.melody;
        ThemeUse chosenthemeUse = themeUses.get(0);


        for (int i = length; i <= notate.getScoreLength() - length; i += length) { //loop through the remaining length of the score

            int themei = random.nextInt(10 * probUselist.size() + 1);
            System.out.println(themei);
            //pick a random number from 0 inclusive to 10*the probability list size
            //since all the elements in the list are multpled by 10, the size has to be multiplied by 10 too

            //To implement the probabilities I broke up the size of the list times 10 into intervals
            //the first interval is from 0 to to the first probability - 1 so that way the number of slots in that interval is equal
            //to that first probability times 10
            //so if the random number chosen is in that interval, then that first theme is used
            if (themei <= 10 * probUselist.get(0) - 1) {
                System.out.println("Theme1");
                chosenthemeUse = themeUses.get(0);
                chosentheme = themeUses.get(0).theme.melody;
                MelodyPart adjustedTheme = generateSolohelper(chosenthemeUse, chosentheme, solo, cm);

                //this if takes care of the case if the index is out of bounds
                if (i + adjustedTheme.size() >= solo.getSize()) {
                    generateSolohelper2(themeLength, solo);
                } 
                
                else {// if there is no index out of bounds issue, then add the adjusted theme into the solo
                    solo.pasteSlots(adjustedTheme, i);
                }
            } //if the themeUses size is more than one themeuse then the other intervals have to be accounted for 
            
            else if (themeUses.size() > 1) {

                double A = 10 * probUselist.get(0);
                double B = 10 * probUselist.get(0) + 10 * probUselist.get(1);

                //the interval for the second ThemeUse
                if ((themei >= A) && (themei <= B - 1)) {
                    System.out.println("Theme2");
                    chosenthemeUse = themeUses.get(1);
                    chosentheme = themeUses.get(1).theme.melody;
                    MelodyPart adjustedTheme = generateSolohelper(chosenthemeUse, chosentheme, solo, cm);

                    if (i + adjustedTheme.size() >= solo.getSize()) {
                        generateSolohelper2(themeLength, solo);
                    } 
                    
                    else {
                        solo.pasteSlots(adjustedTheme, i);
                    }
                 }
                
                else {
                    //this loop covers the rest of the intervals
                    for (int k = 1; k < probUselist.size() - 1; k++) {
                        A += 10 * probUselist.get(k);
                        B += 10 * probUselist.get(k + 1);

                        if ((themei >= A) && (themei <= B - 1)) {
                            System.out.println("SubsequentThemes!");
                            chosenthemeUse = themeUses.get(k);
                            chosentheme = themeUses.get(k).theme.melody;
                            MelodyPart adjustedTheme = generateSolohelper(chosenthemeUse, chosentheme, solo, cm);

                            if (i + adjustedTheme.size() >= solo.getSize()) {
                                generateSolohelper2(themeLength, solo);
                            } 
                            
                            else {
                                solo.pasteSlots(adjustedTheme, i);
                            }
                        }
                    }
                }
            }

            //this interval is for not using any theme at all    
            if ((themei <= 10 * themeUses.size()) && (themei >= probUsetotal)) {
                System.out.println("noTheme");
                generateSolohelper2(themeLength, solo);
            }
        }


        if (notate.getScore().getLength() - solo.getSize() != 0) { //if the length of the score does not equal the length of the solo
            Polylist rhythm = lickgen.generateRhythmFromGrammar(0, notate.getScore().getLength() - solo.getSize());
            // generate rhythm for the space

            MelodyPart lick = fillMelody(BEAT, rhythm, notate.getChordProg(), 0); //create melody for the space

            Part.PartIterator j = lick.iterator(); //iterate over the lick
            while (j.hasNext()) //while lick has next
            {
                solo.addNote(NoteSymbol.toNote(j.next().toLeadsheet())); //add the note of the lick to the solo
            }
        }
        notate.setCurrentSelectionStart(0); //start selection at beginning

        // Experimental: Resolve pitches in entire solo: seems to improve things, but
        // may generate some repeated notes.
        cm.execute(new RectifyPitchesCommand(solo, 0, solo.getSize(), notate.getChordProg(), false, false));

        notate.pasteMelody(solo); //paste solo into leadsheet

        imp.ImproVisor.setPlayEntrySounds(true); //play solo
    }




    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JDialog AlreadyNamed;
    private javax.swing.JButton CancelButton;
    private javax.swing.JButton NoButton;
    private javax.swing.JButton NoOverwrite;
    private javax.swing.JButton Nodelete;
    private javax.swing.JButton OkButton;
    private javax.swing.JButton Okdelete;
    private javax.swing.JLabel OverwriteOption;
    private javax.swing.JButton Reset;
    private javax.swing.JLabel Resettable;
    private java.awt.Label SoloGeneratorTitle;
    private java.awt.Label ThemesLabel;
    private javax.swing.JButton YesButton;
    private javax.swing.JButton YesOverwrite;
    private javax.swing.JButton cellOkbutton;
    private javax.swing.JLabel chooseName;
    private java.awt.Button currentSelection;
    private javax.swing.JDialog deleteCheck;
    private javax.swing.JLabel deletesure;
    private javax.swing.JDialog enteredIncorrectly;
    private java.awt.Button generateSolo;
    private java.awt.Button generateTheme;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JDialog nameErrorMessage;
    private javax.swing.JTextField nameField;
    private javax.swing.JLabel namePicked;
    private java.awt.Button playSolo;
    private javax.swing.JDialog resetCheck;
    private javax.swing.JTable soloTable;
    private java.awt.Button stopPlaying;
    private javax.swing.JList themeList;
    private javax.swing.JLabel tryAgain;
    private javax.swing.JLabel typedWrong;
    private javax.swing.JLabel youSure;
    // End of variables declaration//GEN-END:variables
} 


