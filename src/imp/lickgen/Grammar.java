/**
 * This Java Class is part of the Impro-Visor Application
 *
 * Copyright (C) 2005-2014 Robert Keller and Harvey Mudd College
 *
 * Impro-Visor is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * Impro-Visor is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * merchantability or fitness for a particular purpose.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Impro-Visor; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

package imp.lickgen;

import imp.brickdictionary.Block;
import imp.data.Chord;
import imp.data.ChordPart;
import imp.data.Duration;
import imp.data.MelodyPart;
import imp.data.Part.PartIterator;
import imp.gui.Notate;
import imp.util.ErrorLog;
import imp.util.ErrorLogWithResponse;
import java.io.*;
import java.util.ArrayList;
import java.util.Collection;
import polya.Arith;
import polya.Polylist;
import polya.PolylistBuffer;
import polya.PolylistEnum;
import polya.Tokenizer;

/*
 * @author David Morrison, modifications by Robert Keller, 21 June 2012
 */

public class Grammar
{
// Rule tags:
public static final String START = "startsymbol";

public static final String TERMINAL = "terminals";

public static final String BASE = "base";

public static final String RULE = "rule";

public static final String PARAM = "parameter";

public static final String COMMENT = "comment";

// Special forms:
public static final String BUILTIN = "builtin";

public static final String SPLICE = "splice";

public static final String LITERAL = "literal";


// Operators:
public static final String PLUS = "+";

public static final String MINUS = "-";

public static final String TIMES = "*";

public static final String DIVIDE = "/";

// Builtin variables:

public static final String BRICK = "brick";

public static final String CHORD_FAMILY = "chord-family";

public static final String EXPECTANCY = "expectancy";

public static final String SYNCOPATION = "syncopation";

public static final String HIGH = "high";

public static final String MEDIUM = "medium";

public static final String LOW = "low";

public static final Double ONE = new Double(1);

public static final Double ZERO = new Double(0);


ArrayList<String> terminals = new ArrayList<String>();

Polylist rules = Polylist.nil;

String startSymbol = null; // to be set

private int retryCount = 0;

private Notate notate;

private int currentSlot;

private int chordSlot;

public Grammar(String file)
  {
  loadGrammar(file);
  }

/**
 * The current terminalString generated by the grammar.
 */

Polylist terminalString;


/**
 * Stack used to accumulate terminals to transfer to terminalString.
 */

Polylist accumulator = Polylist.nil;


int numSlots;

/**
 * Transfers terminals from accumulator, which is behaving as a stack,
 * to terminalString, which is behaving as a queue.
 */

private void accumulateTerminals()
  {
    if( accumulator.isEmpty() )
      {
        return; // nothing to accumulate
      }
    //ChordPart chords = notate.getChordProg();
    //Chord currentChord = chords.getCurrentChord(chordSlot);
    //System.out.println("\nat slot " + chordSlot + " " + currentChord + " accumulating " + accumulator);
    
    terminalString = terminalString.append(accumulator);
    //System.out.println("new terminalString = " + terminalString);
    
    for( Polylist L = accumulator; L.nonEmpty(); L = L.rest() )
      {
      int duration = getDuration(L.first());
      chordSlot += duration;
      numSlots -= duration;
      }
    
    accumulator = Polylist.nil;
    //System.out.println("slot now = " + chordSlot);
  }


/**
 * Applies grammar rules to generate a lick
@param data the number of slots to be filled
@return
 */

// This code is kind of hacked. First gen should be called in a functional style.
// The other issue is that applyRules sometimes fails when run on a generated
// grammar. We have tried to arrange this failure to take the form of an exception,
// and will then simply try again, until a terminal string is generated.

public Polylist run(int startSlot, int initialNumSlots, Notate myNotate)
  {
    currentSlot = startSlot;
    chordSlot = startSlot;
    numSlots = initialNumSlots;
    int savedRetryCount = retryCount;
    int maxRetries = 20;
    notate = myNotate;
    
    terminalString = Polylist.nil;
    int stage = 0;
    
    while( numSlots > 0 ) //(retryCount - savedRetryCount) <= maxRetries )
      {
        try
          {
            stage++;
            Polylist gen = addStart(numSlots);
            
            if( gen == null )
              {
                return Polylist.nil;    // In case no grammar
              }
            
            //ySystem.out.println("\nStage " + stage + " generation starts with " + gen + " terminalString length " + getDurationAbstractMelody(terminalString));
            
            // gen is a list representing the undeveloped frontier of the rhs tree
            // symbols in gen are expanded one at a time, left-to-right
            // As non-terminal are expanded, the RHS replaces the non-terminal
            // on the left of gen.
            // If the top of gen is a terminal, it is flipped over onto 
            // accumulator, and then appended to terminalString.

            // So the combination of terminalString and gen represent the total
            // frontier of the rhs tree.
            // The variable terminalString is modified implicitly within applyRules.

            while( gen.nonEmpty() )
              {
                // System.out.println("gen = " + gen);  // Shows rhs.
                gen = applyRules(gen);

                if( gen == null )
                  {
                  throw new RuleApplicationException();
                  //return null;
                  }
                
                accumulateTerminals();
              }
            //accumulateTerminals();
            //return terminalString;
          }
        catch( RuleApplicationException e )
          {
          if( ErrorLogWithResponse.log(ErrorLog.SEVERE, "Problem applying rules: " + e) )
            {
              return null;
            }
          }
      notate.setLickGenStatus("Retrying lick generation (" + (++retryCount) + " cumulative).");
      }
    //ySystem.out.println("completed in " + stage + " stages" + ". terminalString length " + getDurationAbstractMelody(terminalString));

    return truncateAbstractMelody(terminalString, initialNumSlots);
//    notate.setLickGenStatus("Unable to generate in " + maxRetries + " retries.");
//    return null;
  }


/**
 * Add the Start Symbol to list gen in order to start the grammar expansion.
 */

public Polylist addStart(int numSlots)
  {
  Polylist gen = Polylist.nil;
  Polylist search = rules;

  // While the list of rules isn't empty...
  while( search.nonEmpty() )
    {
    Polylist next = (Polylist)search.first();
    search = search.rest();

    try
      {
      // ... See if the next rule contains the "startsymbol" tag.
      // If it does, pop it on the front of the string.
      if( ((String)next.first()).equals(START) )
        {
        if( next.length() == 2 && next.second() instanceof String )
          {
          startSymbol = (String)next.second();
          
          Polylist s = Polylist.list(startSymbol, numSlots);
          gen = gen.cons(s);
          return gen;
          }
        else
          {
          ErrorLog.log(ErrorLog.SEVERE,
                  "Malformed start rule: " + next + ".  Abort.");
          return null;
          }
        }
      }
    // Catch any syntax errors in the rule file.  At some point it might
    // be nice to actually print out what the problem is...
    catch( ClassCastException e )
      {
      ErrorLog.log(ErrorLog.SEVERE, "Malformed rules file.  Abort.");
      return null;
      }
    }

  // If it didn't find a start symbol in the file, abort.
  ErrorLog.log(ErrorLog.SEVERE, "No start symbol found.  Abort.");
  return null;
  }

/**
 * Returns true if ob is considered a terminal in the grammar.
 * @param ob
 * @return 
 */
public boolean isTerminal(Object ob)
  {
    return isAbstractNote(ob)
        || isScaleDegree(ob) 
        || isSlope(ob) 
        || isTriadic(ob) 
        || isWrappedTerminal(ob);
  }

public boolean isAbstractNote(Object ob)
  {
    if( !(ob instanceof String) )
      {
        return false;
      }
    
    String string = (String)ob;
    int len = string.length();
    if( len == 0 )
      {
        return false;
      }
    
    char first = string.charAt(0);
    String rest = string.substring(1);
    switch( first )
      {
        case 'A':
        case 'C':
        case 'H':
        case 'L':
        case 'R':
        case 'S':
        case 'X':
        case 'Y':
            break;
        default:
            return false;
      }
        //System.out.print("string = " + string);
        boolean isDuration  = Duration.isDuration(rest);
        //System.out.println(" isAbstractNote = " + isDuration);
        return  isDuration;
  }

public boolean isTerminalSpecifiedInFile(Object ob)
  {
    if( terminals.contains(ob) )
      {
        return true;
      }
    return false;
  }

public boolean isWrappedTerminal(Object ob)
  {
    if( !(ob instanceof Polylist) )
      {
        return false;
      }
    
    if( isScaleDegree(ob) || isSlope(ob) || isTriadic(ob) )
      {
        return false;
      }
    
    Polylist oblist = (Polylist) ob;
    
    if( oblist.isEmpty() )
      {
        return false;
      }
    
    return  isAbstractNote(oblist.first()); //isTerminalSpecifiedInFile(oblist.first());
  }

public static boolean isSlope(Object ob)
  {
    if( !(ob instanceof Polylist) )
      {
        return false;
      }
    
    Polylist oblist = (Polylist)ob;
    
    if( oblist.length() < 4 )
      {
        return false;
      }
    
    if( !oblist.first().equals("slope") )
      {
        return false;
      }
    
    return true;
  }

public static boolean isTriadic(Object ob)
  {
    if( !(ob instanceof Polylist) )
      {
        return false;
      }
    
    Polylist oblist = (Polylist)ob;
    
    if( oblist.length() != 3 )
      {
        return false;
      }
    
    if( !oblist.first().equals("triadic") )
      {
        return false;
      }
    
    return true;
  }

public static boolean isScaleDegree(Object ob)
  {
    if( !(ob instanceof Polylist ) )
      {
        return false;
      }
    
    Polylist oblist = (Polylist)ob;
    
    if( oblist.length() != 3 )
      {
        return false;
      }
    
    Object first = oblist.first();
    
    if( !(first instanceof String) )
      {
        return false;
      }
       
    if( !("X".equals((String)first)) )
      {
        return false;
      }
    
    Object second = oblist.second();
    
    if( !(second instanceof Long || second instanceof String ) )
      {
        return false;
      }
    
    Object third = oblist.third();
 
    if( !(third instanceof Long || third instanceof String ) )
      {
        return false;
      }
    return true;
  }

/**
 * Get the duration of various terminals.
 * This is used in calculating chordSlot, for example.
 * @param ob
 * @return 
 */
public static int getDuration(Object ob)
  {
    //System.out.print("duration of " + ob + " = ");
    int result = 0;
    
    if( ob instanceof String )
      {
        result = Duration.getDuration(((String)ob).substring(1));
      }
    else if( isScaleDegree(ob) )
      {
        result = Duration.getDuration(((Polylist) ob).third().toString());
      }
    else if( isSlope(ob) )
      {
        // Get the tail from the fourth element on
        Polylist body = ((Polylist)ob).rest().rest().rest();
        int sum = 0;
        while( body.nonEmpty() )
          {
            sum += getDuration(body.first());
            body = body.rest();
          }
        result = sum;
      }
    else if( isTriadic(ob) )
      {
        result = Duration.getDuration(((Polylist)ob).second().toString());
      }
    
    //System.out.println(result);
    
    return result;
  }

public static int getDurationAbstractMelody(Polylist L)
  {
    int duration = 0;
    while( L.nonEmpty() )
      {
        duration += getDuration(L.first());
        L = L.rest();
      }
    return duration;
  }

public static Polylist truncateAbstractMelody(Polylist L, int desiredDuration)
  {
    PolylistBuffer buffer = new PolylistBuffer();
    int duration = 0;
    while( L.nonEmpty() )
      {
        Object first = L.first();
        int dur = getDuration(first);
        if( duration + dur > desiredDuration )
          {
            break;
          }
        buffer.append(first);
        duration += dur;
        L = L.rest();
      }
    return buffer.toPolylist();    
  }

/**
 * Add the rhs of a rule to the appropriate list, assuming that the
 * value of the weight expression is positive
 * @param rhs
 * @param wtExp
 * @param ruleList 
 */
private void addToList(Polylist rhs, Object wtExp, ArrayList<WeightedRHS> ruleList)
  {
  Object wt = evaluate(wtExp);
  if( wt instanceof Number )
    {
      Double weight = ((Number) wt).doubleValue();
      if( weight >= 0 )
        {
          ruleList.add(new WeightedRHS(rhs, weight));
        }
    }
  else
    {
      ErrorLog.log(ErrorLog.WARNING, "Invalid weight expression in grammar rule: " + wtExp);
    }
  }


/**
 * Pop tokens off the gen stack.
 * Any terminal tokens are pushed onto accumulator.
 * Rules are applied to non-terminals.
 */

public Polylist applyRules(Polylist gen) throws RuleApplicationException
  {
    // We need to be given a non-empty polylist.
    if( gen.isEmpty() )
      {
        ErrorLog.log(ErrorLog.SEVERE, "applyRules passed empty polylist.  Abort.");
        return null;
      }

     Object pop = gen.first();

     gen = gen.rest();

    // Accumulate any terminal values.

    accumulator = Polylist.nil;
       
      while( isTerminal(pop) )
          {
          if( isWrappedTerminal(pop) )
          {
              accumulator = accumulator.cons(((Polylist)pop).first());
          }
        else
          {
            accumulator = accumulator.cons(pop);
          }
    
           if( gen.isEmpty() || numSlots <= 0 )
            {
            accumulateTerminals();
            return gen;
            }

          pop = gen.first();
          gen = gen.rest();
        }

      accumulateTerminals();
//      if( numSlots <= 0 )
//            {
//            return gen;
//            }
      
      // All applicable rules (and their corresponding weights)
      // get loaded into these arrays, to be selected from at random.
      ArrayList<Polylist> ruleArray = new ArrayList<Polylist>(5);
      ArrayList<Polylist> baseArray = new ArrayList<Polylist>(5);
      ArrayList<Double> ruleWeights = new ArrayList<Double>(5);
      ArrayList<Double> baseWeights = new ArrayList<Double>(5);

    Polylist search = rules;
    
      // Now search through and find all rules that apply to the given start symbol.
      // Note that a start symbol can be a polylist.
      while( search.nonEmpty() )
      {
        // Next is the next rule to compare to
        Polylist next = (Polylist)search.first();
        String type = (String)next.first();
        //System.out.println("\nnext = " + next);

      //System.out.println("matching LHS " + goal);
      /*
       * RULEs and BASEs have the following S-expression format:
       * (<keyword> (<LHS symbol>) (<RHS>) weight)
       * <keyword> can be "rule" or "base"
       * <LHS symbol> can be a string or a polylist of strings
       * <RHS> is a polylist of symbols (or if it's a RULE, some expressions
       *	to evaluate).
       * <weight> is a double expressing how "important" the rhs is.  More important
       *	rules will be chosen more often than less important ones.
       */

      // The BASE keyword stops all evalution and variable substitution.
      // If a lhs matches both a RULE and a BASE, it will always choose the BASE.
      // This basically short-circuits any computation and provides an easy way
      // to find base cases.
        
//        if( numSlots <= 0 )
//          {
//          System.out.println("terminals: " + terminalString);
//          return gen;            
//          }
//        else 
            if( type.equals(BASE) && next.length() == 4 )
        {
          //System.out.println("\nbase = " + next);
          Object symbol = next.second();
          Polylist derivation = (Polylist)next.third();

          if( pop.equals(symbol) )
            {
            baseArray.add(derivation);
            Number weight = (Number)evaluate(next.fourth());
            baseWeights.add(weight.doubleValue());
            }
        }
      // Most objects will have type RULE.
        else if( type.equals(RULE) && next.length() == 4 )
        {
          //System.out.println("\nrule = " + next);
          Object symbol = next.second();
          Polylist derivation = (Polylist)next.third();

          //System.out.println(" rhs before evaluation  " + rhs);

          // The first symbol can never be a variable, it will give the "name" of the
          // rhs.  All additional symbols will contain information.
          //System.out.println("pop = " + pop);

          if( pop instanceof Polylist && ((Polylist)pop).first() instanceof String )
            {
            if( ((String)((Polylist)pop).first()).equals(((Polylist)symbol).first()) )
            {
              // Fill in variables with their given numeric values.
              derivation = setVars((Polylist)pop, (Polylist)symbol, derivation);
              
              // A null result means that unification failed.
              if( derivation == null )
                {
                search = search.rest();
                continue;
                }
              
              //System.out.println(" derivation after setVars " + derivation);
              
              // Evaluate any expressions that need to be evaluated.
              derivation = (Polylist)evaluate(derivation);
              
              //System.out.println(" derivation after evaluation of " + pop + ": " + derivation);
              
              // Check for negative arguments in RHS,
              // In which case don't use RHS
              boolean valid = true;
              PolylistEnum L = derivation.elements();
              polya.PolylistBuffer B = new polya.PolylistBuffer();
              while( L.hasMoreElements() )
              {
                Object ob = L.nextElement();
                if( ob instanceof Polylist )
                {
                  Polylist P = (Polylist)ob;
              
                  if( P.length() == 2 && P.first().equals(startSymbol) ) 
                {
                  // We found the start symbol on the RHS.
                  // Only pass it if argument is non-negative.
                  // FIX: Replace this with a more sound mechanism.

                    Object arg = P.second();
                    if( arg instanceof Number && ((Number)arg).intValue() <= 0 )
                    {
                      //valid = false;
                      //System.out.println("abandoning: " + derivation);
                      //break;
                    }
              else B.append(ob);
                }
              else B.append(ob);
                }
              else B.append(ob);
              } // while
              
              derivation = B.toPolylist();
            
              if( valid )
                {
                Object wt = evaluate(next.fourth());
                if( wt instanceof Number )
                  {
                  Double weight = ((Number)wt).doubleValue();
                  if( weight >= 0 )
                    {
                    ruleArray.add(derivation);
                    ruleWeights.add(weight);
                    //System.out.println("Adding with weight " + weight + " derivation " + derivation);
            }
                  }
          else
            {
                  ErrorLog.log(ErrorLog.WARNING, "Invalid weight in grammar rule: " + next);
            }
                }
              }
            }
          else
            {
            Object wt = evaluate(next.fourth());
            if( wt instanceof Number )
              {
              // This RHS element is not a string. Just carry it and hope for the best!
              // It is probably an S-expression such as (slope M N ...)
              Double weight = ((Number)wt).doubleValue();
              if( weight >= 0 )
                {
                ruleArray.add(derivation);
                ruleWeights.add(weight);
                //System.out.println("Adding with weight " + weight + " derivation " + derivation);
                }
              }
            else
              {
              ErrorLog.log(ErrorLog.WARNING, "Invalid weight in grammar rule: " + next);
              }
            }
          //Otherwise ignore, as it may be a parameter, etc.
        }
      search = search.rest();
    }

      // Randomly choose a rule to follow.
      double total = 0.0;

      ArrayList<Polylist> rulesList;
      ArrayList<Double> weightArray;

      // If any base cases exist, we ignore all rules.
      if( !baseWeights.isEmpty() )
      {
        rulesList = new ArrayList<Polylist>(baseArray);
        weightArray = new ArrayList<Double>(baseWeights);
      }
      else
      {
        rulesList = new ArrayList<Polylist>(ruleArray);
        weightArray = new ArrayList<Double>(ruleWeights);
          }

      //System.out.println("rules = " + rules);
    
      // Sum up all the weights to use in a weighted average.	    
      for( int i = 0; i < weightArray.size(); ++i )
      {
        total += weightArray.get(i);

        // Generate a random number to find out which rule to use...
      }
      double rand = Math.random();
      double offset = 0.0;

      int weightSize = weightArray.size();
      // Loop through all rules.
      for( int i = 0; i < weightSize; ++i )
      {
        // If the random number falls between the range of the probability 
        // for that rule, we choose it and break out of the loop.
        if( rand >= offset && rand < offset + (weightArray.get(i) / total) )
      {
          Polylist rule = rulesList.get(i);

          for( Polylist L = rule; L.nonEmpty(); L = L.rest() )
          {
            Object ob = L.first();

            if( ob instanceof Polylist )
              {
                gen = gen.cons(ob);
              }
            else
              {
                gen = gen.cons(Polylist.list(ob));
              }
            //System.out.println("gen = " + gen);
          }
          //System.out.println("terminals: " + terminalString);
          accumulateTerminals();
          return gen;
          
      }
        offset += weightArray.get(i) / total;
        }
      if( weightSize > 0 )
        {
          gen = gen.cons(rulesList.get(weightSize-1));
          //ySystem.out.println("using a backup rule for "  + pop);
        }
      else
        {
        //ySystem.out.println("failed to find rule out of " + weightSize + " possible for " + pop);
        }
    accumulateTerminals();
    //System.out.println("terminals: " + terminalString);
    return gen; // throw new RuleApplicationException("applyRules, no such rule for " + gen);
  }

/**
 * Load in any terminal values specified in the user file.  Returns a ArrayList containing
 * all terminal values.
 */

public ArrayList<Object> getAllOfType(String t)
  {
  Polylist search = rules;
  ArrayList<Object> elements = new ArrayList<Object>();
  while( search.nonEmpty() )
    {
    try
      {
      Polylist next = (Polylist)search.first();
      String type = (String)next.first();

      if( type.equals(t) )
        {
        for( int i = 1; i < next.length(); ++i )
          {
          elements.add(next.nth(i));
          }
        }
      search = search.rest();
      }
    catch( ClassCastException e )
      {
      ErrorLog.log(ErrorLog.SEVERE, "Error parsing " + t);
      return null;
      }
    }

  return elements;
  }

///**
// * Get all the allowable terminal symbols, as specified in the grammar file.
// */
//
//public ArrayList<String> getTerminals()
//  {
//  Collection terms = (Collection)getAllOfType(TERMINAL);
//  if( terminals == null )
//    {
//    return new ArrayList<String>(); // empty
//    }
//  return new ArrayList<String>(terms);
//  }


public void clearParams()
  {
  Polylist newRules = Polylist.nil;

  while( rules.nonEmpty() )
    {
    if( !((String)((Polylist)rules.first()).first()).equals(PARAM) )
      {
      newRules = newRules.cons(rules.first());
      }
    rules = rules.rest();
    }

  newRules = newRules.reverse();
  rules = newRules;
  }


public ArrayList<Polylist> getParams()
  {
  return new ArrayList<Polylist>((Collection)getAllOfType(PARAM));
  }


public Polylist addRule(Polylist toAdd)
  {
  rules = rules.cons(toAdd);
  return rules;
  }


public Polylist getRules()
  {
  return rules;
  }

// Load the rules in from a file.

public int loadGrammar(String filename)
  {
  //System.out.println("Grammar loadGrammar " + filename);
  try
    {
    Tokenizer in = new Tokenizer(new FileInputStream(filename));
    Object ob;

    while( (ob = in.nextSexp()) != Tokenizer.eof )
      {
      //System.out.println("ob = " + ob);
      if( ob instanceof Polylist )
        {
        rules = rules.cons((Polylist)ob);
        }
      }
    rules = rules.reverse();
    //terminals = getTerminals();
    return 0;
    }
  catch( FileNotFoundException e )
    {
    ErrorLog.log(ErrorLog.SEVERE, "File " + filename + " not found.  Abort.");
    return -1;
    }
  }


public int saveGrammar(String filename)
  {
  try
    {
    Polylist toWrite = rules;
    String contents = "";
    while( toWrite.nonEmpty() )
      {
      contents += toWrite.first() + "\n";
      toWrite = toWrite.rest();
      }
    FileWriter out = new FileWriter(new File(filename));
    out.write(contents);
    out.close();
    return 0;
    }
  catch( IOException e )
    {
    ErrorLog.log(ErrorLog.WARNING, "Error saving to " + filename);
    return -1;
    }
  }


public void clear()
  {
  rules = Polylist.nil;
  terminalString = Polylist.nil;
  }

/**
 * Set all instances of variables in toSet corresponding value in getValsFrom.
 * This is a unilateral unification.
 */

private Polylist setVars(Polylist getValsFrom, 
                         Polylist getVarsFrom,
                         Polylist toSet)
  {
  // skip first element, which is a functor
  Polylist vars = getVarsFrom.rest();
  Polylist vals = getValsFrom.rest();
  while( vars.nonEmpty() && vals.nonEmpty() )
    {
      Object var = vars.first();
      Object val = vals.first();
      if( (var instanceof Number) && (val instanceof Number) )
        {
          if( ((Number)var).longValue() != ((Number)val).longValue() )
            {
              return null;  // not unifiable
            }
        }
      else if( (var instanceof String) && (val instanceof Number) )
        {
        toSet = replace(var.toString(), ((Number)val).longValue(), toSet);
        }
      else if( (var instanceof String) && (val instanceof String) )
        {
          if( !var.equals(val ) )
            {
             return null;  // not unifiable  
            }
        }
      else
        {
          return null; // not unifiable
        }

      vars = vars.rest();
      vals = vals.rest();
    }
  return toSet;
  }

// Evaluate will take an object and perform arithmetic evaluation on it.
// Expressions should be given in prefix form:
// (+ 3 4) evaluates to 7
// (+ (/ 4 2) (* 7 3)) evaluates to 23
//
// As of 21 June 2012, evaluate can accept builtins, of the form
// (builtin <some identifier>)
// Right now, the only identifier is "expectancy". Evaluation of this identifier
// is stubbed to return 1. Any other identifier will return 0.
// Eventually, the value of the builtin identifier may change depending on the
// then-current slot.

private Object evaluate(Object toParse)
  {
  //System.out.println("currentSlot = " + currentSlot);
  // Base case:
  if( toParse instanceof Number || toParse instanceof String )
    {
    return toParse;
    }
  else if( toParse instanceof Polylist && ((Polylist)toParse).nonEmpty() )
    {
    try
      {
      // Recursively evaluate until we get down to two numbers we can add.
      Polylist parsing = (Polylist)toParse;
      
      if( BUILTIN.equals(parsing.first()) )
        {
        return evaluateBuiltin(parsing.second(), parsing.third());
        }
      else if( PLUS.equals(parsing.first()) )
        {
        return Arith.add(evaluate(parsing.second()), evaluate(parsing.third()));
        }
      else if( MINUS.equals(parsing.first()) )
        {
        return Arith.subtract(evaluate(parsing.second()), evaluate(parsing.third()));
        }
      else if( TIMES.equals(parsing.first()) )
        {
        return Arith.multiply(evaluate(parsing.second()), evaluate(parsing.third()));
        }
      else if( DIVIDE.equals(parsing.first()) )
        {
        return Arith.divide(evaluate(parsing.second()), evaluate(parsing.third()));
        }
      else
        {
        Polylist p = Polylist.nil;
        Polylist L = parsing;
        while( L.nonEmpty() )
          {
            p = Polylist.cons(evaluate(L.first()), p);
            L = L.rest();
          }
        p = p.reverse();
        return p;
        }
      }
    catch( ClassCastException e )
      {
      ErrorLog.log(ErrorLog.SEVERE, "Bad cast operation in evaluation of " + toParse);
      return null;
      }
    }
  else
    {
    return null;
    }
  }
/**
 * Evaluate the rest of a special form (splice <operator> <arg> ...)
 * (<operator> <arg> ...) must return a list.
 * Currently the only operator available is literal, e.g.
 * a rule RHS of the form
 * (C4 (splice literal C8 C8) (splice literal C16 C16 C16 C16) R4)
 * returns (C4 C8 C8 C16 C16 C16 C16 R4)
 * 
 * It is expected that additional splice-oriented operators will be added,
 * and not all will just use literal arguments.
 * 
 * @param form
 * @return 
 */

Polylist evaluateSplice(Polylist form)
  {
    if( form.isEmpty() )
      {
        return Polylist.nil;
      }
    
    Object operator = form.first();
    Polylist args = form.rest();
    
    if( LITERAL.equals(operator) )
      {
        return args;
      }
    if(SYNCOPATION.equals(operator))
    {
        MelodyPart melody = notate.getCurrentMelodyPart();    
        MelodyPart currMelody = melody.extract(currentSlot - LENGTH_OF_TRADE, currentSlot);
        int[] syncVector = currMelody.getSyncVector(15, LENGTH_OF_TRADE);
        int measures = LENGTH_OF_TRADE/SLOTS_PER_MEASURE;
        int synco = Tension.getSyncopation(syncVector, measures);
        //Generates a syncopation that matches the syncopation of the previous 4 bars
        int[] rhythm = Generator.generateSyncopation(measures, synco);
        String[] rhythmArray = Generator.generateString(rhythm, (String)args.first());
        Polylist rhythmList = Polylist.PolylistFromArray(rhythmArray);
        return rhythmList;
    }
    // default
    
    return Polylist.nil;
  }

public int getCurrentSlot()
{
    return currentSlot;
}

// For testing purposes only:

int expectancyValue = 0;
int syncopationValue = 1;

private static int LENGTH_OF_TRADE = 4*480;
private static int SLOTS_PER_MEASURE = 480;

/**
 * Evaluates the arguments following the builtin operator. 
 * So far only implemented for expectancy and syncopation
 * @param arg1
 * @param arg2
 * @return 
 */
private Object evaluateBuiltin(Object arg1, Object arg2)
{
  //System.out.println("\nevaluate-builtin " + arg1 + " " + arg2);
  
    ChordPart chords = notate.getChordProg();
    if( arg1 instanceof String && ((String)arg1).equals(CHORD_FAMILY) )
      {
        if( !(arg2 instanceof Polylist) )
          {
            return 0;
          }
        
        Polylist families = (Polylist)arg2;
        
        Chord currentChord = chords.getCurrentChord(chordSlot);
        
        if( currentChord == null )
          {
            return ZERO;
          }
        
        return families.member(currentChord.getFamily()) ? ONE : 0.1;
      }
    // Is evaluable of the form (builtin brick <brickname>)
    if( BRICK.equals(arg1) )
      {
        //System.out.println("evaluating brick at slot " + chordSlot);
        if( !(arg2 instanceof String) )
          {
            return ZERO;
          }
        
        String brickname = (String)arg2;
        
        notate.ensureRoadmap();
        Block currentBlock = chords.getBlockAtSlot(chordSlot);
        
        if( currentBlock == null )
          {
            return ZERO;
          }
        
        String blockName = currentBlock.getDashedName();
        
        if( brickname.equals(blockName) )
          {
            System.out.println("At slot " + chordSlot 
                             + " considering brick " + brickname);
            return ONE;
          }
        
       //System.out.println("At slot " + chordSlot 
       //           + " brickname " + brickname + " doesn't match " + blockName);
       
       return 0.1; //ZERO;
       }
    MelodyPart melody = notate.getCurrentMelodyPart();    
    MelodyPart currMelody = melody.extract(currentSlot - LENGTH_OF_TRADE, currentSlot);
    if( EXPECTANCY.equals(arg1) )
    {
        int firstIndex = currMelody.getNextIndex(0);
        int secondIndex = currMelody.getNextIndex(firstIndex);
        if(currMelody.getNote(firstIndex) == null || currMelody.getNote(secondIndex) == null)
        {
            return ONE;
        }
        PartIterator pi = currMelody.iterator(secondIndex);
        int numPitches = 2;
        double totalExpectancy = 0;
        while(pi.hasNext())
        {
            Chord c = chords.getChord(pi.nextIndex());
            int first = currMelody.getNote(firstIndex).getPitch();
            int second = currMelody.getNote(secondIndex).getPitch();
            int curr = currMelody.getNote(pi.nextIndex()).getPitch();
            double expectancy = Expectancy.getExpectancy(curr, second, first, c);
            totalExpectancy += expectancy;
            numPitches ++;
            firstIndex = secondIndex;
            secondIndex = pi.nextIndex();
            pi.next();
        }
        return new Double (totalExpectancy/numPitches);
    }
    if(SYNCOPATION.equals(arg1))
    {
        int[] syncVector = currMelody.getSyncVector(15, LENGTH_OF_TRADE);
        int synco = Tension.getSyncopation(syncVector, (LENGTH_OF_TRADE/SLOTS_PER_MEASURE));
        //System.out.println(synco);
        double syncoPerMeasure = synco/(LENGTH_OF_TRADE/SLOTS_PER_MEASURE);
        //System.out.println("Syncopation per measure " + syncoPerMeasure);
        if(arg2.equals(HIGH))
        {
            if(syncoPerMeasure >= 8)
            {
                //System.out.println("High");
                return new Double(0.8);
            }
            else
            {
                return new Double(0.1);
            }
        }
        if(arg2.equals(MEDIUM))
        {
            if(syncoPerMeasure < 8 && syncoPerMeasure >= 4)
            {
                //System.out.println("Medium");
                return new Double(0.8);
            }
            else
            {
                return new Double(0.1);
            }
        }
        if(arg2.equals(LOW))
        {
            if(syncoPerMeasure < 4)
            {
                //System.out.println("Low");
                return new Double(0.8);
            }
            else
            {
                return new Double(0.1);
            }
        }
        return ZERO;
    }
    return ZERO;
}

// Recursively replace all instances of varName with value in toReplace

private Polylist replace(String varName, Long value, Polylist toReplace)
  {
  Polylist toReturn = Polylist.nil;
  
  Polylist L = toReplace;
  
  while( L.nonEmpty() )
    {
    if( L.first() instanceof Polylist )
      {
      toReturn = toReturn.cons(replace(varName, value, (Polylist)L.first()));
      }
    else if( varName.equals(L.first()) )
      {
      toReturn = toReturn.cons(value);
      }
    else
      {
      toReturn = toReturn.cons(L.first());
      }
    L = L.rest();
    }
  //System.out.println("replace var " + varName + " with " + value + " in " + toReplace + " giving " + toReturn.reverse());
  return toReturn.reverse();
  }

/**
 * Inner class representation of rhs right-hand sides (RHS)
 * with weights, for probabilistic evaluation.
 */
class WeightedRHS
  {
  Object rhs;
  double weight;
  
  WeightedRHS(Object rhs, double weight)
    {
     this.rhs = rhs;
     this.weight = weight;
}

  Polylist getRHS()
    {
      return rhs instanceof Polylist? (Polylist)rhs : Polylist.list(rhs);
    }
  
  double getWeight()
    {
      return weight;
    }
  
  @Override
  public String toString()
    {
      Polylist rhsList = (Polylist)rhs;
      return "weight " + weight 
           + " dur " + getDurationAbstractMelody(rhsList) + " " 
           + rhsList;
    }
  }
}
